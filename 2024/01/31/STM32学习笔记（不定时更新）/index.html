<!DOCTYPE html><html lang="en" theme-mode="dark"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>STM32学习笔记1（不定时更新） | Passenger's Blog</title><link rel="icon" type="image/x-icon" href="/favicon.ico"><script>var config = {"root":"/","search":{"preload":false,"activeHolder":"键入以继续","blurHolder":"数据检索","noResult":"无 $0 相关数据"},"code":{"codeInfo":"$0 - $1 行","copy":"复制"}}</script><script src="//unpkg.com/valine/dist/Valine.min.js"></script><script src="/js/gitalk.js"></script><script src="//unpkg.com/mermaid@10.5.0/dist/mermaid.min.js"></script><script>mermaid.initialize({startOnLoad: false});</script><script src="//cdnjs.cloudflare.com/ajax/libs/mathjax/2.6.1/MathJax.js"></script><script>MathJax.Hub.Config({
 menuSettings: {
   zoom: "None"
 },
 showMathMenu: false,
 jax: ["input/TeX","output/CommonHTML"],
 extensions: ["tex2jax.js"],
 TeX: {
   extensions: ["AMSmath.js","AMSsymbols.js"],
   equationNumbers: {
     autoNumber: "AMS"
   }
 },
 tex2jax: {
   inlineMath: [["\\(", "\\)"]],
   displayMath: [["\\[", "\\]"]]
 }
});</script><link type="text/css" rel="stylesheet" href="/lib/encrypt/hbe.style.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lightgallery.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-zoom.css"><link type="text/css" rel="stylesheet" href="//unpkg.com/lightgallery@2.7.1/css/lg-thumbnail.css"><link type="text/css" rel="stylesheet" href="/lib/fontawesome/css/all.min.css"><link rel="stylesheet" href="/css/arknights.css"><script>if (window.localStorage.getItem('theme-mode') === 'light')
 document.documentElement.setAttribute('theme-mode', 'light')
if (window.localStorage.getItem('theme-mode') === 'dark')
 document.documentElement.setAttribute('theme-mode', 'dark')</script><style>@font-face {
 font-family: Bender;
 src: local('Bender'), url("/font/Bender.ttf"), url("/font/Bender.otf");
}
@font-face {
 font-family: BenderLight;
 src: local('BenderLight'), url("/font/BenderLight.ttf");
}
@font-face {
 font-family: 'JetBrains Mono';
 src: local('JetBrains Mono'), url('/font/JetBrainsMono-Regular.woff2') format('woff2');
}</style><style>:root {
  --dark-background: url('https://ak.hypergryph.com/assets/index/images/ak/pc/bk.jpg');
  --light-background: url('/img/bk.jpg');
  --theme-encrypt-confirm: '确认'
}</style><!-- hexo injector head_end start -->
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css">

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/hexo-math@4.0.0/dist/style.css">
<!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"><style>mjx-container[jax="SVG"] {
  direction: ltr;
}

mjx-container[jax="SVG"] > svg {
  overflow: visible;
}

mjx-container[jax="SVG"][display="true"] {
  display: block;
  text-align: center;
  margin: 1em 0;
}

mjx-container[jax="SVG"][justify="left"] {
  text-align: left;
}

mjx-container[jax="SVG"][justify="right"] {
  text-align: right;
}

g[data-mml-node="merror"] > g {
  fill: red;
  stroke: red;
}

g[data-mml-node="merror"] > rect[data-background] {
  fill: yellow;
  stroke: none;
}

g[data-mml-node="mtable"] > line[data-line] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > rect[data-frame] {
  stroke-width: 70px;
  fill: none;
}

g[data-mml-node="mtable"] > .mjx-dashed {
  stroke-dasharray: 140;
}

g[data-mml-node="mtable"] > .mjx-dotted {
  stroke-linecap: round;
  stroke-dasharray: 0,140;
}

g[data-mml-node="mtable"] > svg {
  overflow: visible;
}

[jax="SVG"] mjx-tool {
  display: inline-block;
  position: relative;
  width: 0;
  height: 0;
}

[jax="SVG"] mjx-tool > mjx-tip {
  position: absolute;
  top: 0;
  left: 0;
}

mjx-tool > mjx-tip {
  display: inline-block;
  padding: .2em;
  border: 1px solid #888;
  font-size: 70%;
  background-color: #F8F8F8;
  color: black;
  box-shadow: 2px 2px 5px #AAAAAA;
}

g[data-mml-node="maction"][data-toggle] {
  cursor: pointer;
}

mjx-status {
  display: block;
  position: fixed;
  left: 1em;
  bottom: 1em;
  min-width: 25%;
  padding: .2em .4em;
  border: 1px solid #888;
  font-size: 90%;
  background-color: #F8F8F8;
  color: black;
}

foreignObject[data-mjx-xml] {
  font-family: initial;
  line-height: normal;
  overflow: visible;
}

.MathJax path {
  stroke-width: 3;
}

mjx-container[display="true"] {
  overflow: auto hidden;
}

mjx-container[display="true"] + br {
  display: none;
}
</style></head><body><div class="loading" style="opacity: 0;"><div class="loadingBar left"></div><div class="loadingBar right"></div></div><main><header class="closed"><div class="navBtn"><i class="navBtnIcon"><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span><span class="navBtnIconBar"></span></i></div><nav><div class="navItem" id="search-header"><span class="navItemTitle"><input autocomplete="off" autocorrect="off" autocapitalize="none" placeholder="数据检索" spellcheck="false" maxlength="50" type="text" id="search-input"></span></div><div class="navItem" id="search-holder"></div><div class="search-popup"><div id="search-result"></div></div><ol class="navContent"><li class="navItem"><a class="navBlock" href="/"><span class="navItemTitle">Home</span></a></li><li class="navItem" matchdata="categories,tags"><a class="navBlock" href="/archives/"><span class="navItemTitle">Archives</span></a></li><li class="navItem"><a class="navBlock" href="/Links/"><span class="navItemTitle">Links</span></a></li></ol></nav></header><article><div id="post-bg"><div id="post-title"><h1>STM32学习笔记1（不定时更新）</h1><div id="post-info"><span>文章发布时间: <div class="control"><time datetime="2024-01-31T02:41:30.000Z" id="date"> 2024-01-31</time></div></span><br><span>最后更新时间: <div class="control"><time datetime="2024-03-10T04:39:34.241Z" id="updated"> 2024-03-10</time></div></span><br><span>文章总字数: <div class="control">11.5k</div></span><br><span>预计阅读时间: <div class="control">46 分钟</div></span></div></div><hr><div id="post-content"><h1 id="STM32学习笔记"><a href="#STM32学习笔记" class="headerlink" title="STM32学习笔记"></a>STM32学习笔记</h1><p>这个笔记是基于标准库的，跟随江协教程学习。</p>
<h2 id="1-新建工程"><a href="#1-新建工程" class="headerlink" title="1-新建工程"></a>1-新建工程</h2><p>新建工程时要选择启动文件，其选择依据芯片类型，具体见下表</p>
<table>
<thead>
<tr>
<th align="center">缩写</th>
<th align="center">释义</th>
<th align="center">Flash容量</th>
<th align="center">型号</th>
</tr>
</thead>
<tbody><tr>
<td align="center">DL_VL</td>
<td align="center">小容量产品超值系列</td>
<td align="center">16-32K</td>
<td align="center">STM32F100</td>
</tr>
<tr>
<td align="center">MD_VL</td>
<td align="center">中容量产品超值系列</td>
<td align="center">64-128K</td>
<td align="center">STM32F100</td>
</tr>
<tr>
<td align="center">HD_VL</td>
<td align="center">大容量产品超值系列</td>
<td align="center">256-512K</td>
<td align="center">STM32F100</td>
</tr>
<tr>
<td align="center">LD</td>
<td align="center">小容量产品</td>
<td align="center">16-32K</td>
<td align="center">STM32F101/102/103</td>
</tr>
<tr>
<td align="center">MD</td>
<td align="center">中容量产品</td>
<td align="center">64-128K</td>
<td align="center">STM32F101/102/103</td>
</tr>
<tr>
<td align="center">HL</td>
<td align="center">大容量产品</td>
<td align="center">256-512K</td>
<td align="center">STM32F101/102/103</td>
</tr>
<tr>
<td align="center">XL</td>
<td align="center">加大容量产品</td>
<td align="center">大于512K</td>
<td align="center">STM32F101/102/103</td>
</tr>
<tr>
<td align="center">CL</td>
<td align="center">互联型产品</td>
<td align="center">-</td>
<td align="center">STM32F105/107</td>
</tr>
</tbody></table>
<p>总结：<br>新建工程的步骤：<br>· 建立工程文件夹，Keil中新建工程，选择型号<br>· 工程文件夹里建立StartLibrary、User等文件夹，2复制固件库里面的文件到工程文件夹<br>· 工程里对应建立Start、Library、User等同名称的分组，然后将文件夹的文件添加到工程分组里<br>· 工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹<br>· 工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER<br>· 工程选项，Debug，下拉列表选择对应调试器，Settings,FlashDownload里勾选Reset and Run</p>
<p>工程架构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">startup_xx.c：                  system_xx.c/.h:         stm32f10x.h:<br>    复位中断：                     定义Systeminit           外设寄存器描述<br>        调用Systeminit          main.c:                 core_cm3.c/.h:<br>        调用main                    定义main                内核寄存器描述<br>    其他中断：                  stm32f10x_it.c/.h:      misc.c/.h,stm32f10x_abc.c/.h…：<br>        调用中断                    定义中断                库函数<br>        处理函数                    处理函数            stm32f10x_conf.h:<br>                                其他用户文件                库函数配置<br></code></pre></td></tr></table></figure>

<h2 id="2-GPIO"><a href="#2-GPIO" class="headerlink" title="2-GPIO"></a>2-GPIO</h2><h3 id="GPIO简介"><a href="#GPIO简介" class="headerlink" title="GPIO简介"></a>GPIO简介</h3><p>GPIO即通用输入输出口<br>可配置8种输入输出模式<br>引脚：0-3.3V，部分可容忍5V</p>
<p>输出模式下可以控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等<br>输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等</p>
<h3 id="GPIO基本结构"><a href="#GPIO基本结构" class="headerlink" title="GPIO基本结构"></a>GPIO基本结构</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba63a7871b83018aa7fdf4.png'><img src="https://pic.imgdb.cn/item/65ba63a7871b83018aa7fdf4.png" alt="GPIO结构框图"></p>
<p>由于stm32是32位的单片机，stm32内部的寄存器都是32位的，但是端口只有16个，所以寄存器<strong>只有低16位有对应端口</strong></p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65ba63a6871b83018aa7fc1c.png'><img src="https://pic.imgdb.cn/item/65ba63a6871b83018aa7fc1c.png" alt="GPIO电路图"><br><em>注：输入驱动器中的肖特基触发器实际为施密特触发器，此处为翻译错误</em></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">施密特触发器：当电压高于一定值的时候立马输出高电压，当电压低于一定值的时候立马输出低电压，处于中间保持<br>此处用于整形，防止信号失真<br></code></pre></td></tr></table></figure>

<p>输出数据清除器<strong>同时控制16个端口</strong>且<strong>只能整体读写</strong>，想要控制个别位需要用”&amp;=”以及”|=”的方法，比较麻烦，利用前面的位设置/清除寄存器可以仅控制输出数据寄存器的某一位而不影响其他位</p>
<p>输出控制有推挽、开漏、关闭三种输出模式</p>
<ol>
<li><p>推挽：此模式下，P-MOS和N-MOS<strong>均有效</strong>。数据寄存器为1时，P导通N断开，输出接VDD，高电平；数据寄存器为0时，P断开N导通，输出接VSS，低电平。此状态下高低电平均有较强驱动能力，所以又称<strong>强推输出模式</strong>。</p>
</li>
<li><p>开漏：此模式下<strong>P-MOS无效</strong>，N-MOS有效。数据寄存器为1时，N断开，相当于输出断开，也就是<strong>高阻模式</strong>；数据寄存器为0时，N导通，输出接VSS，低电平。此模式可以作为通信协议的驱动模式，如I2C，此模式下可以避免各个设备的相互干扰；同时在此模式下，通过在IO口外接上拉电源（以5V为例），数据寄存器输出1时由外部电路上拉到5V，就可以兼容5V的设备。</p>
</li>
<li><p>关闭，此时P-MOS和N-MOS均关闭，IO口由外部电路控制。</p>
</li>
</ol>
<h3 id="GPIO模式"><a href="#GPIO模式" class="headerlink" title="GPIO模式"></a>GPIO模式</h3><p>通过配置GPIO的端口寄存器，端口可配置成以下8种模式</p>
<p>四种输出方式：<br>　　（1）推挽输出   可输出引脚电平，高电平为高阻态，低电平接VSS<br>　　（2）开漏输出   可输出引脚电平，高电平接VDD，低电平接VSS<br>　　（3）复用推挽   由片上外设控制，高电平为高阻态，低电平接VSS<br>　　（4）复用开漏   由片上外设控制，高电平接VDD，低电平接VSS</p>
<p>四种输入方式：<br>　　（1）浮空输入   可读取引脚电平，若引脚悬空，则电平不确定<br>　　（2）上拉输入   可读取引脚电平，内部连接上拉电阻，悬空时默认高电平<br>　　（3）下拉输入   可读取引脚电平，内部连接下拉电阻，悬空时默认低电平<br>　　（4）模拟输入   GPIO无效，引脚直接接入内部ADC</p>
<h4 id="浮空-上拉-下拉输入"><a href="#浮空-上拉-下拉输入" class="headerlink" title="浮空/上拉/下拉输入"></a>浮空/上拉/下拉输入</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png'><img src="https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png" alt="浮空/上拉/下拉输入"></p>
<p>在输入模式下，输出寄存器是断开的，端口只能输入而不能输出。<br>输入寄存器的两个的电阻可以上拉工作下拉工作或者都不工作，对应上拉输入下拉输入和浮空输入。<br>右侧保护二极管，VDD和VDD_FT不同，后者对5V容忍IO脚是特殊的</p>
<h4 id="模拟输入"><a href="#模拟输入" class="headerlink" title="模拟输入"></a>模拟输入</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png'><img src="https://pic.imgdb.cn/item/65ba649f871b83018aacc649.png" alt="模拟输入"></p>
<p>在次模式下，IO口直接模拟输入，其余部分全部无效</p>
<h4 id="开漏-推挽输出"><a href="#开漏-推挽输出" class="headerlink" title="开漏/推挽输出"></a>开漏/推挽输出</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65baf0eb871b83018af5e26e.png'><img src="https://pic.imgdb.cn/item/65baf0eb871b83018af5e26e.png" alt="开漏/推挽输出模式"></p>
<p>P-MOS无效时是开漏输出，P-MOS和N-MOS均有效时是推挽输出。<br>在输出模式下输入模式是有效的。</p>
<h4 id="复用开漏-复用推挽输出"><a href="#复用开漏-复用推挽输出" class="headerlink" title="复用开漏/复用推挽输出"></a>复用开漏/复用推挽输出</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65baf6d1871b83018a053483.png'><img src="https://pic.imgdb.cn/item/65baf6d1871b83018a053483.png" alt="复用开漏/复用推挽输出"></p>
<p>此状态下通用输出没有连接，引脚的控制权转移到片上外设。</p>
<h4 id="LED和蜂鸣器"><a href="#LED和蜂鸣器" class="headerlink" title="LED和蜂鸣器"></a>LED和蜂鸣器</h4><p>LED：反光二极管</p>
<p>蜂鸣器：分为有源无源，有源自带振荡源，接上直流电压即可持续发声；无源内部不带振荡源，需要控制器提供震荡脉冲才可发声，调整振荡脉冲频率可发出不同频率的声音。</p>
<h4 id="面包板"><a href="#面包板" class="headerlink" title="面包板"></a>面包板</h4><p>结构如下图：<br class='item-img' data-src='https://www.z4a.net/images/2024/02/01/41429c4624ea25d0066ab0ef1b4f3292.png'><img src="https://www.z4a.net/images/2024/02/01/41429c4624ea25d0066ab0ef1b4f3292.png" alt="面包板"></p>
<h3 id="应用1-LED闪烁"><a href="#应用1-LED闪烁" class="headerlink" title="应用1.LED闪烁"></a>应用1.LED闪烁</h3><p>电路板连接图：</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65bb1afd871b83018a6de2f1.jpg'><img src="https://pic.imgdb.cn/item/65bb1afd871b83018a6de2f1.jpg" alt="3.1LED闪烁"></p>
<p>使用GPIO点灯的步骤：</p>
<ol>
<li>使用RCC开启GPIO时钟；</li>
<li>使用GPIO_Init()函数初始化</li>
<li>使用输出或者输入函数控制GPIO口</li>
</ol>
<p>GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)和GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)是设置引脚电平的两个函数，其中第一个参数是GPIO口（如GPIOA），第二个参数是引脚号（如GPIO_PIN_0）</p>
<p>攥写一段代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    GPIO_ResetBits(GPIOA,GPIO_Pin_0);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        <br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>写入后得到现象如下图：</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65bb1f3e871b83018a7a4bbb.jpg'><img src="https://pic.imgdb.cn/item/65bb1f3e871b83018a7a4bbb.jpg" alt="GPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)"></p>
<p>可以看到LED成功被点亮。</p>
<p>在我们使用GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)时，LED熄灭。</p>
<p>void GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)是对单个引脚写入信号的函数，在上程序中，将<code>GPIO_ResetBits(GPIOA,GPIO_Pin_0);</code>替换为<code>GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);</code>也能得到点亮的效果。</p>
<p>下面我们要实现LED的闪烁，通过使用Delay模块即可实现（Delay模块的编写在之后的课程）。代码如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>        GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>写入后，可以观察到LED闪烁。使用SetBits或者ResetBits得到的效果同样。</p>
<p><em>在WriteBit函数中，BIT_(RE)SET可以换成0或者1，但是前面要加上”(BitAction)”切换成枚举类型</em></p>
<p>将LED长短脚位置互换之后，LED依旧闪烁，说明推挽模式下高低电平都有驱动能力；将模式改成OUT_OD（开漏输出）LED不亮了，说明开漏输出的高电平无驱动能力，重新将LED长短脚换回原来位置，LED回复闪烁，说明开漏模式下低电平有驱动能力。</p>
<h3 id="应用2-LED流水灯"><a href="#应用2-LED流水灯" class="headerlink" title="应用2.LED流水灯"></a>应用2.LED流水灯</h3><p>面包板连线：</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65bb1afe871b83018a6de519.jpg'><img src="https://pic.imgdb.cn/item/65bb1afe871b83018a6de519.jpg" alt="LED流水灯"></p>
<p>在编写流水灯的程序，设置引脚的时候可以使用“|”来同时设置多个引脚，在流水灯应用中，我们需要使用0-7，共八个引脚，所以可以写<code>GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7;</code></p>
<p>最终代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">8</span>; i++)<br>        {<br>            GPIO_Write(GPIOA,~(<span class="hljs-number">0x0001</span>&lt;&lt;i));<br>            Delay_ms(<span class="hljs-number">500</span>);<br>        }<br>    }<br>}<br><br></code></pre></td></tr></table></figure>

<p>效果图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bb4d66871b83018a0d95af.jpg'><img src="https://pic.imgdb.cn/item/65bb4d66871b83018a0d95af.jpg" alt="LED 流水灯效果图"></p>
<h3 id="应用3-蜂鸣器"><a href="#应用3-蜂鸣器" class="headerlink" title="应用3.蜂鸣器"></a>应用3.蜂鸣器</h3><p>面包板连线：<br class='item-img' data-src='https://www.z4a.net/images/2024/02/01/3-3-.jpg'><img src="https://www.z4a.net/images/2024/02/01/3-3-.jpg" alt="蜂鸣器"></p>
<p>具体代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><br><span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    GPIO_InitTypeDef    GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<br>    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        GPIO_ResetBits(GPIOB,GPIO_Pin_13);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>        GPIO_SetBits(GPIOB,GPIO_Pin_13);<br>        Delay_ms(<span class="hljs-number">500</span>);<br>    }<br>}<br></code></pre></td></tr></table></figure>
<p><em>注：我在使用的时候连接了B13，所以代码中写的是13</em></p>
<h3 id="传感器模块"><a href="#传感器模块" class="headerlink" title="传感器模块"></a>传感器模块</h3><p>给予的工具包包含了四个传感器模块：光敏/热敏/对射式红外/反射式红外传感器，图片及电路图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bd98c3871b83018ad50af4.png'><img src="https://pic.imgdb.cn/item/65bd98c3871b83018ad50af4.png" alt="传感器"><br class='item-img' data-src='https://pic.imgdb.cn/item/65bd98c2871b83018ad50a67.png'><img src="https://pic.imgdb.cn/item/65bd98c2871b83018ad50a67.png" alt="传感器电路图"></p>
<p>结构较简单，不多赘述</p>
<h3 id="部分C语言知识点"><a href="#部分C语言知识点" class="headerlink" title="部分C语言知识点"></a>部分C语言知识点</h3><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><em>浮点数不能加unsigned</em></p>
<p>在单片机编程中，原本用于定义字符的char常被用于定义整形，所以C和ST就给其定义了新的关键字，出处于相同原因，部分其他关键字也被定义了新的名字，具体见下表：</p>
<table>
<thead>
<tr>
<th align="center">关键字</th>
<th align="center">位数</th>
<th align="center">表示范围</th>
<th align="center">stdint关键字</th>
<th align="center">ST关键字</th>
</tr>
</thead>
<tbody><tr>
<td align="center">char</td>
<td align="center">8</td>
<td align="center">-128 - 127</td>
<td align="center">int8_t</td>
<td align="center">s8</td>
</tr>
<tr>
<td align="center">unsigned char</td>
<td align="center">8</td>
<td align="center">0-255</td>
<td align="center">uint8_t</td>
<td align="center">u8</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">16</td>
<td align="center">-32768 - 32767</td>
<td align="center">int16_t</td>
<td align="center">s16</td>
</tr>
<tr>
<td align="center">unsigned short</td>
<td align="center">16</td>
<td align="center">0 - 65535</td>
<td align="center">uint16_t</td>
<td align="center">u16</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">32</td>
<td align="center">-2147483648 - 2147483647</td>
<td align="center">int32_t</td>
<td align="center">s32</td>
</tr>
<tr>
<td align="center">unsigned int</td>
<td align="center">32</td>
<td align="center">0 - 4294967295</td>
<td align="center">uint32_t</td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">32</td>
<td align="center">-2147483648 - 2147483647</td>
<td align="center"></td>
<td align="center">s32</td>
</tr>
<tr>
<td align="center">unsigned long</td>
<td align="center">32</td>
<td align="center">0 - 4294967295</td>
<td align="center"></td>
<td align="center">u32</td>
</tr>
<tr>
<td align="center">long long</td>
<td align="center">64</td>
<td align="center">-(2^64)/2 - (2^64)/2-1</td>
<td align="center">int64_t</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">unsigned long long</td>
<td align="center">32</td>
<td align="center">0 - (2^64)-1</td>
<td align="center">uint64_t</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">32</td>
<td align="center">-3.4e38 - 3.4e38</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">64</td>
<td align="center">-1.7e308 = 1.7e308</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<p><em>注：ST关键字是老版本的，推荐使用stdint关键字</em></p>
<h4 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h4><p>·关键字：#define<br>·用途：将一个字符串改成数字，便于理解防止出错；提取程序中常出现的参数，便于修改</p>
<p>e.p. : 定义宏定义：<br>        #define ABC 12345<br>       引用宏定义：<br>        int a = ABC; //等效于int a = 12345;</p>
<h4 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a>typedef</h4><p>·关键字：typedef<br>·用途：将比较长的变量类型名字改名字，便于使用</p>
<p>e.p. : 定义typedef：<br>        typedef unsigned char uint8_t;<br>       引用typedef：<br>        unit8_t a; //等效于unsigned char a;</p>
<p>与宏定义的不同：<br>    1. 新名字在后面<br>    2. 仅能用于变量类型名<br>    3. typedef会进行检查，更安全</p>
<h4 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h4><p>·关键字：struct<br>·用途：数据打包，不同类型变量的集合</p>
<p>e.p. : 定义结构体：<br>        struct{char x;int y;float z;} StructName;<br>        <em>因为结构体变量类型较长，所以常用typedef更改变量类型名</em><br>       引用结构体：<br>        StructName.x= ‘A’;<br>        StructName.y= 66;<br>        StructName. z= 1.14;<br>    或：pStructName-&gt;x= ‘A’;    //pSrtuctName是结构体的地址<br>        pStructName-&gt;y= 66;<br>        pStructName-&gt;z= 1.14;</p>
<p>使用typedef举例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span>{</span><br>    <span class="hljs-type">char</span> x;<br>    <span class="hljs-type">int</span> y;<br>    <span class="hljs-type">float</span> z;<br>} StructName_1;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>{<br>    StructName_1 c;<br>    StructName_1 d;<br>    c.x= <span class="hljs-string">'A'</span>;<br>    c.y= <span class="hljs-number">66</span>;<br>    c. z= <span class="hljs-number">1.14</span>;<br><br>    prinf(<span class="hljs-string">"c.x-%c\n"</span>,c.x);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>}<br></code></pre></td></tr></table></figure>

<h4 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h4><p>·关键字：enum<br>·用途：定义一个取值受限的整型变量，用于限制变量取值范围；宏定义的集合</p>
<p>e.p. : 定义枚举变量：<br>        enum{FALSE = 0, TRUE = 1} EnumName;<br>        <em>因为枚举变量变量类型较长，所以常用typedef更改变量类型名</em><br>       引用typedef：<br>        EnumName=FALSE;<br>        EnumName=TRUE;</p>
<h3 id="应用4-按键控制LED"><a href="#应用4-按键控制LED" class="headerlink" title="应用4.按键控制LED"></a>应用4.按键控制LED</h3><p>面包板连接图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bb1b00871b83018a6de942.jpg'><img src="https://pic.imgdb.cn/item/65bb1b00871b83018a6de942.jpg" alt="按键控制LED"></p>
<p>连接完成品如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg'><img src="https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg" alt="L按键控制led实物图"></p>
<p>为了保持主函数整洁，将部分代码封装到头文件Key.c和LED.c</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs Key.c">#include "stm32f10x.h"                  // Device header<br>#include "Delay.h"<br><br>/**<br>  * 函    数：按键初始化<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void Key_Init(void)<br>{<br>	/*开启时钟*/<br>	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		//开启GPIOB的时钟<br>	<br>	/*GPIO初始化*/<br>	GPIO_InitTypeDef GPIO_InitStructure;<br>	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;<br>	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						//将PB1和PB11引脚初始化为上拉输入<br>}<br><br>/**<br>  * 函    数：按键获取键码<br>  * 参    数：无<br>  * 返 回 值：按下按键的键码值，范围：0~2，返回0代表没有按键按下<br>  * 注意事项：此函数是阻塞式操作，当按键按住不放时，函数会卡住，直到按键松手<br>  */<br>uint8_t Key_GetNum(void)<br>{<br>	uint8_t KeyNum = 0;		//定义变量，默认键码值为0<br>	<br>	if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)			//读PB1输入寄存器的状态，如果为0，则代表按键1按下<br>	{<br>		Delay_ms(20);											//延时消抖<br>		while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0);	//等待按键松手<br>		Delay_ms(20);											//延时消抖<br>		KeyNum = 1;												//置键码为1<br>	}<br>	<br>	if (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)			//读PB11输入寄存器的状态，如果为0，则代表按键2按下<br>	{<br>		Delay_ms(20);											//延时消抖<br>		while (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);	//等待按键松手<br>		Delay_ms(20);											//延时消抖<br>		KeyNum = 2;												//置键码为2<br>	}<br>	<br>	return KeyNum;			//返回键码值，如果没有按键按下，所有if都不成立，则键码为默认值0<br>}<br></code></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs LED.c">#include "stm32f10x.h"                  // Device header<br><br>/**<br>  * 函    数：LED初始化<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED_Init(void)<br>{<br>	/*开启时钟*/<br>	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);		//开启GPIOA的时钟<br>	<br>	/*GPIO初始化*/<br>	GPIO_InitTypeDef GPIO_InitStructure;<br>	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;<br>	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);						//将PA1和PA2引脚初始化为推挽输出<br>	<br>	/*设置GPIO初始化后的默认电平*/<br>	GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);				//设置PA1和PA2引脚为高电平<br>}<br><br>/**<br>  * 函    数：LED1开启<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED1_ON(void)<br>{<br>	GPIO_ResetBits(GPIOA, GPIO_Pin_1);		//设置PA1引脚为低电平<br>}<br><br>/**<br>  * 函    数：LED1关闭<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED1_OFF(void)<br>{<br>	GPIO_SetBits(GPIOA, GPIO_Pin_1);		//设置PA1引脚为高电平<br>}<br><br>/**<br>  * 函    数：LED1状态翻转<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED1_Turn(void)<br>{<br>	if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)		//获取输出寄存器的状态，如果当前引脚输出低电平<br>	{<br>		GPIO_SetBits(GPIOA, GPIO_Pin_1);					//则设置PA1引脚为高电平<br>	}<br>	else													//否则，即当前引脚输出高电平<br>	{<br>		GPIO_ResetBits(GPIOA, GPIO_Pin_1);					//则设置PA1引脚为低电平<br>	}<br>}<br><br>/**<br>  * 函    数：LED2开启<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED2_ON(void)<br>{<br>	GPIO_ResetBits(GPIOA, GPIO_Pin_2);		//设置PA2引脚为低电平<br>}<br><br>/**<br>  * 函    数：LED2关闭<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED2_OFF(void)<br>{<br>	GPIO_SetBits(GPIOA, GPIO_Pin_2);		//设置PA2引脚为高电平<br>}<br><br>/**<br>  * 函    数：LED2状态翻转<br>  * 参    数：无<br>  * 返 回 值：无<br>  */<br>void LED2_Turn(void)<br>{<br>	if (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)		//获取输出寄存器的状态，如果当前引脚输出低电平<br>	{                                                  <br>		GPIO_SetBits(GPIOA, GPIO_Pin_2);               		//则设置PA2引脚为高电平<br>	}                                                  <br>	else                                               		//否则，即当前引脚输出高电平<br>	{                                                  <br>		GPIO_ResetBits(GPIOA, GPIO_Pin_2);             		//则设置PA2引脚为低电平<br>	}<br>}<br></code></pre></td></tr></table></figure>

<p>主程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs main.c">#include "stm32f10x.h"                  // Device header<br>#include "Delay.h"<br>#include "LED.h"<br>#include "Key.h"<br><br>uint8_t KeyNum;		//定义用于接收按键键码的变量<br><br>int main(void)<br>{<br>	/*模块初始化*/<br>	LED_Init();		//LED初始化<br>	Key_Init();		//按键初始化<br>	<br>	while (1)<br>	{<br>		KeyNum = Key_GetNum();		//获取按键键码<br>		<br>		if (KeyNum == 1)			//按键1按下<br>		{<br>			LED1_Turn();			//LED1翻转<br>		}<br>		<br>		if (KeyNum == 2)			//按键2按下<br>		{<br>			LED2_Turn();			//LED2翻转<br>		}<br>	}<br>}<br><br></code></pre></td></tr></table></figure>
<p>具体功能见注释，通过这几个程序可以做到使用按键控制LED亮灭。</p>
<h3 id="应用5-光敏传感器控制蜂鸣器"><a href="#应用5-光敏传感器控制蜂鸣器" class="headerlink" title="应用5.光敏传感器控制蜂鸣器"></a>应用5.光敏传感器控制蜂鸣器</h3><p>接线图如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65bb1b00871b83018a6deb22.jpg'><img src="https://pic.imgdb.cn/item/65bb1b00871b83018a6deb22.jpg" alt="光敏传感器控制蜂鸣器"></p>
<p>连接完成后实物图如下：</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg'><img src="https://pic.imgdb.cn/item/65be169a871b83018a758488.jpg" alt="光敏传感器控制蜂鸣器实物图"></p>
<p>头文件：<br>LightSensor.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：光敏传感器初始化</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LightSensor_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-comment">/*开启时钟*/</span><br>	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);		<span class="hljs-comment">//开启GPIOB的时钟</span><br>	<br>	<span class="hljs-comment">/*GPIO初始化*/</span><br>	GPIO_InitTypeDef GPIO_InitStructure;<br>	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;<br>	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>	GPIO_Init(GPIOB, &amp;GPIO_InitStructure);						<span class="hljs-comment">//将PB13引脚初始化为上拉输入</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：获取当前光敏传感器输出的高低电平</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：光敏传感器输出的高低电平，范围：0/1</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">uint8_t</span> <span class="hljs-title function_">LightSensor_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-keyword">return</span> GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);			<span class="hljs-comment">//返回PB13输入寄存器的状态</span><br>}<br></code></pre></td></tr></table></figure>

<p>LED.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED初始化</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-comment">/*开启时钟*/</span><br>	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);		<span class="hljs-comment">//开启GPIOA的时钟</span><br>	<br>	<span class="hljs-comment">/*GPIO初始化*/</span><br>	GPIO_InitTypeDef GPIO_InitStructure;<br>	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;<br>	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;<br>	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);						<span class="hljs-comment">//将PA1和PA2引脚初始化为推挽输出</span><br>	<br>	<span class="hljs-comment">/*设置GPIO初始化后的默认电平*/</span><br>	GPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);				<span class="hljs-comment">//设置PA1和PA2引脚为高电平</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED1开启</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED1_ON</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	GPIO_ResetBits(GPIOA, GPIO_Pin_1);		<span class="hljs-comment">//设置PA1引脚为低电平</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED1关闭</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED1_OFF</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	GPIO_SetBits(GPIOA, GPIO_Pin_1);		<span class="hljs-comment">//设置PA1引脚为高电平</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED1状态翻转</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED1_Turn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == <span class="hljs-number">0</span>)		<span class="hljs-comment">//获取输出寄存器的状态，如果当前引脚输出低电平</span><br>	{<br>		GPIO_SetBits(GPIOA, GPIO_Pin_1);					<span class="hljs-comment">//则设置PA1引脚为高电平</span><br>	}<br>	<span class="hljs-keyword">else</span>													<span class="hljs-comment">//否则，即当前引脚输出高电平</span><br>	{<br>		GPIO_ResetBits(GPIOA, GPIO_Pin_1);					<span class="hljs-comment">//则设置PA1引脚为低电平</span><br>	}<br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED2开启</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED2_ON</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	GPIO_ResetBits(GPIOA, GPIO_Pin_2);		<span class="hljs-comment">//设置PA2引脚为低电平</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED2关闭</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED2_OFF</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	GPIO_SetBits(GPIOA, GPIO_Pin_2);		<span class="hljs-comment">//设置PA2引脚为高电平</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：LED2状态翻转</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">LED2_Turn</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-keyword">if</span> (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == <span class="hljs-number">0</span>)		<span class="hljs-comment">//获取输出寄存器的状态，如果当前引脚输出低电平</span><br>	{                                                  <br>		GPIO_SetBits(GPIOA, GPIO_Pin_2);               		<span class="hljs-comment">//则设置PA2引脚为高电平</span><br>	}                                                  <br>	<span class="hljs-keyword">else</span>                                               		<span class="hljs-comment">//否则，即当前引脚输出高电平</span><br>	{                                                  <br>		GPIO_ResetBits(GPIOA, GPIO_Pin_2);             		<span class="hljs-comment">//则设置PA2引脚为低电平</span><br>	}<br>}<br></code></pre></td></tr></table></figure>

<p>主程序如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Buzzer.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"LightSensor.h"</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-comment">/*模块初始化*/</span><br>	Buzzer_Init();			<span class="hljs-comment">//蜂鸣器初始化</span><br>	LightSensor_Init();		<span class="hljs-comment">//光敏传感器初始化</span><br>	<br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>	{<br>		<span class="hljs-keyword">if</span> (LightSensor_Get() == <span class="hljs-number">1</span>)		<span class="hljs-comment">//如果当前光敏输出1</span><br>		{<br>			Buzzer_ON();				<span class="hljs-comment">//蜂鸣器开启</span><br>		}<br>		<span class="hljs-keyword">else</span>							<span class="hljs-comment">//否则</span><br>		{<br>			Buzzer_OFF();				<span class="hljs-comment">//蜂鸣器关闭</span><br>		}<br>	}<br>}<br></code></pre></td></tr></table></figure>

<h2 id="OLED"><a href="#OLED" class="headerlink" title="OLED"></a>OLED</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>OLED(Organic Light Emitting Diode)<br>供电：3-5.5V，通信协议：I2C/SPI，分辨率：128*64（0.96寸）</p>
<p>OLED显示屏电路原理图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c23b659f345e8d03771dd7.png'><img src="https://pic.imgdb.cn/item/65c23b659f345e8d03771dd7.png" alt="4针脚OLED"></p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65c23b659f345e8d03771eab.png'><img src="https://pic.imgdb.cn/item/65c23b659f345e8d03771eab.png" alt="7针脚OLED"></p>
<h3 id="调试方式"><a href="#调试方式" class="headerlink" title="调试方式"></a>调试方式</h3><ol>
<li>串口调试：通过串口通信将调试信息发送到电脑端，电脑使用串口助手显示调试信息</li>
<li>显示屏调试：将显示屏连到单片机，将调试信息直接在显示屏上显示</li>
<li>Keil调试模式：借助keil软件的调试功能，可使用单步运行、设置断点、查看寄存器以及变量等功能（调试模式下不能修改代码）</li>
</ol>
<h3 id="驱动函数"><a href="#驱动函数" class="headerlink" title="驱动函数"></a>驱动函数</h3><p>将OLED显示屏区分为4行16列</p>
<p>教程给出的函数有：</p>
<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">OLED_Init()</td>
<td align="center">初始化</td>
</tr>
<tr>
<td align="center">OLED_Clear()</td>
<td align="center">清屏</td>
</tr>
<tr>
<td align="center">OLED_ShowChar(1,1,’A’)</td>
<td align="center">显示一个字符</td>
</tr>
<tr>
<td align="center">OLED_ShowString(1,3,”HelloWorld”)</td>
<td align="center">显示字符串</td>
</tr>
<tr>
<td align="center">OLED_ShowNum(2,1,12345,5)</td>
<td align="center">显示十进制数字</td>
</tr>
<tr>
<td align="center">OLED_ShowSignedNum(2,7,-66,2)</td>
<td align="center">显示有符号十进制数</td>
</tr>
<tr>
<td align="center">OLED_ShowHexNum(3,1,0xAA55,4)</td>
<td align="center">显示16进制数字</td>
</tr>
<tr>
<td align="center">OLED_ShowBinNum(4,1,0xAA55,16)</td>
<td align="center">显示2进制数字</td>
</tr>
</tbody></table>
<h3 id="实体演示"><a href="#实体演示" class="headerlink" title="实体演示"></a>实体演示</h3><p>面包板接线图 ；<br class='item-img' data-src='https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg'><img src="https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg" alt="OLED"></p>
<p>编写如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br><br>    OLED_ShowChar(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'A'</span>);<br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"Homo"</span>);<br>    OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">114</span>,<span class="hljs-number">3</span>);<br>    OLED_ShowHexNum(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>,<span class="hljs-number">0x514</span>,<span class="hljs-number">3</span>);<br>    OLED_ShowSignedNum(<span class="hljs-number">3</span>,<span class="hljs-number">1</span>,<span class="hljs-number">-19198</span>,<span class="hljs-number">5</span>);<br>    OLED_ShowBinNum(<span class="hljs-number">4</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0x2</span>,<span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>   <br>       <br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>显示结果如下：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c241b89f345e8d03908e37.jpg'><img src="https://pic.imgdb.cn/item/65c241b89f345e8d03908e37.jpg" alt="OLED显示"></p>
<p><em><del>莫名感觉有点可爱</del></em></p>
<h2 id="EXTI外部中断"><a href="#EXTI外部中断" class="headerlink" title="EXTI外部中断"></a>EXTI外部中断</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>EXTI(Extern Interrupt)外部中断</p>
<p>EXTI可以监测指定GPIO口的电平信号，当其指定的GPIO产生电平变化时，EXTI会立刻向NVIC发出中断申请，经NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序</p>
<p>支持的触发方式：上升沿/下降沿/双边沿/软件触发</p>
<p>支持全部GPIO口，但是相同的Pin不能同时触发中断</p>
<p>通道数：16个GPIO，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒</p>
<p>触发相应方式：中断响应/事件响应（中断响应是触发中断，事件响应是触发别的外设操作）</p>
<h3 id="中断系统"><a href="#中断系统" class="headerlink" title="中断系统"></a>中断系统</h3><p>中断：主程序运行时出现了特定的中断触发条件（中断源），使CPU暂停当前程序转去处理中断程序，处理完之后返回暂停位置继续执行原本程序</p>
<p>中断优先级：多个中断源同时申请中断的时候，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源</p>
<p>中断嵌套：一个中断正在运行的时候，有优先级更高的中断源申请中断的时候，CPU会再次暂停当前中断程序，转去处理新的中断程序，处理完之后依次返回</p>
<p>STM32中断包括：EXTI,TIM,ADC,USRT,SPI,I2C,PTC</p>
<p>中断向量表：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e7d8.png'><img src="https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e7d8.png" alt="中断表1"><br class='item-img' data-src='https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e8ae.png'><img src="https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e8ae.png" alt="中断表2"><br class='item-img' data-src='https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e705.png'><img src="https://pic.imgdb.cn/item/65c3895b9f345e8d03c4e705.png" alt="中断表3"></p>
<h3 id="NVIC"><a href="#NVIC" class="headerlink" title="NVIC"></a>NVIC</h3><h4 id="NVIC基本结构"><a href="#NVIC基本结构" class="headerlink" title="NVIC基本结构"></a>NVIC基本结构</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65c389a89f345e8d03c63895.png'><img src="https://pic.imgdb.cn/item/65c389a89f345e8d03c63895.png" alt="NVIC_Basic_Structure"></p>
<p>使用NVIC为了防止中断占用过多CPU引脚以及防止优先级分组对CPU性能的占用</p>
<h4 id="NVIC优先级分组"><a href="#NVIC优先级分组" class="headerlink" title="NVIC优先级分组"></a>NVIC优先级分组</h4><p>NVIC的中断优先级由优先级寄存器的四位（0-15）组成，这四位可以进行切分，分成高n位的抢占优先级和低4-n位的相应优先级</p>
<p>抢断优先级高的可以中断嵌套，响应优先级高的可以优先排队，两者相同按中断号排队</p>
<h3 id="EXTI"><a href="#EXTI" class="headerlink" title="EXTI"></a>EXTI</h3><h4 id="EXTI基本结构"><a href="#EXTI基本结构" class="headerlink" title="EXTI基本结构"></a>EXTI基本结构</h4><p>结构框图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c394939f345e8d03f54378.png'><img src="https://pic.imgdb.cn/item/65c394939f345e8d03f54378.png" alt="EXTI结构框图"></p>
<p>AFIO是一个数据选择器，他会选择前面连接的一个引脚连接到EXTI，这也是为什么前面说每个引脚只能连接一个中断。</p>
<p>*注：原本EXTI有20路通道输出，但是其中5-9，10-15分别被集中到一个引脚中，即5-9，10-15分别会触发同一个中断函数，在这两个中断函数中，我们要通过标志位来判断具体是哪个中断</p>
<p>下面还有20个引脚连接外设</p>
<h4 id="AFIO复用IO口"><a href="#AFIO复用IO口" class="headerlink" title="AFIO复用IO口"></a>AFIO复用IO口</h4><p>AFIO电路图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c397849f345e8d0301f25a.png'><img src="https://pic.imgdb.cn/item/65c397849f345e8d0301f25a.png" alt="AFIO"></p>
<p>AFIO主要用于引脚复用功能的选择和重定义</p>
<p>在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择</p>
<h4 id="EXTI内部框图"><a href="#EXTI内部框图" class="headerlink" title="EXTI内部框图"></a>EXTI内部框图</h4><p>EXTI内部框图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c397e49f345e8d03039d26.png'><img src="https://pic.imgdb.cn/item/65c397e49f345e8d03039d26.png" alt="EXTI内部框图"></p>
<p>图中右下角输入线就是20根输入线，通过检测器决定是进行上升沿触发/下降沿触发/两者</p>
<p>请求挂起寄存器可以被读取以判断是哪个通道触发的判断</p>
<p>· 需要使用外部中断的情况：外部驱动的突发事件</p>
<h3 id="旋转编码器介绍"><a href="#旋转编码器介绍" class="headerlink" title="旋转编码器介绍"></a>旋转编码器介绍</h3><p>旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向</p>
<p>类型：机械触点式/霍尔传感器式/光栅式</p>
<p>光栅式：通过旋钮上光栅阻挡信号产生信号波，但是只能测位置和速度不能测方向</p>
<p>机械触电式：金属触点经过设计，正反转时。两个触电会有不同的相位差，通过相位差可以判断方向</p>
<p>硬件电路：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c39b849f345e8d0314285b.png'><img src="https://pic.imgdb.cn/item/65c39b849f345e8d0314285b.png" alt="旋转编码器模块"><br class='item-img' data-src='https://pic.imgdb.cn/item/65c39b839f345e8d03142795.png'><img src="https://pic.imgdb.cn/item/65c39b839f345e8d03142795.png" alt="旋转编码器"></p>
<h3 id="应用1-对射式红外传感器计次"><a href="#应用1-对射式红外传感器计次" class="headerlink" title="应用1.对射式红外传感器计次"></a>应用1.对射式红外传感器计次</h3><p>面包板连接图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c4469b9f345e8d038e92cd.jpg'><img src="https://pic.imgdb.cn/item/65c4469b9f345e8d038e92cd.jpg" alt="对射式红外传感器计次"></p>
<p>头文件：<br>CountSensor.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><br><span class="hljs-type">uint16_t</span> CounterSensor_Count;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">CounterSensor_Init</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-comment">//基础配置</span><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);<br><br>    <span class="hljs-comment">//配置AFIO</span><br>    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);<br><br>    <span class="hljs-comment">//配置EXTI</span><br>    EXTI_InitTypeDef EXTI_InitStructure;<br>    EXTI_InitStructure.EXTI_Line=EXTI_Line14;<br>    EXTI_InitStructure.EXTI_LineCmd=ENABLE;<br>    EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;<br>    EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;<br>    EXTI_Init(&amp;EXTI_InitStructure);<br><br>    <span class="hljs-comment">//配置NVIC</span><br>    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);<br><br>    NVIC_InitTypeDef NVIC_InitStructure;<br>    NVIC_InitStructure.NVIC_IRQChannel=EXTI15_10_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="hljs-number">1</span>;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="hljs-number">1</span>;<br>    NVIC_Init(&amp;NVIC_InitStructure);<br>}<br><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">CountSensor_GetCount</span><span class="hljs-params">()</span><br>{<br>    <span class="hljs-keyword">return</span> CounterSensor_Count;<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">EXTI15_10_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">if</span>(EXTI_GetITStatus(EXTI_Line14)==SET)<br>    {<br>        <span class="hljs-keyword">if</span> (GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_14)==<span class="hljs-number">0</span>)<br>        {<br>            CounterSensor_Count++;<br>        }<br>        EXTI_ClearITPendingBit(EXTI_Line14);<br>        <br>    }<br>    <br>}<br><br></code></pre></td></tr></table></figure>

<p>主程序：<br>main.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"CountSensor.h"</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    CounterSensor_Init();<br><br>    OLED_ShowChar(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">'A'</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,CountSensor_GetCount(),<span class="hljs-number">5</span>);<br>       <br>    }<br>}<br><br></code></pre></td></tr></table></figure>
<p>现象：每次对射式红外传感器中间被隔光，OLED上显示次数+1</p>
<h3 id="应用2-旋转编码器计次"><a href="#应用2-旋转编码器计次" class="headerlink" title="应用2.旋转编码器计次"></a>应用2.旋转编码器计次</h3><p>面包板接线图：<br>![旋转编码计数器](<a target="_blank" rel="noopener" href="https://pic/">https://pic</a> .imgdb.cn/item/65c481509f345e8d03201b8a.jpg)</p>
<h2 id="TIM定时器中断"><a href="#TIM定时器中断" class="headerlink" title="TIM定时器中断"></a>TIM定时器中断</h2><h3 id="TIM简介"><a href="#TIM简介" class="headerlink" title="TIM简介"></a>TIM简介</h3><p>定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断<br>16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时</p>
<p>不仅具备基本的定时中断功能，而且还包含<strong>内外时钟源选择</strong>、<strong>输入捕获</strong>、<strong>输出比较</strong>、<strong>编码器接口</strong>、<strong>主从触发模式</strong>等多种功能</p>
<p>根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">编号</th>
<th align="center">总线</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">高级定时器</td>
<td align="center">TIM1、TIM8</td>
<td align="center">APB2</td>
<td align="center">拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能</td>
</tr>
<tr>
<td align="center">通用定时器</td>
<td align="center">TIM2、TIM3、TIM4、TIM5</td>
<td align="center">APB1</td>
<td align="center">拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能</td>
</tr>
<tr>
<td align="center">基本定时器</td>
<td align="center">TIM6、TIM7</td>
<td align="center">APB1</td>
<td align="center">拥有定时中断、主模式触发DAC的功能</td>
</tr>
</tbody></table>
<p><em>STM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4</em></p>
<h3 id="基本定时器"><a href="#基本定时器" class="headerlink" title="基本定时器"></a>基本定时器</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c6dd629f345e8d03404c71.png'><img src="https://pic.imgdb.cn/item/65c6dd629f345e8d03404c71.png" alt="基本定时器框图"></p>
<p>PSC预分频器：输出频率=输入频率/输入的值</p>
<p>自动重装寄存器记录写入的计数目标，当计数==技术目标的时候产生一个中断信号并清零计数器</p>
<p>此类计数值等于自动重装值产生的中断叫做“更新中断”</p>
<h3 id="通用定时器"><a href="#通用定时器" class="headerlink" title="通用定时器"></a>通用定时器</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c6e0099f345e8d03451c35.png'><img src="https://pic.imgdb.cn/item/65c6e0099f345e8d03451c35.png" alt="通用定时器结构框图"></p>
<p>通用定时器除了向上计数（从0开始累计到重装值之后清零同时申请中断），还支持向下计数（从重装值开始递减，到0之后回到重装值并申请中断）和中央对齐计数（先从0向上到重装值申请中断然后从重装值向下到0再申请中断，依次循环），高级计时器也支持这三类模式</p>
<p>除了使用内部72Hz的时钟，还可以通过ETR连接外部时钟（通过ETRF作为时钟使用较简单，通过TRGI会占据通道</p>
<p>ITR引脚来自其他定时器的TRGO输出</p>
<h3 id="高级定时器"><a href="#高级定时器" class="headerlink" title="高级定时器"></a>高级定时器</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c6e0099f345e8d03451bf0.png'><img src="https://pic.imgdb.cn/item/65c6e0099f345e8d03451bf0.png" alt="高级定时器结构框图"></p>
<p>基本和通用计时器只能每个计数周期发生一次中断，但是高级计时器可以使用重复次数计时器完成多个技术周期进行一次中断</p>
<h3 id="定时中断基本结构"><a href="#定时中断基本结构" class="headerlink" title="定时中断基本结构"></a>定时中断基本结构</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65c7231d9f345e8d03e08e35.jpg'><img src="https://pic.imgdb.cn/item/65c7231d9f345e8d03e08e35.jpg" alt="定时中断基本结构框图"></p>
<p>预分频器时序图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c727b79f345e8d03ed9243.png'><img src="https://pic.imgdb.cn/item/65c727b79f345e8d03ed9243.png" alt="预分频器时序图"></p>
<p>预分频器原理：在TIMx_PSC中写入新数据后（改变预分频值），控制，直到当前计数周期结束之后，改变的分频值才会起作用</p>
<p>预分频计数器内部也是靠计数器工作的，分频值为0时，计数器恒为0，分频值为1时，计数器就01计数，回到0时发出一个脉冲，定时器时钟计数。</p>
<p>计数器计数频率：CK_CNT=CK_PSC/(PSC+1)</p>
<h3 id="计时器时序"><a href="#计时器时序" class="headerlink" title="计时器时序"></a>计时器时序</h3><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/7b9477f8c3680db0ed6dd185117bfc5d.png'><img src="https://www.z4a.net/images/2024/02/10/7b9477f8c3680db0ed6dd185117bfc5d.png" alt="计时器时序"></p>
<p><em>UIF需要在中断程序中手动清零</em></p>
<p>计数器溢出频率：CK_CNT_OV=CK_CNT/(ARR+1)=CK_PSC/(PSC+1)/(ARR+1)</p>
<h4 id="计数器无预装时序"><a href="#计数器无预装时序" class="headerlink" title="计数器无预装时序"></a>计数器无预装时序</h4><p>计数器中有缓冲计时器，可以通过修改APRE的值控制是否使用</p>
<p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/486e8a762680ca8177d762e5320e2bea.png'><img src="https://www.z4a.net/images/2024/02/10/486e8a762680ca8177d762e5320e2bea.png" alt="计数器无预装时序"></p>
<p>在无预装时许的情况下修改技术目标，若当前计数值小于技术目标，则到达修改后的计数目标然后重置，若大于，则会因为无法等于技术目标而一直到上限再重置 </p>
<h4 id="计数器有预装时序"><a href="#计数器有预装时序" class="headerlink" title="计数器有预装时序"></a>计数器有预装时序</h4><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/02b5e9f258121466ddaae53f4cc650e7.png'><img src="https://www.z4a.net/images/2024/02/10/02b5e9f258121466ddaae53f4cc650e7.png" alt="计数器有预装时时序"></p>
<p>影子计数器用于同步防止出错</p>
<h3 id="RCC时钟树"><a href="#RCC时钟树" class="headerlink" title="RCC时钟树"></a>RCC时钟树</h3><p class='item-img' data-src='https://www.z4a.net/images/2024/02/10/RCC.png'><img src="https://www.z4a.net/images/2024/02/10/RCC.png" alt="RCC时钟树"></p>
<p>在不修改参数的情况下，三种计时器都是72Hz</p>
<h3 id="应用1-定时器定时中断"><a href="#应用1-定时器定时中断" class="headerlink" title="应用1.定时器定时中断"></a>应用1.定时器定时中断</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg'><img src="https://pic.imgdb.cn/item/65c23d679f345e8d037f2d92.jpg" alt="定时器定时中断"></p>
<p>头文件Timer.c：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><br><span class="hljs-keyword">extern</span> <span class="hljs-type">uint16_t</span> Num;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TImer_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<br><br>    TIM_InternalClockConfig(TIM2);<br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">10000</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">7200</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_ClearFlag(TIM2,TIM_FLAG_Update);<br>    TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);<br><br>    NVIC_InitTypeDef NVIC_InitStructure;<br>    NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn;<br>    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;<br>    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=<span class="hljs-number">2</span>;<br>    NVIC_InitStructure.NVIC_IRQChannelSubPriority=<span class="hljs-number">1</span>;<br>    NVIC_Init(&amp;NVIC_InitStructure); <br><br>    TIM_Cmd(TIM2,ENABLE);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2,TIM_IT_Update)==SET)<br>    {<br>        Num++;<br>        TIM_ClearITPendingBit(TIM2,TIM_IT_Update);<br>    }<br>    <br>}<br></code></pre></td></tr></table></figure>

<p>主程序 main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Timer.h"</span></span><br><br><span class="hljs-type">uint16_t</span> Num;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    OLED_Init();<br>    TImer_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Num:"</span>);<br>    <br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,Num,<span class="hljs-number">5</span>);<br>    }<br>}<br></code></pre></td></tr></table></figure>

<h3 id="应用2-定时器外部时钟"><a href="#应用2-定时器外部时钟" class="headerlink" title="应用2.定时器外部时钟"></a>应用2.定时器外部时钟</h3><p>面包板接线图：</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65c86f3c9f345e8d034904a2.jpg'><img src="https://pic.imgdb.cn/item/65c86f3c9f345e8d034904a2.jpg" alt="定时器外部时钟"></p>
<h3 id="输出比较"><a href="#输出比较" class="headerlink" title="输出比较"></a>输出比较</h3><h4 id="输出比较简介"><a href="#输出比较简介" class="headerlink" title="输出比较简介"></a>输出比较简介</h4><p>·OC（Output Compare） 输出比较可以通过比较CNT和CRR寄存器值的关系来输出电平进行置0、置1或反转的操作，用于输出一点频率和占空比的PWM波形<br>·每个高级定时器和通用定时器都有4个输出比较通道<br>·高级定时器的前三个通道额外拥有死区生成和互补输出的功能</p>
<h4 id="PWM简介"><a href="#PWM简介" class="headerlink" title="PWM简介"></a>PWM简介</h4><p>PWM(Pluse Width Modulation)脉冲宽度调制<br>在具有惯性的系统中，可通过对一系列脉冲的宽度进行调制来等效的获取需要的模拟参量，常用于电机控速等领域<br>PWM参数：<br>  频率=1/T_s  占空比=T_ON/T_s  分辨率=占空比变化步距</p>
<h4 id="输出比较通道"><a href="#输出比较通道" class="headerlink" title="输出比较通道"></a>输出比较通道</h4><p>下图是输出比较通道框图（高级和普通）</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b6e2.png'><img src="https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b6e2.png" alt="输出比较通道(high)"></p>
<p>为了控制电机，高级输出比较通道的OC1和OC1N需要输出互补的信号，在实际应用中可能会因为元件的不理想，导致出现上管未关闭下管就导通的现象，会导致功率损耗产生大量热，为防止该现象使用死区发生器，可以在一管关闭时延迟一段时间再导通另一管，避免同时导通。</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b77d.png'><img src="https://pic.imgdb.cn/item/65cb1fdd9f345e8d0373b77d.png" alt="输出比较通道(normal)"></p>
<p>通过比较CNT和CCR可以使输出模式控制器输出高低电平，通过调节寄存器可以选择不同模式，模式表如下:</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">冻结</td>
<td align="center">CNT=CCR时，REF保持为原状态</td>
</tr>
<tr>
<td align="center">匹配时置有效电平</td>
<td align="center">CNT=CCR时，REF置有效电平</td>
</tr>
<tr>
<td align="center">匹配时置有效电平</td>
<td align="center">CNT=CCR时，REF置无效电平</td>
</tr>
<tr>
<td align="center">匹配时电平翻转</td>
<td align="center">CNT=CCR时，REF电平翻转</td>
</tr>
<tr>
<td align="center">强制为无效电平</td>
<td align="center">CNT与CCR无效，REF强制为无效电平</td>
</tr>
<tr>
<td align="center">强制为有效电平</td>
<td align="center">CNT与CCR无效，REF强制为有效电平</td>
</tr>
<tr>
<td align="center">PWM模式1</td>
<td align="center">向上计数：CNT&lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平   向下计数：CNT&gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平</td>
</tr>
<tr>
<td align="center">PWM模式2</td>
<td align="center">向上计数：CNT&lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平   向下计数：CNT&gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平</td>
</tr>
</tbody></table>
<p>匹配时电平翻转模式可以平稳输出占空比为50%的信号，匹配时置有效电平和匹配时置有效电平相对不适合输出连续信号，比较适用于当你想要输出某一信号的情况</p>
<h4 id="PWM基本结构"><a href="#PWM基本结构" class="headerlink" title="PWM基本结构"></a>PWM基本结构</h4><p>PWM基本结构框图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cb24079f345e8d0380c94b.png'><img src="https://pic.imgdb.cn/item/65cb24079f345e8d0380c94b.png" alt="PWM基本结构框图"></p>
<p>由图可以看出PWM的基本结构</p>
<h4 id="PWM参数计算"><a href="#PWM参数计算" class="headerlink" title="PWM参数计算"></a>PWM参数计算</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cb24079f345e8d0380c9e5.png'><img src="https://pic.imgdb.cn/item/65cb24079f345e8d0380c9e5.png" alt="PWM波"></p>
<ol>
<li>PWM频率：  Freq = CK_PSC/(PSC+1)/(ARR+1)</li>
<li>PWM占空比：Duty = CRR/(ARR+1)</li>
<li>PWM分辨率：Reso = 1/(ARR+1)</li>
</ol>
<h3 id="舵机简介"><a href="#舵机简介" class="headerlink" title="舵机简介"></a>舵机简介</h3><p>舵机是一种根据输入PWM信号占空比来控制输出角度的装置</p>
<p>输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2a619f345e8d0393dff2.png'><img src="https://pic.imgdb.cn/item/65cb2a619f345e8d0393dff2.png" alt="舵机"></p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2a609f345e8d0393dd00.png'><img src="https://pic.imgdb.cn/item/65cb2a609f345e8d0393dd00.png" alt="舵机拆解图"></p>
<p>如图：舵机不是单纯的电机，而是由多个期间组成，大概逻辑就是PWM波给电板一个指定角度，判断当前角度，大则反转小则正转</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2a609f345e8d0393ddb0.png'><img src="https://pic.imgdb.cn/item/65cb2a609f345e8d0393ddb0.png" alt="多舵机信号"></p>
<p>↑根据该图可以得到输入信号脉冲宽度对应的舵机输出角度</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a7738.png'><img src="https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a7738.png" alt="舵机硬件图"></p>
<p>在上面图片蓝色舵机的三个引线中，棕色是GND，红色是电源，黄色是信号线，不同型号的舵机可以参考元件的说明书</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a76ee.png'><img src="https://pic.imgdb.cn/item/65cb2c8d9f345e8d039a76ee.png" alt="舵机电路图"></p>
<p>给舵机供电时需要看电源是否达标</p>
<h3 id="直流电机及驱动"><a href="#直流电机及驱动" class="headerlink" title="直流电机及驱动"></a>直流电机及驱动</h3><p>直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2e099f345e8d039ec4d9.png'><img src="https://pic.imgdb.cn/item/65cb2e099f345e8d039ec4d9.png" alt="直流电机"></p>
<p>直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作</p>
<p>TB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2e099f345e8d039ec5e9.png'><img src="https://pic.imgdb.cn/item/65cb2e099f345e8d039ec5e9.png" alt="直流电机驱动"></p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2e099f345e8d039ec52f.png'><img src="https://pic.imgdb.cn/item/65cb2e099f345e8d039ec52f.png" alt="直流电机电路"></p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af65.png'><img src="https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af65.png" alt="驱动电路硬件模块"></p>
<p>VM是电机电源，需要一个能输出大电流的电源，VCC是逻辑电平输入，需要和控制器电压相同<br>AO和BO是电机输出，PWMA，AIN1，AIN2是AO1/2对应的控制，其中PWMA接PWM信号输出端。<br>STBY是待机控制，接地待机，接VCC启动，需要时可以接GPIO控制<br>详细见下表：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af06.png'><img src="https://pic.imgdb.cn/item/65cb2f109f345e8d03a1af06.png" alt="电机驱动表"></p>
<h3 id="应用3-PWM驱动LED呼吸灯"><a href="#应用3-PWM驱动LED呼吸灯" class="headerlink" title="应用3.PWM驱动LED呼吸灯"></a>应用3.PWM驱动LED呼吸灯</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c86f399f345e8d0348fd06.jpg'><img src="https://pic.imgdb.cn/item/65c86f399f345e8d0348fd06.jpg" alt="接线图"></p>
<p>头文件 PWM.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);<br>    GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);<br>    GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_15;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM2);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">100</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">7200</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_OCInitTypeDef TIM_OCInitStructure;<br>    TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<br>    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;<br>    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>    TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">0</span>;<br>    TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);<br><br>    TIM_Cmd(TIM2,ENABLE);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_SetCompare1</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> Compare)</span><br>{<br>    TIM_SetCompare1(TIM2,Compare);<br>}<br><br></code></pre></td></tr></table></figure>

<p>主程序 mian.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><br><span class="hljs-type">uint16_t</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    PWM_Init();<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        {<br>            PWM_SetCompare1(i);<br>            Delay_ms(<span class="hljs-number">10</span>);<br>        }<br>        <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++)<br>        {<br>            PWM_SetCompare1(<span class="hljs-number">100</span>-i);<br>            Delay_ms(<span class="hljs-number">10</span>);<br>        }<br>       <br>    }<br>}<br><br></code></pre></td></tr></table></figure>
<p>总体步骤和51单片机呼吸灯相似</p>
<h3 id="应用4-PWM驱动电机"><a href="#应用4-PWM驱动电机" class="headerlink" title="应用4.PWM驱动电机"></a>应用4.PWM驱动电机</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c86f3a9f345e8d0348ff42.jpg'><img src="https://pic.imgdb.cn/item/65c86f3a9f345e8d0348ff42.jpg" alt="PWM驱动电机"></p>
<p>所有PWM通道输出信号跳变都是同步的，所以可以四个一起用</p>
<p>头文件 PWM.c（有更改）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    <span class="hljs-comment">// RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);</span><br>    <span class="hljs-comment">// GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);</span><br>    <span class="hljs-comment">// GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);</span><br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM2);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">2000</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">72</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_OCInitTypeDef TIM_OCInitStructure;<br>    TIM_OCStructInit(&amp;TIM_OCInitStructure);<br>    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;<br>    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;<br>    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;<br>    TIM_OCInitStructure.TIM_Pulse = <span class="hljs-number">0</span>;<br>    TIM_OC2Init(TIM2,&amp;TIM_OCInitStructure);<br><br>    TIM_Cmd(TIM2,ENABLE);<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">PWM_SetCompare2</span><span class="hljs-params">(<span class="hljs-type">uint16_t</span> Compare)</span><br>{<br>    TIM_SetCompare2(TIM2,Compare);<br>}<br><br></code></pre></td></tr></table></figure>

<p>Servo.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Servo_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    PWM_Init();<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Servo_SetAngle</span><span class="hljs-params">(<span class="hljs-type">float</span> Angle)</span><br>{<br>    PWM_SetCompare2(Angle/<span class="hljs-number">100</span>*<span class="hljs-number">2000</span>+<span class="hljs-number">500</span>);<br>}<br><br></code></pre></td></tr></table></figure>

<p>主程序 main.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Servo.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Key.h"</span></span><br><br><span class="hljs-type">uint16_t</span> KeyNum;<br><span class="hljs-type">float</span> Angle=<span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    Key_Init();<br>    Servo_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Angle:"</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        OLED_ShowSignedNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,Angle,<span class="hljs-number">3</span>);<br>        KeyNum=Key_GetNum();<br>        <span class="hljs-keyword">if</span> (KeyNum==<span class="hljs-number">1</span>)<br>        {<br>             Angle+=<span class="hljs-number">10</span>;<br>             <span class="hljs-keyword">if</span> (Angle&gt;=<span class="hljs-number">90</span>)<br>             {<br>                 Angle=<span class="hljs-number">0</span>;<br>             }<br>             Servo_SetAngle(Angle);<br>        }<br>    }<br>}<br><br></code></pre></td></tr></table></figure>

<h3 id="应用5-PWM驱动直流电机"><a href="#应用5-PWM驱动直流电机" class="headerlink" title="应用5.PWM驱动直流电机"></a>应用5.PWM驱动直流电机</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65c86f3b9f345e8d0349012e.jpg'><img src="https://pic.imgdb.cn/item/65c86f3b9f345e8d0349012e.jpg" alt="PWM驱动直流电机"></p>
<p>头文件<br>Motor.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Motor_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4 | GPIO_Pin_5;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    PWM_Init();<br>}<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Motor_SetSpeed</span><span class="hljs-params">(<span class="hljs-type">int8_t</span> Speed)</span><br>{<br>    <span class="hljs-keyword">if</span> (Speed &gt;= <span class="hljs-number">0</span>)<br>    {<br>        GPIO_SetBits(GPIOA,GPIO_Pin_4);<br>        GPIO_ResetBits(GPIOA,GPIO_Pin_5);<br>        PWM_SetCompare3(Speed);<br>    }<br>    <span class="hljs-keyword">else</span><br>    {<br>        GPIO_ResetBits(GPIOA,GPIO_Pin_4);<br>        GPIO_SetBits(GPIOA,GPIO_Pin_5);<br>        PWM_SetCompare3(-Speed);<br>    }<br>    <br>}<br></code></pre></td></tr></table></figure>
<p>主程序<br>mian.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Motor.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Key.h"</span></span><br><br><span class="hljs-type">uint8_t</span> KeyNum;<br><span class="hljs-type">int8_t</span> Speed;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    Motor_Init();<br>    Key_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Speed:"</span>);<br>    Motor_SetSpeed(<span class="hljs-number">20</span>);<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        KeyNum=Key_GetNum();<br>        <span class="hljs-keyword">if</span> (KeyNum==<span class="hljs-number">1</span>)<br>        {<br>            Speed+=<span class="hljs-number">20</span>;<br>            <span class="hljs-keyword">if</span> (Speed&gt;<span class="hljs-number">100</span>)<br>            {<br>                Speed=<span class="hljs-number">-100</span>;<br>            }  <br>        }<br>        Motor_SetSpeed(Speed);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,Speed,<span class="hljs-number">3</span>);<br>        <br>    }<br>}<br></code></pre></td></tr></table></figure>

<p>若电机旋转方向和自己想要的不一致可以更改Motor.c里面的Motor_SetSpeed函数</p>
<h3 id="输入捕获"><a href="#输入捕获" class="headerlink" title="输入捕获"></a>输入捕获</h3><p>IC(Input Compare)输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数</p>
<p>每个高级定时器和通用定时器都拥有4个输入捕获通道</p>
<p>可配置为PWMI模式，同时测量频率和占空比</p>
<p>可配合主从触发模式，实现硬件全自动测量</p>
<h4 id="频率测量"><a href="#频率测量" class="headerlink" title="频率测量"></a>频率测量</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cf09019f345e8d0389ef34.png'><img src="https://pic.imgdb.cn/item/65cf09019f345e8d0389ef34.png" alt="频率测量"></p>
<p>测频法：在闸门时间T内，对上升沿计次，得到N，则频率<br><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="7.645ex" height="2.765ex" role="img" focusable="false" viewBox="0 -877 3378.9 1222"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g><g data-mml-node="mo" transform="translate(1255.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(2311,0)"><g data-mml-node="mi" transform="translate(220,394) scale(0.707)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="mi" transform="translate(285.1,-345) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><rect width="827.9" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<p>测频法适合高频</p>
<p>测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率<br><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.781ex;" xmlns="http://www.w3.org/2000/svg" width="7.645ex" height="3.006ex" role="img" focusable="false" viewBox="0 -983.5 3378.9 1328.5"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><path data-c="1D465" d="M52 289Q59 331 106 386T222 442Q257 442 286 424T329 379Q371 442 430 442Q467 442 494 420T522 361Q522 332 508 314T481 292T458 288Q439 288 427 299T415 328Q415 374 465 391Q454 404 425 404Q412 404 406 402Q368 386 350 336Q290 115 290 78Q290 50 306 38T341 26Q378 26 414 59T463 140Q466 150 469 151T485 153H489Q504 153 504 145Q504 144 502 134Q486 77 440 33T333 -11Q263 -11 227 52Q186 -10 133 -10H127Q78 -10 57 16T35 71Q35 103 54 123T99 143Q142 143 142 101Q142 81 130 66T107 46T94 41L91 40Q91 39 97 36T113 29T132 26Q168 26 194 71Q203 87 217 139T245 247T261 313Q266 340 266 352Q266 380 251 392T217 404Q177 404 142 372T93 290Q91 281 88 280T72 278H58Q52 284 52 289Z"></path></g></g><g data-mml-node="mo" transform="translate(1255.2,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="mfrac" transform="translate(2311,0)"><g data-mml-node="msub" transform="translate(223.1,485) scale(0.707)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><g data-mml-node="mi" transform="translate(220,-345) scale(0.707)"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><rect width="827.9" height="60" x="120" y="220"></rect></g></g></g></svg></mjx-container></p>
<p>测周法适合低频</p>
<p>在上述的两种方法中，N越大，误差越大，在某个频率下测频法和测周法的N相同，此频率为中界频率</p>
<p>中界频率：测频法与测周法误差相等的频率点<br><mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -1.161ex;" xmlns="http://www.w3.org/2000/svg" width="10.428ex" height="4.208ex" role="img" focusable="false" viewBox="0 -1346.7 4609.1 1860"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="msub"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><path data-c="1D45A" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"></path></g></g><g data-mml-node="mo" transform="translate(1471.6,0)"><path data-c="3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"></path></g><g data-mml-node="msqrt" transform="translate(2527.4,0)"><g transform="translate(1020,0)"><g data-mml-node="mfrac"><g data-mml-node="msub" transform="translate(220,485) scale(0.707)"><g data-mml-node="mi"><path data-c="1D453" d="M118 -162Q120 -162 124 -164T135 -167T147 -168Q160 -168 171 -155T187 -126Q197 -99 221 27T267 267T289 382V385H242Q195 385 192 387Q188 390 188 397L195 425Q197 430 203 430T250 431Q298 431 298 432Q298 434 307 482T319 540Q356 705 465 705Q502 703 526 683T550 630Q550 594 529 578T487 561Q443 561 443 603Q443 622 454 636T478 657L487 662Q471 668 457 668Q445 668 434 658T419 630Q412 601 403 552T387 469T380 433Q380 431 435 431Q480 431 487 430T498 424Q499 420 496 407T491 391Q489 386 482 386T428 385H372L349 263Q301 15 282 -47Q255 -132 212 -173Q175 -205 139 -205Q107 -205 81 -186T55 -132Q55 -95 76 -78T118 -61Q162 -61 162 -103Q162 -122 151 -136T127 -157L118 -162Z"></path></g><g data-mml-node="mi" transform="translate(523,-150) scale(0.707)"><path data-c="1D450" d="M34 159Q34 268 120 355T306 442Q362 442 394 418T427 355Q427 326 408 306T360 285Q341 285 330 295T319 325T330 359T352 380T366 386H367Q367 388 361 392T340 400T306 404Q276 404 249 390Q228 381 206 359Q162 315 142 235T121 119Q121 73 147 50Q169 26 205 26H209Q321 26 394 111Q403 121 406 121Q410 121 419 112T429 98T420 83T391 55T346 25T282 0T202 -11Q127 -11 81 37T34 159Z"></path></g></g><g data-mml-node="mi" transform="translate(281.9,-345) scale(0.707)"><path data-c="1D447" d="M40 437Q21 437 21 445Q21 450 37 501T71 602L88 651Q93 669 101 677H569H659Q691 677 697 676T704 667Q704 661 687 553T668 444Q668 437 649 437Q640 437 637 437T631 442L629 445Q629 451 635 490T641 551Q641 586 628 604T573 629Q568 630 515 631Q469 631 457 630T439 622Q438 621 368 343T298 60Q298 48 386 46Q418 46 427 45T436 36Q436 31 433 22Q429 4 424 1L422 0Q419 0 415 0Q410 0 363 1T228 2Q99 2 64 0H49Q43 6 43 9T45 27Q49 40 55 46H83H94Q174 46 189 55Q190 56 191 56Q196 59 201 76T241 233Q258 301 269 344Q339 619 339 625Q339 630 310 630H279Q212 630 191 624Q146 614 121 583T67 467Q60 445 57 441T43 437H40Z"></path></g><rect width="821.7" height="60" x="120" y="220"></rect></g></g><g data-mml-node="mo" transform="translate(0,136.7)"><path data-c="221A" d="M1001 1150Q1017 1150 1020 1132Q1020 1127 741 244L460 -643Q453 -650 436 -650H424Q423 -647 423 -645T421 -640T419 -631T415 -617T408 -594T399 -560T385 -512T367 -448T343 -364T312 -259L203 119L138 41L111 67L212 188L264 248L472 -474L983 1140Q988 1150 1001 1150Z"></path></g><rect width="1061.7" height="60" x="1020" y="1226.7"></rect></g></g></g></svg></mjx-container></p>
<h4 id="输入捕获通道"><a href="#输入捕获通道" class="headerlink" title="输入捕获通道"></a>输入捕获通道</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cf15089f345e8d03b1364c.png'><img src="https://pic.imgdb.cn/item/65cf15089f345e8d03b1364c.png" alt="输入捕获通道"></p>
<h3 id="应用6-输入捕获模式测频率"><a href="#应用6-输入捕获模式测频率" class="headerlink" title="应用6.输入捕获模式测频率"></a>应用6.输入捕获模式测频率</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg'><img src="https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg" alt="输入捕获模式测频率"></p>
<p>头文件<br>IC.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">IC_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM3);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">65536</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">72</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_ICInitTypeDef TIM_ICInitStructure;<br>    TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<br>    TIM_ICInitStructure.TIM_ICFilter=<span class="hljs-number">0xF</span>;<br>    TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;<br>    TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;<br>    TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;<br>    TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);<br><br>    TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);<br>    TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);<br><br>    TIM_Cmd(TIM3,ENABLE);<br>}<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">IC_GetFreq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span>/(TIM_GetCapture1(TIM3)+<span class="hljs-number">1</span>);<br>}<br><br></code></pre></td></tr></table></figure>

<p>主程序<br>mian.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"IC.h"</span></span><br><br><span class="hljs-type">uint16_t</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    PWM_Init();<br>	IC_Init();<br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Freq:00000Hz"</span>);<br><br>    PWM_SetPrescaler(<span class="hljs-number">720</span><span class="hljs-number">-1</span>);<br>    PWM_SetCompare1(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        OLED_ShowNum(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,IC_GetFreq(),<span class="hljs-number">5</span>);<br>       <br>    }<br>}<br><br></code></pre></td></tr></table></figure>

<h3 id="应用7-PWMI模式测占空比"><a href="#应用7-PWMI模式测占空比" class="headerlink" title="应用7.PWMI模式测占空比"></a>应用7.PWMI模式测占空比</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg'><img src="https://pic.imgdb.cn/item/65cf43da9f345e8d034d70fb.jpg" alt="PWMI模式测占空比"></p>
<p>头文件：<br>IC.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">IC_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;<br>    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;<br>    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    TIM_InternalClockConfig(TIM3);<br><br>    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;<br>    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;<br>    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;<br>    TIM_TimeBaseInitStructure.TIM_Period=<span class="hljs-number">65536</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_Prescaler=<span class="hljs-number">72</span><span class="hljs-number">-1</span>;<br>    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=<span class="hljs-number">0</span>;<br>    TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);<br><br>    TIM_ICInitTypeDef TIM_ICInitStructure;<br>    TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;<br>    TIM_ICInitStructure.TIM_ICFilter=<span class="hljs-number">0xF</span>;<br>    TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;<br>    TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;<br>    TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;<br>    TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);<br><br>    TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);<br>    TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);<br><br>    TIM_Cmd(TIM3,ENABLE);<br>}<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">IC_GetFreq</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1000000</span>/(TIM_GetCapture1(TIM3)+<span class="hljs-number">1</span>);<br>}<br><br><span class="hljs-type">uint32_t</span> <span class="hljs-title function_">IC_GetPuty</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <span class="hljs-keyword">return</span> (TIM_GetCapture2(TIM3)+<span class="hljs-number">1</span>)*<span class="hljs-number">100</span>/(TIM_GetCapture1(TIM3)+<span class="hljs-number">1</span>);<br>}<br><br></code></pre></td></tr></table></figure>

<p>主程序<br>mian.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"PWM.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"IC.h"</span></span><br><br><span class="hljs-type">uint16_t</span> i;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    PWM_Init();<br>	IC_Init();<br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Freq:00000Hz"</span>);<br>    OLED_ShowString(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Duty:000%"</span>);<br><br>    PWM_SetPrescaler(<span class="hljs-number">720</span><span class="hljs-number">-1</span>);<br>    PWM_SetCompare1(<span class="hljs-number">50</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        OLED_ShowNum(<span class="hljs-number">1</span>,<span class="hljs-number">6</span>,IC_GetFreq(),<span class="hljs-number">5</span>);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">6</span>,IC_GetPuty(),<span class="hljs-number">3</span>);<br>    }<br>}<br><br></code></pre></td></tr></table></figure>

<p>因为没有信号发生器，所以这里的信号由GPIOA_PIN0产生的PW吗波代替</p>
<h3 id="编码器接口"><a href="#编码器接口" class="headerlink" title="编码器接口"></a>编码器接口</h3><p>编码器接口(Encoder Interface )可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度</p>
<p>每个高级定时器和通用定时器都拥有1个编码器接口</p>
<p>两个输入引脚借用了输入捕获的通道1和通道2</p>
<h4 id="正交编码器"><a href="#正交编码器" class="headerlink" title="正交编码器"></a>正交编码器</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65cf64739f345e8d03d32021.png'><img src="https://pic.imgdb.cn/item/65cf64739f345e8d03d32021.png" alt="正交编码器"></p>
<p>由图：在正转时A相提前B相90°，反转时A相滞后B相90°（具体哪个提前哪个滞后可以自己改）</p>
<p>使用正交信号好处：</p>
<ol>
<li>更精确</li>
<li>抗噪声</li>
</ol>
<p>编码器接口基本结构：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf69749f345e8d03e9f226.png'><img src="https://pic.imgdb.cn/item/65cf69749f345e8d03e9f226.png" alt="编码器接口基本结构"></p>
<p>工作模式：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf6f289f345e8d0303e56d.png'><img src="https://pic.imgdb.cn/item/65cf6f289f345e8d0303e56d.png" alt="工作模式"></p>
<p>实例：<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf6ff69f345e8d03073f38.png'><img src="https://pic.imgdb.cn/item/65cf6ff69f345e8d03073f38.png" alt="e.p.1"></p>
<p>通过调节IC1PF1可以使反向</p>
<p>实例（反向）:<br class='item-img' data-src='https://pic.imgdb.cn/item/65cf70ea9f345e8d030b4162.png'><img src="https://pic.imgdb.cn/item/65cf70ea9f345e8d030b4162.png" alt="1.p.e"></p>
<h3 id="应用8-编码器接口测速"><a href="#应用8-编码器接口测速" class="headerlink" title="应用8.编码器接口测速"></a>应用8.编码器接口测速</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65d9814e9f345e8d0306048b.jpg'><img src="https://pic.imgdb.cn/item/65d9814e9f345e8d0306048b.jpg" alt="编码器接口测速"></p>
<p>头文件：Encoder.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：编码器初始化</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">Encoder_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-comment">/*开启时钟*/</span><br>	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);			<span class="hljs-comment">//开启TIM3的时钟</span><br>	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);			<span class="hljs-comment">//开启GPIOA的时钟</span><br>	<br>	<span class="hljs-comment">/*GPIO初始化*/</span><br>	GPIO_InitTypeDef GPIO_InitStructure;<br>	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;<br>	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;<br>	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>	GPIO_Init(GPIOA, &amp;GPIO_InitStructure);							<span class="hljs-comment">//将PA6和PA7引脚初始化为上拉输入</span><br>	<br>	<span class="hljs-comment">/*时基单元初始化*/</span><br>	TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;				<span class="hljs-comment">//定义结构体变量</span><br>	TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     <span class="hljs-comment">//时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能</span><br>	TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; <span class="hljs-comment">//计数器模式，选择向上计数</span><br>	TIM_TimeBaseInitStructure.TIM_Period = <span class="hljs-number">65536</span> - <span class="hljs-number">1</span>;               <span class="hljs-comment">//计数周期，即ARR的值</span><br>	TIM_TimeBaseInitStructure.TIM_Prescaler = <span class="hljs-number">1</span> - <span class="hljs-number">1</span>;                <span class="hljs-comment">//预分频器，即PSC的值</span><br>	TIM_TimeBaseInitStructure.TIM_RepetitionCounter = <span class="hljs-number">0</span>;            <span class="hljs-comment">//重复计数器，高级定时器才会用到</span><br>	TIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             <span class="hljs-comment">//将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元</span><br>	<br>	<span class="hljs-comment">/*输入捕获初始化*/</span><br>	TIM_ICInitTypeDef TIM_ICInitStructure;							<span class="hljs-comment">//定义结构体变量</span><br>	TIM_ICStructInit(&amp;TIM_ICInitStructure);							<span class="hljs-comment">//结构体初始化，若结构体没有完整赋值</span><br>																	<span class="hljs-comment">//则最好执行此函数，给结构体所有成员都赋一个默认值</span><br>																	<span class="hljs-comment">//避免结构体初值不确定的问题</span><br>	TIM_ICInitStructure.TIM_Channel = TIM_Channel_1;				<span class="hljs-comment">//选择配置定时器通道1</span><br>	TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;							<span class="hljs-comment">//输入滤波器参数，可以过滤信号抖动</span><br>	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);							<span class="hljs-comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><br>	TIM_ICInitStructure.TIM_Channel = TIM_Channel_2;				<span class="hljs-comment">//选择配置定时器通道2</span><br>	TIM_ICInitStructure.TIM_ICFilter = <span class="hljs-number">0xF</span>;							<span class="hljs-comment">//输入滤波器参数，可以过滤信号抖动</span><br>	TIM_ICInit(TIM3, &amp;TIM_ICInitStructure);							<span class="hljs-comment">//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道</span><br>	<br>	<span class="hljs-comment">/*编码器接口配置*/</span><br>	TIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);<br>																	<span class="hljs-comment">//配置编码器模式以及两个输入通道是否反相</span><br>																	<span class="hljs-comment">//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相</span><br>																	<span class="hljs-comment">//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置</span><br>	<br>	<span class="hljs-comment">/*TIM使能*/</span><br>	TIM_Cmd(TIM3, ENABLE);			<span class="hljs-comment">//使能TIM3，定时器开始运行</span><br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：获取编码器的增量值</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：自上此调用此函数后，编码器的增量值</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">int16_t</span> <span class="hljs-title function_">Encoder_Get</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-comment">/*使用Temp变量作为中继，目的是返回CNT后将其清零*/</span><br>	<span class="hljs-type">int16_t</span> Temp;<br>	Temp = TIM_GetCounter(TIM3);<br>	TIM_SetCounter(TIM3, <span class="hljs-number">0</span>);<br>	<span class="hljs-keyword">return</span> Temp;<br>}<br></code></pre></td></tr></table></figure>

<p>主程序：main.c</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Timer.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Encoder.h"</span></span><br><br><span class="hljs-type">int16_t</span> Speed;			<span class="hljs-comment">//定义速度变量</span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-comment">/*模块初始化*/</span><br>	OLED_Init();		<span class="hljs-comment">//OLED初始化</span><br>	Timer_Init();		<span class="hljs-comment">//定时器初始化</span><br>	Encoder_Init();		<span class="hljs-comment">//编码器初始化</span><br>	<br>	<span class="hljs-comment">/*显示静态字符串*/</span><br>	OLED_ShowString(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-string">"Speed:"</span>);		<span class="hljs-comment">//1行1列显示字符串Speed:</span><br>	<br>	<span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>)<br>	{<br>		OLED_ShowSignedNum(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>, Speed, <span class="hljs-number">5</span>);	<span class="hljs-comment">//不断刷新显示编码器测得的最新速度</span><br>	}<br>}<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 函    数：TIM2中断函数</span><br><span class="hljs-comment">  * 参    数：无</span><br><span class="hljs-comment">  * 返 回 值：无</span><br><span class="hljs-comment">  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行</span><br><span class="hljs-comment">  *           函数名为预留的指定名称，可以从启动文件复制</span><br><span class="hljs-comment">  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入</span><br><span class="hljs-comment">  */</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">TIM2_IRQHandler</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	<span class="hljs-keyword">if</span> (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)		<span class="hljs-comment">//判断是否是TIM2的更新事件触发的中断</span><br>	{<br>		Speed = Encoder_Get();								<span class="hljs-comment">//每隔固定时间段读取一次编码器计数增量值，即为速度值</span><br>		TIM_ClearITPendingBit(TIM2, TIM_IT_Update);			<span class="hljs-comment">//清除TIM2更新事件的中断标志位</span><br>															<span class="hljs-comment">//中断标志位必须清除</span><br>															<span class="hljs-comment">//否则中断将连续不断地触发，导致主程序卡死</span><br>	}<br>}<br></code></pre></td></tr></table></figure>

<h2 id="ADC-数模转换器"><a href="#ADC-数模转换器" class="headerlink" title="ADC 数模转换器"></a>ADC 数模转换器</h2><p>ADC（Analog-Digital Converter）模拟-数字转换器</p>
<p>ADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁</p>
<p>12位逐次逼近型ADC，1us转换时间</p>
<p>输入电压范围：0<del>3.3V，转换结果范围：0</del>4095</p>
<p>18个输入通道，可测量16个外部和2个内部信号源</p>
<p>规则组和注入组两个转换单元</p>
<p>模拟看门狗自动监测输入电压范围</p>
<p>STM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道</p>
<h4 id="逐次逼近型ADC"><a href="#逐次逼近型ADC" class="headerlink" title="逐次逼近型ADC"></a>逐次逼近型ADC</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d984c89f345e8d030f69d8.png'><img src="https://pic.imgdb.cn/item/65d984c89f345e8d030f69d8.png" alt="逐次逼近型ADC"></p>
<p>通道选择开关八个通道都可输入，地址锁存和译码可选择输入的通道</p>
<p>DAC输入的电压在比较器与通道进入的电压比较，逼近，直至大约相等，此时DAC电压等于输入电压，比较过程使用二分法</p>
<p>CLOCK是时钟，START是输入信号，EOC是输出信号</p>
<p>V_REF是参考电压</p>
<h4 id="ADC框图"><a href="#ADC框图" class="headerlink" title="ADC框图"></a>ADC框图</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d986389f345e8d0313c539.png'><img src="https://pic.imgdb.cn/item/65d986389f345e8d0313c539.png" alt="ADC框图"></p>
<p>左侧ADCx_IN是输入口，经过选择器进入模数转换器（原理类似于上面逐次逼近型ADC），输出数据保存在寄存器，可以读取</p>
<p>在这个模型里，可以一次性选择多个通道，注入通道上限4个，规则通道上限16个</p>
<p>规则通道只有一个寄存器，所以直接使用会导致前面的数据丢失，只有最后的数据，常配合DMA使用，DMA可以将前面的数据移至其他地方存储。</p>
<p>为了减少对程序的影响，左下两个触发使用硬件触发，将TIM3设为TRGO，定时，就可以自动触发ADC转换，节省了触发资源</p>
<p>右上角模拟看门狗，可以设置模拟阈值，当达到阈值的时候就会申请NVIC的ADC中断，同样，（注入）转换结束也能申请中断</p>
<h4 id="输入通道"><a href="#输入通道" class="headerlink" title="输入通道"></a>输入通道</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98a0c9f345e8d031ef502.png'><img src="https://pic.imgdb.cn/item/65d98a0c9f345e8d031ef502.png" alt="输入通道"></p>
<p><em>ADC1和ADC2可分开使用，也可以一起使用</em></p>
<h4 id="转换模式"><a href="#转换模式" class="headerlink" title="转换模式"></a>转换模式</h4><h5 id="单次转换非扫描模式"><a href="#单次转换非扫描模式" class="headerlink" title="单次转换非扫描模式"></a>单次转换非扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c1e3.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c1e3.png" alt="单次转换非扫描模式"></p>
<p>把想要转换的通道放在序列1，转换后数据存放在数据寄存器，通识EOC置1</p>
<h5 id="连续转换非扫描模式"><a href="#连续转换非扫描模式" class="headerlink" title="连续转换非扫描模式"></a>连续转换非扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c2d4.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c2d4.png" alt="连续转换非扫描模式"></p>
<p>连续转换不需要判断结束，需要数据直接读取</p>
<h5 id="单次转换扫描模式"><a href="#单次转换扫描模式" class="headerlink" title="单次转换扫描模式"></a>单次转换扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c25c.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c25c.png" alt="单次转换扫描模式"></p>
<p>设置通道数目，每次只转换通道数目对应数目的，全部完成之后EOC置1</p>
<h5 id="连续转换扫描模式"><a href="#连续转换扫描模式" class="headerlink" title="连续转换扫描模式"></a>连续转换扫描模式</h5><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98b469f345e8d0322c361.png'><img src="https://pic.imgdb.cn/item/65d98b469f345e8d0322c361.png" alt="连续转换扫描模式"></p>
<p>连续扫描</p>
<h4 id="触发控制"><a href="#触发控制" class="headerlink" title="触发控制"></a>触发控制</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98cdf9f345e8d03273840.png'><img src="https://pic.imgdb.cn/item/65d98cdf9f345e8d03273840.png" alt="触发控制"></p>
<h4 id="数据对齐"><a href="#数据对齐" class="headerlink" title="数据对齐"></a>数据对齐</h4><p>分为<strong>数据右对齐</strong>和<strong>数据左对齐</strong>，分别为左侧和右侧补0，右对齐比较常用</p>
<h4 id="转换时间"><a href="#转换时间" class="headerlink" title="转换时间"></a>转换时间</h4><p>AD转换的步骤：采样，保持，量化，编码</p>
<p>STM32 ADC的总转换时间为：<br>    T_CONV = 采样时间 + 12.5个ADC周期</p>
<p>例如：当ADCCLK=14MHz，采样时间为1.5个ADC周期<br>    T_CONV = 1.5 + 12.5 = 14个ADC周期 = 1μs</p>
<h4 id="校准"><a href="#校准" class="headerlink" title="校准"></a>校准</h4><p>ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差</p>
<p>建议在每次上电后执行一次校准</p>
<p>启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期</p>
<h4 id="硬件电路"><a href="#硬件电路" class="headerlink" title="硬件电路"></a>硬件电路</h4><p class='item-img' data-src='https://pic.imgdb.cn/item/65d98e219f345e8d032ac21c.png'><img src="https://pic.imgdb.cn/item/65d98e219f345e8d032ac21c.png" alt="硬件电路"></p>
<h3 id="应用1-AD单通道"><a href="#应用1-AD单通道" class="headerlink" title="应用1.AD单通道"></a>应用1.AD单通道</h3><p>面包板接线图：</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65db49e69f345e8d03468302.jpg'><img src="https://pic.imgdb.cn/item/65db49e69f345e8d03468302.jpg" alt="AD单通道"></p>
<p>头文件 AD.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">AD_Init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);<br>    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);<br><br>    RCC_ADCCLKConfig(RCC_PCLK2_Div6);<br><br>    GPIO_InitTypeDef GPIO_InitStructure;<br>    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;<br>    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;<br>    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;<br>    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);<br><br>    ADC_RegularChannelConfig(ADC1,ADC_Channel_0,<span class="hljs-number">1</span>,ADC_SampleTime_55Cycles5);<br><br>    ADC_InitTypeDef ADC_InitStructure;<br>    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;<br>    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;<br>    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;<br>    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;<br>    ADC_InitStructure.ADC_NbrOfChannel = <span class="hljs-number">1</span>;<br>    ADC_InitStructure.ADC_ScanConvMode = DISABLE;<br>    ADC_Init(ADC1,&amp;ADC_InitStructure);<br><br>    ADC_Cmd(ADC1,ENABLE);<br><br>    ADC_ResetCalibration(ADC1);<br>    <span class="hljs-keyword">while</span>(ADC_GetResetCalibrationStatus(ADC1) == SET);<br>    ADC_StartCalibration(ADC1);<br>    <span class="hljs-keyword">while</span>(ADC_GetCalibrationStatus(ADC1) == SET);<br><br>    ADC_SoftwareStartConvCmd(ADC1,ENABLE);<br>}<br><br><span class="hljs-type">uint16_t</span> <span class="hljs-title function_">AD_GetValue</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>    <br>    <span class="hljs-keyword">return</span> ADC_GetConversionValue(ADC1);<br>}<br><br></code></pre></td></tr></table></figure>
<p>上面程序配置的是连续模式，将init函数的最后一行移到getvalue函数的第一行并在后面加一行<code>    while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET);</code>并将<code>    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;</code>改为DISABLE即可改成非连续模式。</p>
<p>主程序 main.c:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"stm32f10x.h"</span>                  <span class="hljs-comment">// Device header</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"Delay.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"OLED.h"</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">"AD.h"</span></span><br><br><span class="hljs-type">uint16_t</span> ADVALUE;<br><span class="hljs-type">float</span> Voltage;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>{<br>	OLED_Init();<br>    AD_Init();<br><br>    OLED_ShowString(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"ADVALUE:"</span>);<br>    OLED_ShowString(<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-string">"Voltage:"</span>);<br><br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)<br>    {<br>        ADVALUE = AD_GetValue();<br>        Voltage = (<span class="hljs-type">float</span>)ADVALUE/<span class="hljs-number">4095</span>*<span class="hljs-number">3</span>;<br><br>        OLED_ShowNum(<span class="hljs-number">1</span>,<span class="hljs-number">9</span>,ADVALUE,<span class="hljs-number">4</span>);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">9</span>,Voltage,<span class="hljs-number">1</span>);<br>        OLED_ShowNum(<span class="hljs-number">2</span>,<span class="hljs-number">11</span>,(<span class="hljs-type">uint16_t</span>)(Voltage*<span class="hljs-number">100</span>)%<span class="hljs-number">100</span>,<span class="hljs-number">3</span>);<br>        OLED_ShowChar(<span class="hljs-number">2</span>,<span class="hljs-number">10</span>,<span class="hljs-string">'.'</span>);<br>        Delay_ms(<span class="hljs-number">100</span>);<br>    }<br>}<br><br></code></pre></td></tr></table></figure>

<h3 id="应用2-AD多通道"><a href="#应用2-AD多通道" class="headerlink" title="应用2.AD多通道"></a>应用2.AD多通道</h3><p>面包板接线图：<br class='item-img' data-src='https://pic.imgdb.cn/item/65db52cc9f345e8d03629888.jpg'><img src="https://pic.imgdb.cn/item/65db52cc9f345e8d03629888.jpg" alt="AD多通道"></p>
<h2 id="DMA"><a href="#DMA" class="headerlink" title="DMA"></a>DMA</h2><p>DMA（Direct Memory Access）直接存储器存取<br>DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源<br>12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）<br>每个通道都支持软件触发和特定的硬件触发</p>
<p>STM32F103C8T6 DMA资源：DMA1（7个通道）</p>
<h3 id="存储器映像"><a href="#存储器映像" class="headerlink" title="存储器映像"></a>存储器映像</h3><p>ROM：</p>
<table>
<thead>
<tr>
<th align="center">起始地址</th>
<th align="center">存储器</th>
<th align="center">用途</th>
</tr>
</thead>
<tbody><tr>
<td align="center">0x0800 0000</td>
<td align="center">程序存储器Flash</td>
<td align="center">存储C语言编译后的程序代码</td>
</tr>
<tr>
<td align="center">0x1FFF F000</td>
<td align="center">系统存储器</td>
<td align="center">存储BootLoader，用于串口下载</td>
</tr>
<tr>
<td align="center">0x1FFF F800</td>
<td align="center">选项字节</td>
<td align="center">存储一些独立于程序代码的配置参数</td>
</tr>
</tbody></table>
<h3 id="DMA基本结构"><a href="#DMA基本结构" class="headerlink" title="DMA基本结构"></a>DMA基本结构</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed1f029f345e8d0359f9d4.png'><img src="https://pic.imgdb.cn/item/65ed1f029f345e8d0359f9d4.png" alt="DMA_Basic_Structure"></p>
<h3 id="DMA请求"><a href="#DMA请求" class="headerlink" title="DMA请求"></a>DMA请求</h3><p>这部分是上面DMA触发的内容</p>
<p class='item-img' data-src='https://pic.imgdb.cn/item/65ed20519f345e8d0360b262.png'><img src="https://pic.imgdb.cn/item/65ed20519f345e8d0360b262.png" alt="DMA_Request"></p>
<p>M2M是选择位，选择硬件触发还是软件触发，EN是开关控制</p>
<h3 id="数据转运-DMA"><a href="#数据转运-DMA" class="headerlink" title="数据转运+DMA"></a>数据转运+DMA</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed229d9f345e8d036cc68c.png'><img src="https://pic.imgdb.cn/item/65ed229d9f345e8d036cc68c.png" alt="数据转运+DMA"></p>
<h3 id="ADC扫描模式-DMA"><a href="#ADC扫描模式-DMA" class="headerlink" title="ADC扫描模式+DMA"></a>ADC扫描模式+DMA</h3><p class='item-img' data-src='https://pic.imgdb.cn/item/65ed229d9f345e8d036cc82e.png'><img src="https://pic.imgdb.cn/item/65ed229d9f345e8d036cc82e.png" alt="ADC扫描模式+DMA"></p>
<p>其他模式下DMA作用类似于锦上添花，但是对于ADC而言DMA非常重要，没有DMA会使ADC功能大大受限，所以ADC+DMA是非常常见经典的组合</p>
<div id="paginator"></div></div><div id="post-footer"><div id="pages"><div class="footer-link" style="width: 50%;text-align:right;border-right:1px #fe2 solid"><a href="/2024/02/01/stm32%E7%AC%94%E8%AE%B02%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/">← 下一篇 stm32笔记2（不定更新 ）</a></div><div class="footer-link" style="width: 50%;right:1px;border-left:1px #fe2 solid"><a href="/2023/11/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">51单片机入门学习笔记 上一篇 →</a></div></div></div><details id="reward"><summary>给穷逼一点钱吧！</summary><div><span>支付宝（AliPay）</span><br><img src="/img/Alipay.png"></div><div><span>微信（WeiChat）</span><br><img src="/img/WeChat.png"></div></details><div id="comments"><div class="selector"><button class="valine-sel"></button><button class="gitalk-sel"></button></div><div id="valine"></div><div id="gitalk"></div></div></div><div class="bottom-btn"><div><a class="i-top" id="to-top" onClick="scrolls.scrolltop();" title="回到顶部" style="opacity: 0; display: none;">∧ </a><a class="i-index" id="to-index" href="#toc-div" title="文章目录">≡</a><a class="i-color" id="color-mode" onClick="colorMode.change()" title="切换主题"></a></div></div></article><aside><div id="about"><a href="/" id="logo"><img src="https://ak.hypergryph.com/assets/index/images/ak/pc/faction/4.png" alt="Logo"></a><h1 id="Dr"><a href="/">Passenger</a></h1><div id="description"><p></p></div><div id="social-links"><a class="social" target="_blank" rel="noopener" href="https://github.com/zjuter"><i class="fab fa-github" alt="GitHub"></i></a><a class="social" href="mailto:setupcard@foxmail.com"><i class="fa fa-envelope" alt="E-Mail"></i></a><a class="social" target="_blank" rel="noopener" href="https://space.bilibili.com/504270070?spm_id_from=333.1007.0.0"><i class="fa-brands fa-bilibili" alt="BiliBili"></i></a></div></div><div id="aside-block"><div id="toc-div"><h1>目录</h1><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0"><span class="toc-number">1.</span> <span class="toc-text">STM32学习笔记</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-%E6%96%B0%E5%BB%BA%E5%B7%A5%E7%A8%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1-新建工程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-GPIO"><span class="toc-number">1.2.</span> <span class="toc-text">2-GPIO</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO%E7%AE%80%E4%BB%8B"><span class="toc-number">1.2.1.</span> <span class="toc-text">GPIO简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.2.</span> <span class="toc-text">GPIO基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GPIO%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">GPIO模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%B5%AE%E7%A9%BA-%E4%B8%8A%E6%8B%89-%E4%B8%8B%E6%8B%89%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.3.1.</span> <span class="toc-text">浮空&#x2F;上拉&#x2F;下拉输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F%E8%BE%93%E5%85%A5"><span class="toc-number">1.2.3.2.</span> <span class="toc-text">模拟输入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%80%E6%BC%8F-%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.3.3.</span> <span class="toc-text">开漏&#x2F;推挽输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%8D%E7%94%A8%E5%BC%80%E6%BC%8F-%E5%A4%8D%E7%94%A8%E6%8E%A8%E6%8C%BD%E8%BE%93%E5%87%BA"><span class="toc-number">1.2.3.4.</span> <span class="toc-text">复用开漏&#x2F;复用推挽输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LED%E5%92%8C%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">1.2.3.5.</span> <span class="toc-text">LED和蜂鸣器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%9D%A2%E5%8C%85%E6%9D%BF"><span class="toc-number">1.2.3.6.</span> <span class="toc-text">面包板</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A81-LED%E9%97%AA%E7%83%81"><span class="toc-number">1.2.4.</span> <span class="toc-text">应用1.LED闪烁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A82-LED%E6%B5%81%E6%B0%B4%E7%81%AF"><span class="toc-number">1.2.5.</span> <span class="toc-text">应用2.LED流水灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A83-%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">1.2.6.</span> <span class="toc-text">应用3.蜂鸣器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BC%A0%E6%84%9F%E5%99%A8%E6%A8%A1%E5%9D%97"><span class="toc-number">1.2.7.</span> <span class="toc-text">传感器模块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%83%A8%E5%88%86C%E8%AF%AD%E8%A8%80%E7%9F%A5%E8%AF%86%E7%82%B9"><span class="toc-number">1.2.8.</span> <span class="toc-text">部分C语言知识点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.2.8.1.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%8F%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.8.2.</span> <span class="toc-text">宏定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#typedef"><span class="toc-number">1.2.8.3.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.2.8.4.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9E%9A%E4%B8%BE"><span class="toc-number">1.2.8.5.</span> <span class="toc-text">枚举</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A84-%E6%8C%89%E9%94%AE%E6%8E%A7%E5%88%B6LED"><span class="toc-number">1.2.9.</span> <span class="toc-text">应用4.按键控制LED</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A85-%E5%85%89%E6%95%8F%E4%BC%A0%E6%84%9F%E5%99%A8%E6%8E%A7%E5%88%B6%E8%9C%82%E9%B8%A3%E5%99%A8"><span class="toc-number">1.2.10.</span> <span class="toc-text">应用5.光敏传感器控制蜂鸣器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OLED"><span class="toc-number">1.3.</span> <span class="toc-text">OLED</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B"><span class="toc-number">1.3.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.2.</span> <span class="toc-text">调试方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8%E5%87%BD%E6%95%B0"><span class="toc-number">1.3.3.</span> <span class="toc-text">驱动函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9E%E4%BD%93%E6%BC%94%E7%A4%BA"><span class="toc-number">1.3.4.</span> <span class="toc-text">实体演示</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXTI%E5%A4%96%E9%83%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">1.4.</span> <span class="toc-text">EXTI外部中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E4%BB%8B-1"><span class="toc-number">1.4.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E6%96%AD%E7%B3%BB%E7%BB%9F"><span class="toc-number">1.4.2.</span> <span class="toc-text">中断系统</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#NVIC"><span class="toc-number">1.4.3.</span> <span class="toc-text">NVIC</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#NVIC%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.3.1.</span> <span class="toc-text">NVIC基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NVIC%E4%BC%98%E5%85%88%E7%BA%A7%E5%88%86%E7%BB%84"><span class="toc-number">1.4.3.2.</span> <span class="toc-text">NVIC优先级分组</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#EXTI"><span class="toc-number">1.4.4.</span> <span class="toc-text">EXTI</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#EXTI%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.4.4.1.</span> <span class="toc-text">EXTI基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AFIO%E5%A4%8D%E7%94%A8IO%E5%8F%A3"><span class="toc-number">1.4.4.2.</span> <span class="toc-text">AFIO复用IO口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#EXTI%E5%86%85%E9%83%A8%E6%A1%86%E5%9B%BE"><span class="toc-number">1.4.4.3.</span> <span class="toc-text">EXTI内部框图</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E4%BB%8B%E7%BB%8D"><span class="toc-number">1.4.5.</span> <span class="toc-text">旋转编码器介绍</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A81-%E5%AF%B9%E5%B0%84%E5%BC%8F%E7%BA%A2%E5%A4%96%E4%BC%A0%E6%84%9F%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="toc-number">1.4.6.</span> <span class="toc-text">应用1.对射式红外传感器计次</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A82-%E6%97%8B%E8%BD%AC%E7%BC%96%E7%A0%81%E5%99%A8%E8%AE%A1%E6%AC%A1"><span class="toc-number">1.4.7.</span> <span class="toc-text">应用2.旋转编码器计次</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#TIM%E5%AE%9A%E6%97%B6%E5%99%A8%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.</span> <span class="toc-text">TIM定时器中断</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#TIM%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.1.</span> <span class="toc-text">TIM简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">基本定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E7%94%A8%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.3.</span> <span class="toc-text">通用定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7%E5%AE%9A%E6%97%B6%E5%99%A8"><span class="toc-number">1.5.4.</span> <span class="toc-text">高级定时器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.5.</span> <span class="toc-text">定时中断基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E6%97%B6%E5%99%A8%E6%97%B6%E5%BA%8F"><span class="toc-number">1.5.6.</span> <span class="toc-text">计时器时序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%97%A0%E9%A2%84%E8%A3%85%E6%97%B6%E5%BA%8F"><span class="toc-number">1.5.6.1.</span> <span class="toc-text">计数器无预装时序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%A1%E6%95%B0%E5%99%A8%E6%9C%89%E9%A2%84%E8%A3%85%E6%97%B6%E5%BA%8F"><span class="toc-number">1.5.6.2.</span> <span class="toc-text">计数器有预装时序</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RCC%E6%97%B6%E9%92%9F%E6%A0%91"><span class="toc-number">1.5.7.</span> <span class="toc-text">RCC时钟树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A81-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%AE%9A%E6%97%B6%E4%B8%AD%E6%96%AD"><span class="toc-number">1.5.8.</span> <span class="toc-text">应用1.定时器定时中断</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A82-%E5%AE%9A%E6%97%B6%E5%99%A8%E5%A4%96%E9%83%A8%E6%97%B6%E9%92%9F"><span class="toc-number">1.5.9.</span> <span class="toc-text">应用2.定时器外部时钟</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83"><span class="toc-number">1.5.10.</span> <span class="toc-text">输出比较</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.10.1.</span> <span class="toc-text">输出比较简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PWM%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.10.2.</span> <span class="toc-text">PWM简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%87%BA%E6%AF%94%E8%BE%83%E9%80%9A%E9%81%93"><span class="toc-number">1.5.10.3.</span> <span class="toc-text">输出比较通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PWM%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.10.4.</span> <span class="toc-text">PWM基本结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#PWM%E5%8F%82%E6%95%B0%E8%AE%A1%E7%AE%97"><span class="toc-number">1.5.10.5.</span> <span class="toc-text">PWM参数计算</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%88%B5%E6%9C%BA%E7%AE%80%E4%BB%8B"><span class="toc-number">1.5.11.</span> <span class="toc-text">舵机简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA%E5%8F%8A%E9%A9%B1%E5%8A%A8"><span class="toc-number">1.5.12.</span> <span class="toc-text">直流电机及驱动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A83-PWM%E9%A9%B1%E5%8A%A8LED%E5%91%BC%E5%90%B8%E7%81%AF"><span class="toc-number">1.5.13.</span> <span class="toc-text">应用3.PWM驱动LED呼吸灯</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A84-PWM%E9%A9%B1%E5%8A%A8%E7%94%B5%E6%9C%BA"><span class="toc-number">1.5.14.</span> <span class="toc-text">应用4.PWM驱动电机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A85-PWM%E9%A9%B1%E5%8A%A8%E7%9B%B4%E6%B5%81%E7%94%B5%E6%9C%BA"><span class="toc-number">1.5.15.</span> <span class="toc-text">应用5.PWM驱动直流电机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7"><span class="toc-number">1.5.16.</span> <span class="toc-text">输入捕获</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A2%91%E7%8E%87%E6%B5%8B%E9%87%8F"><span class="toc-number">1.5.16.1.</span> <span class="toc-text">频率测量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E9%80%9A%E9%81%93"><span class="toc-number">1.5.16.2.</span> <span class="toc-text">输入捕获通道</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A86-%E8%BE%93%E5%85%A5%E6%8D%95%E8%8E%B7%E6%A8%A1%E5%BC%8F%E6%B5%8B%E9%A2%91%E7%8E%87"><span class="toc-number">1.5.17.</span> <span class="toc-text">应用6.输入捕获模式测频率</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A87-PWMI%E6%A8%A1%E5%BC%8F%E6%B5%8B%E5%8D%A0%E7%A9%BA%E6%AF%94"><span class="toc-number">1.5.18.</span> <span class="toc-text">应用7.PWMI模式测占空比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.5.19.</span> <span class="toc-text">编码器接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%AD%A3%E4%BA%A4%E7%BC%96%E7%A0%81%E5%99%A8"><span class="toc-number">1.5.19.1.</span> <span class="toc-text">正交编码器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A88-%E7%BC%96%E7%A0%81%E5%99%A8%E6%8E%A5%E5%8F%A3%E6%B5%8B%E9%80%9F"><span class="toc-number">1.5.20.</span> <span class="toc-text">应用8.编码器接口测速</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ADC-%E6%95%B0%E6%A8%A1%E8%BD%AC%E6%8D%A2%E5%99%A8"><span class="toc-number">1.6.</span> <span class="toc-text">ADC 数模转换器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%90%E6%AC%A1%E9%80%BC%E8%BF%91%E5%9E%8BADC"><span class="toc-number">1.6.0.1.</span> <span class="toc-text">逐次逼近型ADC</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ADC%E6%A1%86%E5%9B%BE"><span class="toc-number">1.6.0.2.</span> <span class="toc-text">ADC框图</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BE%93%E5%85%A5%E9%80%9A%E9%81%93"><span class="toc-number">1.6.0.3.</span> <span class="toc-text">输入通道</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.0.4.</span> <span class="toc-text">转换模式</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1%E8%BD%AC%E6%8D%A2%E9%9D%9E%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.0.4.1.</span> <span class="toc-text">单次转换非扫描模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E8%BD%AC%E6%8D%A2%E9%9D%9E%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.0.4.2.</span> <span class="toc-text">连续转换非扫描模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E6%AC%A1%E8%BD%AC%E6%8D%A2%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.0.4.3.</span> <span class="toc-text">单次转换扫描模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E8%BF%9E%E7%BB%AD%E8%BD%AC%E6%8D%A2%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.6.0.4.4.</span> <span class="toc-text">连续转换扫描模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%A7%A6%E5%8F%91%E6%8E%A7%E5%88%B6"><span class="toc-number">1.6.0.5.</span> <span class="toc-text">触发控制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%AF%B9%E9%BD%90"><span class="toc-number">1.6.0.6.</span> <span class="toc-text">数据对齐</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E6%8D%A2%E6%97%B6%E9%97%B4"><span class="toc-number">1.6.0.7.</span> <span class="toc-text">转换时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%A1%E5%87%86"><span class="toc-number">1.6.0.8.</span> <span class="toc-text">校准</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A1%AC%E4%BB%B6%E7%94%B5%E8%B7%AF"><span class="toc-number">1.6.0.9.</span> <span class="toc-text">硬件电路</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A81-AD%E5%8D%95%E9%80%9A%E9%81%93"><span class="toc-number">1.6.1.</span> <span class="toc-text">应用1.AD单通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BA%94%E7%94%A82-AD%E5%A4%9A%E9%80%9A%E9%81%93"><span class="toc-number">1.6.2.</span> <span class="toc-text">应用2.AD多通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#DMA"><span class="toc-number">1.7.</span> <span class="toc-text">DMA</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%98%E5%82%A8%E5%99%A8%E6%98%A0%E5%83%8F"><span class="toc-number">1.7.1.</span> <span class="toc-text">存储器映像</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84"><span class="toc-number">1.7.2.</span> <span class="toc-text">DMA基本结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DMA%E8%AF%B7%E6%B1%82"><span class="toc-number">1.7.3.</span> <span class="toc-text">DMA请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BD%AC%E8%BF%90-DMA"><span class="toc-number">1.7.4.</span> <span class="toc-text">数据转运+DMA</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ADC%E6%89%AB%E6%8F%8F%E6%A8%A1%E5%BC%8F-DMA"><span class="toc-number">1.7.5.</span> <span class="toc-text">ADC扫描模式+DMA</span></a></li></ol></li></ol></li></ol></div></div><footer><nobr><span class="icp-title">ICP</span><a class="icp-content" target="_blank" rel="noopener" href="https://beian.miit.gov.cn/">备案个屁</a></nobr><br><nobr>构建自 <a target="_blank" rel="noopener" href="http://hexo.io">Hexo</a></nobr><wbr><nobr> 使用主题 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus/hexo-theme-arknights">Arknights</a></nobr><wbr><nobr> 主题作者 <a target="_blank" rel="noopener" href="https://github.com/Yue-plus">Yue_plus</a></nobr></footer></aside></main><canvas id="canvas-dust"></canvas><script src="/js/search.js"></script><script src="/js/arknights.js"></script><script src="//unpkg.com/lightgallery@2.7.1/lightgallery.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/zoom/lg-zoom.min.js"></script><script src="//unpkg.com/lightgallery@2.7.1/plugins/thumbnail/lg-thumbnail.min.js"></script><script src="/lib/encrypt/hbe.js"></script><script src="/js/pjax.js"></script><script class="pjax-js">reset= () => {new Valine({
 el: '#valine'
 , appId: 'BHvvZvlz37DVYtbfOeshm87j-gzGzoHsz'
 , appKey: 'CEhVRTFF2tS30lPvOacrxzSK' , placeholder: '此条评论委托企鹅物流发送'
 , path: window.location.pathname
});gitalk = new Gitalk({
 clientID: '5e73d069c985fb062218',
 clientSecret: 'zjut096412',
 repo: 'zjuter.github.io',
 owner: 'zjuter',
 admin: ['zjuter'],
 distractionFreeMode: false,
 id: location.pathname
});
if (document.querySelector("#gitalk")) gitalk.render("gitalk");document.querySelector('.lg-container')?.remove()
lightGallery(document.getElementById('post-bg'), {
  plugins: [lgZoom,lgThumbnail],
  selector: '.item-img'})}</script><script>window.addEventListener("load",() => {pjax = new Pjax({
 cacheBust: false,
 selectors: ['title','article','#aside-block','.pjax-js','data-pjax'],
 switches: {'article': Pjax.switches.sideBySide},
 switchesOptions: {
   'article': {
     classNames: {
       remove: "pjax-out",
       add: "pjax-in"
     }
   }
 }
});
document.addEventListener("pjax:complete", reset);reset()})</script></body></html>