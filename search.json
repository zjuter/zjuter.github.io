[{"title":"Arduino学习日志","url":"/2023/11/22/arduino%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/","content":"Arduino学习日志前言这篇文章是我个人在Arduino学习上所做的笔记，arduino的学习是为了未来32单片机以及51单片机的学习作提前适应\n由于受限于图片上传我仅会在这篇笔记展示代码的内容，硬件部分我会尝试在一些其他的平台展示（也许会做一个微信公众号）\n叠甲：这篇文章可能存在一些错误，如果您发现了，请在评论区为我留言，我将很快改正\n部分省略由于arduino的一些语法是和C&#x2F;C++有相似之处，所以语法基础这篇笔记掠过不踢\n串口通讯串口通讯是传输数据的一种方式，所有arduino控制器都有至少一个串行端口（UART）。串口通讯主要由RX（receice接受）、TX（transport发送）、GND（ground接地）三个接口组成，控制器可以据此与其他单片机、传感器、计算机进行通讯\n个人计算机可以使用USB接口与arduino的引脚0（RX）和引脚1（TX）进行串口通讯\n优点：·发展时间长，技能成熟可靠     ·兼容性好、很多电子设备支持串口     ·使用方便，实现简单\n相关函数Serial.begin(speed)：初始化串口数据，打开串口通讯，并设置传输速率    · 参数 spped：波特率,设定的波特率需要和IDE上的波特率相同，否则会出错\nSerial.available()：用于检测控制器是否接到数据。返回值为等待读取的数据字节\nSerial.print(val,format)：串口输函数，发送ASCII码型数据，被发送的数据可以使任何格式    ·参数 format：可为BIN（二进制）DEC（十进制）HEX（十六进制）OCT（八进制）例：Serial.print(“Passenger”)-&gt;输出Passenger    Serial.print(23,BIN)-&gt;输出：0001 1001\nSerial.println(val,format)：在Serial.print()的基础上换个行\nSerial.write(val)：串口输出函数，发送单个字节或字符串    · val&#x3D;65时输出A（val为数字时会根据ASCII码发送字符）\nSerial.read()：串口读取函数，每次读取一个字节    · 没收到时返回-1    · 收到时返回值为接收到的数据流中的一个字符\nSerial.parselnt()：串口数据解析函数，用来读取所接收到的数据中的整数，从数据中第一个数字读取到连续的最后一个数字。可以重复使用。\nparselnt()读取数据时，会忽略字母并提取数字，每次读取后，数字之前的数据和数字本身会从缓存区删除，其他数据保持不变\n\nSerial.parseFloat()：串口数据解析函数，用来读取数据中的小数。 \n","categories":["note","article"],"tags":["SCM","code","hardware","note"]},{"title":"Linux学习日志","url":"/2023/11/10/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/","content":"前言Linux是一个免费、开源、可靠、安全、稳定、多平台的操作系统内核，这篇文章将随着我的学习进程不断更新用于作为笔记。\n\n一些小知识（快捷键· Ctrl+L：清空终端\n小知识（没啥用也许· 使用ls查看目录下内容时，深色的为文件夹，浅色的为文件；使用ls -l时，最前面为d（directory）的是文件夹，为-的是文件\n· 使用su -root然后输入用户密码，获得最大权限（切换root用户）\n通配符“*”通配符“*”，用来做模糊匹配\n通配符，即匹配任意内容（包括空），例：· test* 表示匹配任何以test开头的内容· *test 表示匹配任何以test结尾的内容· test 表示任何包含test的内容\n管道符“|”管道符“|”，把管道符左侧输出的结果作为右边的输入\n左侧可以是任何有输出的命令，右侧只能是有可作为内容输入端口参数的命令\n例：cat test.txt | grep pessenger\n原本上面grep命令应该为grep pessenger 筛选内容，但是grep命令的筛选内容参数可作为内容输入端口，所以在使用管道符时可以省略，将管道符之前内容作为参数输入\n注：管道符可以嵌套使用，比如：cat test.txt | grep pessenger | grep D\n即：cat test.txt的输出（输出内容1）作为参数进行grep pessenger 输出内容1,得到输出内容2，在输入输出内容2进行命令grep D 输出内容2得出最后我们看到的输出内容\n反引号“&#96;”（又称飘号）用反引号包围的命令不会被作为参数，而是将命令输出的内容作为参数输入\n例：echo pwd输出结果为pwd，而echo &quot;pwd&quot;输出内容是当前目录位置\n重定向符“&gt;”和“&gt;&gt;”&gt;将左侧命令的结果覆盖写入到符号右侧指定的文件中\n例：eacho &quot;Hello Linux&quot; &gt; test.txt-&gt;test.txt内容为“Hello Linux”\n&gt;&gt;将左侧命令的结果追加写入到符号右侧的指定文件中\n例：echo &quot;Hello Linux&quot; &gt;&gt; test.txt-&gt;test.txt最后多一行“Hello Linux”\n\n命令行操作命令结构Linux的命令结构大致为：[commend] [-option] [parameter]\n其中：· commend 指的是命令本身，比如：ls、cd等· -option 指的是命令的一些选项，可以通过这个来选择控制命令的行为细节· parameter 指的是命令的参数，用于命令的指向目标\n注：[-0ption]和[parameter]是可选的而不是必须的\n命令表lsls命令的作用是列出目录下的内容，细节如下：\nls [-a -l -h] [Linux路径]\n前置小知识：·Home目录：每一个用户在Linux系统的专属目录默认在:/home/用户名·当前工作目录： Linux在执行命令的时候往往需要一个工作目录来打开命令程序（终端），默认设置工作目录在用户的home目录\n选项-a选项-a选项 表示“all”，即列出所有文件（包括隐藏的）\n显示的文件里面开头是 “.” 的就是隐藏的文件\n-l选择-l选项 以纵向的形式展示内容，并展示更多内容\n-h选择-h选项 可以更好的展示内存，但是只能和 -l 一起使用\n组合使用可以选择分别使用选项，比如 ls -l -a -h，也可以组合使用，比如ls -lah两者等效并且前后顺序没有影响。\ncdcd命令就是更改工作目录，语法是：\ncd [Linux路径]\n注：cd没有选项只有路径\ncd直接执行不写参数就是回到根目录\n绝对路径和相对路劲绝对路径即从根目录为起点，以 &#x2F; 开头\n相对路径从当前文件夹开始，不需要&#x2F;开头\n特殊路径符·**.** 表示当前目录     例：cd ./desktop就是切换到当前目录下的desktop目录内\n·**..**表示上一级目录     例：cd ../..  切换到上二级目录\n·**~**表示HOME目录     例：cd ~/desktop切换到根目录的desktop目录\npwd（Print Work Directory） 用于查看当前所在的工作目录\npwd没有选项，并且没有参数，直接执行即可\nmkdirmkdir命令（来自“Make Directory”）可以创建新的目录（文件夹）\n语法：mkdir [-p] Linux路径\n注：·参数必填，相对路径以及绝对路径均可    · -p选项可选，表示创建不存在父目录，适用于连续多级的目录    · 创建文件夹需要修改权限，在home目录内可以直接创建，在home目录之外需要权限\n例：mkdir pessenger，mkdir ./pessenger等\n选项-p-p 可以没有父目录的目录，用于创建连续目录\n例： mkdir -p /pessenger/hello/world\ntouch用来创建文件，语法：touch Linux路径 \n注：touch命令没有选项，但是参数必填\n例：touch text.txt \ncat查看文件内容,语法：cat Linux路径\n注：cat命令也没有路径且参数必填\n例：cat test.txt\nmore也可以查看文件内容，语法：more Linux路径\n注：more也没有选项且参数必填\n文件内操作·space键：下一页·ENTER键：：下一行·B键上一页·Q键退出\nmore与cat的区别·cat直接将内容全部展示出来·more支持翻页，若文件内容过多，可以一页页展示\n所以more较cat更适合大文件的查看\ncp复制文件&#x2F;文件夹（copy），语法：cp [-r] 参数1 参数2\n参数1：Linux路径，表示被复制的文件或者文件夹\n参数2：Linux路径，表示要复制去的文件或者文件夹\n选项-r用于复制文件夹用，表示递归\nmv用于移动文件夹&#x2F;文件（move），语法： mv 参数1 参数2\n参数1：Linux路径，表示被移动的文件或者文件夹\n参数2：Linux路径，表示要移动到的地方（若目标不存在则改名确保存在）\n例：若目标存在，比如：mv text.txt /desktop，text.txt就被移动到了desktop目录下    若目录不存在，比如：mv text.txt text2.txt(text1.txt不存在这个目录下)，text.txt就被重命名成了text1.txt\nrm用于删除文件&#x2F;文件夹（来自remove），语法：rm [-r -f] 参数1 参数2 …… 参数n\n参数为要删除的文件或者文件夹路径\n谨慎使用rm命令，尤其root用户时rm -rf/,rm -rf/*等效于电脑格式化（删光光）\n选项-r同cp命令，用于删除文件夹\n-f-f表示force，强制删除（不会弹出确认信息）\n注： ·普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示 ·一般用户不使用-f选项\nwhich我们前面学的Linux命令，本体就是一个个二进制的可执行程序（相当于windows的exe文件）\nwhich命令查看一系列命令的程序文件存放在哪里，语法：which Linux命令\n例：which cd\nfind搜索指定的文件，语法：find 起始路径 -name &quot;被查找文件名&quot;（以文件名查找）                    find 起始路径 -size +/-n[kMG](以 大小查找文件)\n+、-表示大于小于；n表示大小数字；[]内为大小单位（k为kb，M为MB，G为GB）\n注：允许使用通配符\n例：find /desktop &quot;-name&quot; *text，find -size +1k\ngrep从文件中，通过关键字过滤文件行，语法：grep [-n] 关键词 文件路径\n选项-n（可选）：表示在结果中显示匹配行的行号\n参数·关键字（必填）：表示过滤的关键字，带有space或者其他特殊符号时建议用””把关键字包起来（建议一直使用“”包围）\n参数·文件路径（必填）：表示要过滤的文件的路径，可作为内容输入端口\n例：grep &quot;pessenger&quot; text.txt\nwc文件内容统计，包括行数，单词数量等，语法：wc [-c -m -l -w] 文件路径\n参数文件路径（必填），被统计路径，可作为内容输入端口\n例：wc -c test.txt\n选项-c统计bytes数量\n-m统计字符数量\n-l统计字数\n-w统计单词数量\necho在命令行内输出指定内容，语法：echo 输出内容\n注：无选项，参数较复杂时可用“”包围\n例：echo &quot;Hello Linux&quot;\ntail可以查看文件尾部内容，跟踪文件最新更改，语法：tail [-f -num] Linux路径\n·参数Linux路径：表示被追踪的文件路径\n例：tail test.txt\n选项-f表示持续追踪，例：tail -f test.txt（运行之后不会主动停止并一直更新用户在对参数对象操作之后的结果）\n注：CTRL+C强制停止运行\n-num表示查看尾部多少行，num为具体数字，不填默认10行，例：tail -5 test.txt\n\nVim&#x2F;Vi 编辑器Vi&#x2F;Vim是Linux最经典的文本编辑器（Vim是Vi的加强版）\n工作模式命令模式此模式下，所敲的按键编辑器都会理解为命令，用命令驱动不同功能。\n此模式下不能自由进行文本编辑\n输入模式编辑模式、插入模式\n此模式下，可以自由地对文件内容进行编辑\n底线命令模式以”:”开始，通常用于文件的保存退出\n打开编辑器时默认是命令模式\n*注：你可以从命令模式进入输入模式和底线命令模式，但是不可以从输入模式进入底线模式或相反，只能从两者回到命令模式再进入另一方\n用打开vi&#x2F;vim打开并编辑文件\nvi/vim 文件路径\n如果存在文件就打开，如果不存在就新建一个文件，再打开进行编辑\n命令模式的命令（缩写）表\n\n\n模式\n快捷键\n描述\n\n\n\n命令模式\ni\n在当前光标位置进入输入模式\n\n\n命令模式\na\n在当前光标位置之后进入输入模式\n\n\n命令模式\nI\n在当前行的开头进入输入模式\n\n\n命令模式\nA\n在当前行的结尾进入输入模式\n\n\n命令模式\no\n在当前光标的上一行进入输入模式\n\n\n命令模式\nO\n在当前光标的下一行进入输入模式\n\n\n输入模式\nesc\n任何情况下输入esc都能回到命令模式\n\n\n命令模式\n↑、k\n向上移动光标\n\n\n命令模式\n↓、j\n向下移动光标\n\n\n命令模式\n←，h\n向左移动光标\n\n\n命令模式\n→、l\n向右移动光标\n\n\n命令模式\n0\n移动光标到当前行的开头\n\n\n命令模式\n$\n移动光标到当前行的结尾\n\n\n命令模式\npageup（PgUp）\n向上翻页\n\n\n命令模式\npagedown（PgDn）\n向下翻页\n\n\n命令模式\n&#x2F;\n进入搜索模式\n\n\n命令模式\nn\n向下继续搜索\n\n\n命令模式\nN\n向上继续搜索\n\n\n命令模式\ndd\n删除光标所在行的内容\n\n\n命令模式\nndd\nn是数字，表示删除当前光标向下n行\n\n\n命令模式\nyy\n复制当前行\n\n\n命令模式\nnyy\nn位为数字，表示复制当前光标向下n行\n\n\n命令模式\np\n黏贴复制的内容\n\n\n命令模式\nu\n撤销修改\n\n\n命令模式\nCTRL+r\n反向撤销修改\n\n\n命令模式\ngg\n回到首行\n\n\n命令模式\nG\n跳到行尾\n\n\n命令模式\ndG\n从当前行开始删除下面所有内容\n\n\n命令模式\ndgg\n从当前行开始删除上面所有内容\n\n\n命令模式\ndS\n从当前光标开始删除到本行结尾\n\n\n命令模式\ndG\n从当前光标开始删除到本行开头\n\n\n命令模式\n:\n进入底线命令模式\n\n\n底线命令模式\n:wq\n保存并退出\n\n\n底线命令模式\n:q\n仅退出\n\n\n底线命令模式\n:q!\n强制退出\n\n\n底线命令模式\n:w\n仅保存\n\n\n底线命令模式\n:set nu\n显示行号\n\n\n底线命令模式\n:set paste\n设置黏贴模式（用于从外部复制内容，防止格式错乱）\n\n\n\nroot及相关root用户，即超级用户，是拥有最大权限的账户\nroot用户拥有一般用户没有的权限，例如：在根目录创建文件夹等\n普通用户的权限一般在HOME目录内是不受限的，一旦出了HOME目录，一般用户在大部分地方只有只读和执行权限，无修改权限\n切换用户我们可用使用su命令来切换用户（switch user）\n语法：su [-] [用户名]\n注：·“-”符号是可选的，表示是否加载环境变量，建议带上。·参数：用户名，表示要切换的用户，可省略，省略表示切换到root·切换用户后可用exit命令退回到上一个用户，也可以使用快捷键CTRL+D\n·普通用户切换到其他用户需要输入密码·root用户切换到其他用户不需要密码\nsudo命令长期使用root用户可能会对系统产生损坏，所以可以使用sudo来为普通命令授权，临时以root身份执行\n语法：sudo 其他命令\n在其他命令前带上sudo即可为这一条命令临时赋予root授权\n注：不是所有用户都有权利使用sudo，我们需要为普通用户配置sudo认证\n为普通用户配置sudo认证1.切换到root用户，执行visudo命令，会通过vi打开：&#x2F;etc&#x2F;sudoers\n2.在文件最后添加：用户名 ALL=(ALL)         NOPASSSWD:ALL其中：NOPASSSWD：ALL表示使用sudo命令无需输入密码\n3.使用wq保存\n4.换回普通用户即可使用\n用户以及用户组在Linux中可以：· 配置多个用户· 配置多个用户组· 用户可以加入到多个用户组中\nlinux系统中关于权限的管控级别有两个：\n\n针对用户的权限控制\n针对用户组的权限控制\n\n用户组及用户管理命令用户组以及用户相关命令只有root用户才可以执行\n用户组相关命令创建用户组：groupadd 用户组名称\n删除用户组：groupdel 用户组名称\n用户相关命令创建用户：useradd [-g 用户组 -d home目录] 用户名    ·选项-g：指定用户组，若不指定则创建一个与用户同名的用户组然后把这个用户塞进去（-g指定的组需要已存在，如果已存在同名的用户组，必须使用-g）    ·选项-d：指定用户的HOME目录，不指定就默认在：&#x2F;home&#x2F;用户名\n删除用户：userdel [-r] 用户名    ·选项-r：删除用户的home目录，如果不带则不删除\n产看用户所属组：id [用户名]    ·参数用户名：被查看的用户，不带就看自己\n修改用户所属组：user mod -aG 用户组 用户名将指定用户移动到指定用户组\ngetent命令：查看当前系统有哪些用户和用户组语法1：getent password（password是你的密码）\n每条结果包括七份信息，分别是：    用户名：密码（x）：用户ID：组ID：描述信息（没啥软用）：HOME目录：执行终端（默认bash）\n语法2：getent group\n每条结果包含三份信息，分别是：    组名称：组认证（显示为x）：组ID\n查看权限控制认知权限信息当你使用ls -l命令查看内容时，会显示权限细节。\n以一条结果为例：    drwxr-xr-x. 3 pessenger passenger 4 11月   4 5:14 Desktop        1       2     3其中：第一部分表示文件、文件夹的权限控制信息      第二部分表示文件、文件夹所属用户      第三部分：表示文件、文件夹所属用户组\n第一部分用于展示文件、文件夹的具体权限，可以分为十个槽位：-/d/l r/- w/- x/- r/- w/- x/- r/- w/- x/-\n· 第一块：-表示文件         d表示文件夹         l表示软链接· 第2-4块表示所属用户权限\n· 第5-7块表示所属用户组的权限\n· 第8-10块表示其他用户权限\nr 表示读权限w 表示写权限x 表示执行权限\n对于文件、文件夹的不同，rwx的含义有细微差别：· r 针对文件可以查看文件内容    针对文件夹可以查看文件夹内容（如ls命令）· w 针对文件可以修改文件内容    针对文件夹可以在文件夹内创建、删除、修改等操作· x 针对文件可表示将文件作为程序执行    针对文件夹可表示更改工作目录到这个文件夹，即cd进入\nchmod命令chomd命令用于修改文件、文件夹的权限信息\n注：只有文件、文件夹的所属用户或者root用户才可修改\n语法：chmod [-R] 权限 文件/文件夹· -R 对文件夹内所有内容应用同样操作\n例：chmod u=rwx,g=rx,o=x hello.txt将文件权限修改为rwxr-x–x    ·其中：u表示user所属用户权限，g表示group组权限，o表示other其他权限\nchmod语法也可以简化，例如：chmod 761 hello.txt\n这句命令相当于chmod u=rwx,g=rw,o=x hello.txt\n例句中的7、6、1分别将u、g、o的权限修改\n我们可以把三位上的每个数字分别理解为一个三位二进制数\n比如7就相当于111即rwx三个权限都有；6相当于110即拥有rw两个权限\n用这种表达可以更加快速便捷地执行chmod命令\nchown命令chown命令可以修改文件文件夹的所属用户和所属用户组\n注：普通用户无法修改所属为其他用户或族，此命令仅适用于root用户执行\n语法：chown [-R] [用户] [:] [用户组] [文件或者文件夹]    · 选项-R：同chmod    · 选项用户：修改所属用户    · 选项用户组：修改所属用户组    · “:”：用于分隔用户和用户组\n例：chown root hello.txt 将hello.txt所属用户组修改为root    chown root:pessenger hello.txt将hello.txt所属用户改为root，用户组改为pessenger\n实战训练用于练习，锻炼熟练度。本环节不会有较多的文字，只是作为实战过程中部分须注意点的记录。\n在Linux上部署各类软件","categories":["note","article"],"tags":["code","note"]},{"title":"生日蛋糕绘图","url":"/2023/10/25/%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95%E7%BB%98%E5%9B%BE/","content":"利用python画一个生日蛋糕！python画图主要是运用了turtle、math和random三个模块\nturtle用于画图，math用于数学计算而random用于最后乱七八糟的彩色点点的布局（我放不好，自己做的太丑了）\n代码是从我之前写的一个改过来的（我忘掉之前那个是从哪里抄来的了）\n具体代码如下：\n\nimport turtle as timport math as mimport random as rdef drawX(a, i):    angle = m.radians(i)    return a * m.cos(angle)def drawY(b, i):    angle = m.radians(i)    return b * m.sin(angle)# 设置背景颜色，窗口位置以及大小t.bgcolor(&quot;#d3dae8&quot;)t.setup(1000, 800)t.penup()t.goto(150, 0)t.pendown()# 1t.pencolor(&quot;white&quot;)t.begin_fill()for i in range(360):    x = drawX(150, i)    y = drawY(60, i)    t.goto(x, y)t.fillcolor(&quot;#fef5f7&quot;)t.end_fill()# 2t.begin_fill()for i in range(180):    x = drawX(150, -i)    y = drawY(70, -i)    t.goto(x, y)for i in range(180, 360):    x = drawX(150, i)    y = drawY(60, i)    t.goto(x, y)t.fillcolor(&quot;#f2d7dd&quot;)t.end_fill()# 3t.pu()t.goto(120, 0)t.pd()t.begin_fill()for i in range(360):    x = drawX(120, i)    y = drawY(48, i)    t.goto(x, y)t.fillcolor(&quot;#cbd9f9&quot;)t.end_fill()# 4t.begin_fill()t.pencolor(&quot;#fee48c&quot;)for i in range(540):    x = drawX(120, i)    y = drawY(48, i) + 70    t.goto(x, y)t.goto(-120, 0)t.fillcolor(&quot;#cbd9f9&quot;)t.end_fill()# 5t.pu()t.goto(120, 70)t.pd()t.pencolor(&quot;#fff0f3&quot;)t.begin_fill()for i in range(360):    x = drawX(120, i)    y = drawY(48, i) + 70    t.goto(x, y)t.fillcolor(&quot;#fff0f3&quot;)t.end_fill()# 6t.pu()t.goto(110, 70)t.pd()t.pencolor(&quot;#fff9fb&quot;)t.begin_fill()for i in range(360):    x = drawX(110, i)    y = drawY(44, i) + 70    t.goto(x, y)t.fillcolor(&quot;#fff9fb&quot;)t.end_fill()# 7t.pu()t.goto(120, 0)t.pd()t.begin_fill()t.pencolor(&quot;#ffa79d&quot;)for i in range(180):    x = drawX(120, -i)    y = drawY(48, -i) + 10    t.goto(x, y)t.goto(-120, 0)for i in range(180, 360):    x = drawX(120, i)    y = drawY(48, i)    t.goto(x, y)t.fillcolor(&quot;#ffa79d&quot;)t.end_fill()# 8t.pu()t.goto(120, 70)t.pd()t.begin_fill()t.pensize(4)t.pencolor(&quot;#fff0f3&quot;)for i in range(1800):    x = drawX(120, 0.1 * i)    y = drawY(-18, i) + 10    t.goto(x, y)t.goto(-120, 70)t.pensize(1)for i in range(180, 360):    x = drawX(120, i)    y = drawY(48, i) + 70    t.goto(x, y)t.fillcolor(&quot;#fff0f3&quot;)t.end_fill()# 9t.pu()t.goto(80, 70)t.pd()t.begin_fill()t.pencolor(&quot;#6f3732&quot;)t.goto(80, 120)for i in range(180):    x = drawX(80, i)    y = drawY(32, i) + 120    t.goto(x, y)t.goto(-80, 70)for i in range(180, 360):    x = drawX(80, i)    y = drawY(32, i) + 70    t.goto(x, y)t.fillcolor(&quot;#6f3732&quot;)t.end_fill()# 10t.pu()t.goto(80, 120)t.pd()t.pencolor(&quot;#ffaaa0&quot;)t.begin_fill()for i in range(360):    x = drawX(80, i)    y = drawY(32, i) + 120    t.goto(x, y)t.fillcolor(&quot;#ffaaa0&quot;)t.end_fill()# 11t.pu()t.goto(70, 120)t.pd()t.pencolor(&quot;#ffc3be&quot;)t.begin_fill()for i in range(360):    x = drawX(70, i)    y = drawY(28, i) + 120    t.goto(x, y)t.fillcolor(&quot;#ffc3be&quot;)t.end_fill()# 12t.pu()t.goto(80, 120)t.pd()t.begin_fill()t.pensize(3)t.pencolor(&quot;#ffaaa0&quot;)for i in range(1800):    x = drawX(80, 0.1 * i)    y = drawY(-12, i) + 80    t.goto(x, y)t.goto(-80, 120)t.pensize(1)for i in range(180, 360):    x = drawX(80, i)    y = drawY(32, i) + 120    t.goto(x, y)t.fillcolor(&quot;#ffaaa0&quot;)t.end_fill()# 13t.pu()t.goto(64, 120)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 60    y = drawY(1, i) + 120    t.goto(x, y)t.goto(64, 170)for i in range(540):    x = drawX(4, i) + 60    y = drawY(1, i) + 170    t.goto(x, y)t.goto(56, 120)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(64, 120 + 10 * i)    t.pu()    t.goto(56, 120 + 10 * i)    t.pd()t.pu()t.goto(60, 170)t.pd()t.goto(60, 180)t.pensize(1)#t.pu()t.goto(64, 190)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 60    y = drawY(10, i) + 190    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 14t.pu()t.goto(-56, 120)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 60    y = drawY(1, i) + 120    t.goto(x, y)t.goto(-56, 170)for i in range(540):    x = drawX(4, i) - 60    y = drawY(1, i) + 170    t.goto(x, y)t.goto(-64, 120)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(-56, 120 + 10 * i)    t.pu()    t.goto(-64, 120 + 10 * i)    t.pd()t.pu()t.goto(-60, 170)t.pd()t.goto(-60, 180)t.pensize(1)#t.pu()t.goto(-56, 190)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 60    y = drawY(10, i) + 190    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 15t.pu()t.goto(0, 130)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i)    y = drawY(1, i) + 130    t.goto(x, y)t.goto(4, 180)for i in range(540):    x = drawX(4, i)    y = drawY(1, i) + 180    t.goto(x, y)t.goto(-4, 130)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(4, 130 + 10 * i)    t.pu()    t.goto(-4, 130 + 10 * i)    t.pd()t.pu()t.goto(0, 180)t.pd()t.goto(0, 190)t.pensize(1)#t.pu()t.goto(4, 200)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i)    y = drawY(10, i) + 200    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 16t.pu()t.goto(30, 110)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 30    y = drawY(1, i) + 110    t.goto(x, y)t.goto(34, 160)for i in range(540):    x = drawX(4, i) + 30    y = drawY(1, i) + 160    t.goto(x, y)t.goto(26, 110)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(34, 110 + 10 * i)    t.pu()    t.goto(26, 110 + 10 * i)    t.pd()t.pu()t.goto(30, 160)t.pd()t.goto(30, 170)t.pensize(1)#t.pu()t.goto(34, 180)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 30    y = drawY(10, i) + 180    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 17t.pu()t.goto(-30, 110)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 30    y = drawY(1, i) + 110    t.goto(x, y)t.goto(-26, 160)for i in range(540):    x = drawX(4, i) - 30    y = drawY(1, i) + 160    t.goto(x, y)t.goto(-34, 110)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(-26, 110 + 10 * i)    t.pu()    t.goto(-34, 110 + 10 * i)    t.pd()t.pu()t.goto(-30, 160)t.pd()t.goto(-30, 170)t.pensize(1)#t.pu()t.goto(-26, 180)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 30    y = drawY(10, i) + 180    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()###随机color = [&quot;#e28cb9&quot;, &quot;#805a8c&quot;, &quot;#eaa989&quot;, &quot;#6e90b7&quot;, &quot;#b8b68f&quot;, &quot;#e174b5&quot;, &quot;#cf737c&quot;, &quot;#7c8782&quot;]for i in range(80):    t.pu()    x = r.randint(-120, 120)    y = r.randint(-25, 30)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(40):    t.pu()    x = r.randint(-90, 90)    y = r.randint(-35, 10)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(40):    t.pu()    x = r.randint(-80, 80)    y = r.randint(60, 90)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(30):    t.pu()    x = r.randint(-50, 50)    y = r.randint(45, 70)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(50):    t.pu()    x = r.randint(-500, 500)    y = r.randint(120, 300)    t.goto(x, y)    t.pd()    t.dot(r.randint(3, 5), color[r.randint(0, 7)])t.seth(90)t.pu()t.goto(0, 0)t.fd(210)t.left(90)t.fd(170)t.pd()t.write(&quot;Happy Birthday&quot;, font=(&quot;Curlz MT&quot;, 50))t.done()\n\n\n总之就是找点作图，难度不是很大，就是费神（这个艾斯比点怎么这么难找啊！）\n四百多行代码，祝你们看的愉快！  \n","categories":["article"],"tags":["code"]},{"title":"目猫老师我是你粉丝啊！","url":"/2023/10/27/%E7%9B%AE%E7%8C%AB%E8%80%81%E5%B8%88%E6%88%91%E6%98%AF%E4%BD%A0%E7%B2%89%E4%B8%9D%E5%95%8A%EF%BC%81/","content":"目猫老师我是你粉丝啊！！！输入 %eyecat输出 目猫：还是南通的氛围适合我\n","categories":["notice"],"tags":["life"]},{"title":"第一篇文章","url":"/2023/10/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"Hello！这是我发布的第一篇博客！\n欢迎你们将这个网站加入收藏夹\n我将不时更新一些我所接触的内容\n或者一些生活上的东西\n\n以下是一些小小的测试，只是做着玩的。这是我的GitHub主页，可以来看看，我会不时丢一些奇怪的内容上去：zjuter\n还有\n↓这是我老婆↓（ 是猫猫不是猪！！！）\n","categories":["notice"],"tags":["life"]},{"title":"使用hexo搭建个人博客","url":"/2023/10/28/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"0基础使用hexo搭建个人博客先叠个甲：我是个菜鸡，如果有无请各位大佬提出助我更正！这个教程主要是提供一个大致的步骤。hexo是一个简洁高效的博客框架，利用hexo将服务器布局在github上可以做到零成本的个人博客搭建\n以下是大体的步骤\n1.前期准备\n2.hexo本地部署与上传\n3.个性化\n· 由于我个人是Windows系统，下列的操作我将以Windows系统为例，mac✌的操作步骤也是大致相同的，可以简单的代替一下部分语句进行操作。\n1.前期准备首先我们需要创建一个GitHub账户国内也有一些可以代替的网站比如Gitee等，但是没几个可以和GitHub比的，所以原则上我们最推荐GitHub\nGithub官网\n部分用户在打开GitHub时会有一些困难，可以耐心等待（或者开个魔法，也许有帮助？）\n具体步骤可以看这里GitHub注册\n然后我们就需要安装git这是下载的地址 git，你可以选择自己需要的版本下载。\n我也丢一个教程在这里：安装git（绝对不是因为我懒）\n安装完之后，任意页面右键出现git相关的选择项（主要是 git brash 就行了）\n完成以上步骤之后我们需要配置ssh老样子，丢个别人的教程 ssh配置 （就是懒行吧）\n之后就是安装node这是官网：ndoe.js\n注意：一定要选左边的！\n左边的是稳定版本，更加可靠，右边的是尝鲜版本，不是很稳定！\n下载完之后无脑继续就行了\n完成安装之后右键打开poweshell或者cmd（后面我就检测打开终端了）输入npm，看到版本号就说明安装成功了\n由于node是默认安装在C盘下面的，如果你对自己的C盘比较不自信，可以给node搬个家（我比较建议搬个家）\n你可以在其他盘想要的地方建一个文件夹（一定要英文名称，建议直接nodejs）\n然后在里面建node_global和node_cache两个文件夹\n打开终端，输入npm config set prefix &quot;nodejs文件位置\\node_global&quot;\n再输入node list -g查看是否更改成功（显示empty是正常的）\n同样的，我们再更改以下node_cache的位置npm config set cache &quot;nodejs的位置\\node_cache&quot;\n输入npm install express -g检测一下（安装报错就用管理员身份重新运行一下\n再输入npm list -g，这次不是empty说明成功了\n然后就是配置环境了！\n计算机右键属性-&gt;高级系统设置-&gt;path-&gt;编辑\n把原来的C:\\Users\\用户名\\AppData\\Roaming\\npm改为新的地址（node_global的位置）\n再新建系统变量NODE_PATH,变量值是node_golbal里面node_modules 的位置\n确定之后就配置完成了\n配置pnpm虽然node的npm已经足够大部分的使用了，但是他有一个致命的缺点：太慢了！\n这个时候我们就需要pnpm了！\npnpm适用范围极光，而且巨快！！，安装也相当简单\n打开终端，输入npm install -g pnpm或者npm install -g @pnpm/exe就好了\n安装完之后，我们还要配置一下镜像，一般来说用的是淘宝的镜像\n终端输入pnpm get registry,pnpm set registry https://registry.npm.taobao.org\n你也可以修改安装包的位置（其实没啥必要我就不展开了）\n然后你就可以愉快的使用pnpm了，就是这么简单（pnpm yyds！）\n2.hexo框架搭建完成前置点之后我们终于可以开始进入搭建环节了！\n先让我们检查一下\n终端输入node -v,pnpm -v和git --version\n有版本号就说明你已经准备好了\n首先链接GitHub设置用户名和邮箱git config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot;\n创建SSH密钥：输入ssh-keygen -t rsa -C &quot;GitHub邮箱&quot;然后一路回车\n进入用户下的.ssh目录（要开显示隐藏文件），用记事本打开id_rsa.pub并复制里面内容\n登录GitHub，进入setting，选择边栏的SSH and GPG keys，点击New SSH key\ntitle随便取，黏贴复制的内容，点Add SSH key完成添加\n然后就要验证链接了\n打开右键打开git brash，输入ssh -T git@github.com,出现“Are you sure……”,输入yes回车确定\n显示“hi ***!……”就成功了\n然后创建GitHub Page仓库GitHub主页右上角加号 -&gt; New repository\n·仓库名输入 用户名.github.io（必须是这个格式）\n·勾选“Initialize this repository with a README”\n其他随便\n最后点 Create repository \n开始正式搭建先在自己喜欢的位置创建一个文件夹（名字要是英文，建议直接blog，我就称这个文件夹为blog了）\n在blog里右键打开终端，输入pnpm install -g hexo-cli一键安装博客\n这个时候就可直观体会pnpm和npm的区别了，npm半天才能安装完，而pnpm只需要短短几秒\n下一步初始化并安装组件\n输入：hexo init,npm install就完成了\n是不是非常迅速？✌\n现在让我们启动一下试试\n输入hexo g完成本地部署\n再输入hexo s启动服务器\n他会跳出一个本地钉钉网址，按住CTRL点击就可以打开\n如果正常的打开了一个网址，恭喜你！你已经成功搭建了一个个人博客！（虽然只是在本地）\n下一步就是把你的博客部署到GitHub上了！\n按CTRL加C退出hexo，让我们先安装点插件\n首先，安装hexo-deployer-git:pnpm install hexo-deployer-git --save\n然后打开blog里面_config.yml文件的deployment部分，改成这样：\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master\n\n完成之后输入hexo d将网站上传部署到GitHub上\n在网页输入https://用户名.github.io就可以上你的个人博客了~\n在个人博客上上传自己的文章创建文章的快捷输入方式是hexo n &quot;文章名称&quot;\n创建之后就可以在blog里面blog\\source_posts位置找到新建的文章（结尾是.md）\n用vscode打开这个文件就可以编辑了！\n·注：md文件不是普通的txt或doc文件，他的编写也有些简单的语法，即MarkDown语法，具体怎么用可以看官方的文档MarkDown\n编辑完成并保存之后在blog里打开终端，输入hexo g,hexo d，一段时间之后你的网站里就会出现你的新文章了\n·注：文章更新需要一段时间，一时半会儿没别太急哈\n个人博客主页个性化首先，你要找一个喜欢的个性化页面\n这里我个人比较建议hexo自己给的个性化库hexo个性化库\n去里面找一个自己喜欢的模板，打开其对应的GitHub库，跟着操作一步步走就行了👍\n各个模板的操作可能不一样，我就不细说了，剩下就交给你自己慢慢探索了\n","categories":["article"],"tags":["code"]},{"title":"没钱力","url":"/2023/11/14/%E6%B2%A1%E9%92%B1%E5%8A%9B/","content":"震惊！生活费即将见底！我超为什么十一月才过了一半不到我的生活费就只剩一点点了！\n双十一甚至只买了两个东西（虽然每个都三百多……）\n但是真的要吃不起饭了！\n与我相依为命的只剩下没吃完的两箱泡面（哭\n\n最后的希望就是淘宝和拼多多（第一次不叫他拼夕夕woc）签到送的一两分钱了！\n老板们快扫扫下面的码爆爆金币（呜呜呜~\n\n（其实就是写个博客吐槽一下，日子还能过只是艰苦了亿点点……\n","categories":["notice"],"tags":["life"]},{"title":"电路学习笔记","url":"/2023/11/23/%E7%94%B5%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"电路学习笔记前言一切为了机器人比赛！总之就是没有规则的乱记笔记，能看就行\n第一章1.3电功率和能量u、i的参考方向为关联参考方向的时候：\n计算元件吸收功率，·若p&gt;0，则说明该部分电路实际为吸收电功率（消耗能量），若p&lt;0，实际为发出电功率\n计算原件发出功率，·若结果p&gt;0，则说明此部分电路实际为发出电功率（提供能量），若p&lt;0，实际为吸收电功率\nu、i的参考方向为非关联参考方向的时候：\n计算原件发出的功率：·若结果p&gt;0。则说明该电路实际为发出电功率（提供能量），若p&lt;0，史记为吸收电功率。\n计算元件吸收功率，·若p&gt;0，则说明该部分电路实际为吸收电功率（消耗能量），若p&lt;0，实际为发出电功率\n电能：从t0到t的时间内，元件吸收的电能W为电力将单位时间正电荷由A点移动到B点时所作的功:\n电功率和电能单位：略（不会还有杂鱼不知道吧）\n1.4电路元件电路由电路元件组成，电路元件是电路中最基本的组成单元\n电路分为集总参数电路和分布参数电路\n· 电路元件特性：可用元件的两个端子的电路物理量之间的函数关系 （二端电路元件，简称电路元件、元件）\n · 集总参数原件，在元件外部不存在任何电场与磁场    · 在任何时刻，流入二端原件的一个端子的电流一定等于从另一个端子流出的电流且两个端子之间的电压为单值量[^1]: 即一个值对应唯一一个函数值。\n电流物理量：电压u、电流i、电荷q、磁通（磁链）元件特性：电压u、电流i、电荷q、磁通（磁链）之间的关系    例：点与原件·电阻元件特性：;电容元件特性：；电感元件特性：\n按元件特性可分为：    · 线性元件、非线性元件、时不变元件（特性参数不随时间变化，又称定常元件）、时变元件    · 无源元件、有源元件\n按元件与外部连接的端子数可分为：· 二段原件，三段原件，四段原件等\n1.5电阻元件电阻元件是反应能量损耗的模型，用于模拟电阻和其他实际部件的电阻特性\n分类近似于电路元件\n常见的电阻：普通金属膜电阻，绕线电阻，电阻排，热敏电阻\n电阻符号 \n服从欧姆定律 ,\nR —– 电阻元件的电阻，单位：欧姆（）G —– 电阻元件的电导，单位：西门子（S），\n伏安特性：电阻元件两端电压u与流过电流i间的关系也称为伏安特性\n4.功率：\n取关联参考方向，电阻元件吸收的顺时功率为：\n电阻是无源元件\n5.能量消耗\n从到时间内，元件吸收的电能为：\n电阻元件一般把吸收的电能转换成热能消耗掉\n实际的金属导体的电阻与导体的尺寸及材料的导电性能有关：\n1.6电压源和电流源1.电压源：有源二端元件，其端电压在任意瞬时与其端电流无关：    · 或者恒定不变——直流    · 或者按某一固有函数规律随时间而变化\n电压源的符号：左侧为通用符号，右侧为直流符号（在为交流电的时候不能使用右侧符号）\n2.伏安特性：交流电源：位置随时间而变化，恒压源：位置恒定不变\n电压源是一个理想的电路元件\n3.功率\n电流源：电流源是一个有源二端元件，其端电流在任一瞬时与其端电压无关：    ·或者恒定不变——直流    ·或者按照某一固有函数规律随时间变化\n电路符号：\n伏安特性：交流电流源：位置随时间的改变而改变恒流源：位置不随时间的改变而改变\n电流源是理想的二端元件\n电压源在实际运行时不允许短路，电流源在实际运行时不允许开路\n正弦电压源/正弦电流源：\n电压源或电流源随时间作正弦规律变化时\n电压源：\n1.7受控电源又称非独立电源（不同于电压源和电流源，受控电源的符号是一个棱形）\n提供的电压或电流，依赖于电路中另一支路的电压或电流。也就是说，只要电路中有一个支路的电压或电流受另一支路的电压或电流控制时，这两个支路就构成一个受控源。\n输出量：电压或电流控制量：电压或电流\n按受控源的分类：\n                        受控电源                           |         输出量为电压————————————————输出量为电流             ↓                          ↓         受控电压源                   受控电流源              |                          |控制量为电压——————控制量为电流 控制量为电压————控制量为电流     ↓                ↓           ↓              ↓电压控电压源      电流控电压源 电压控制电流源  电流控制电流源\n\n\n电压控制的电压源（VCVS）：——控制系数，常数，称为电压放大系数/转移电压比/无量纲\n电压控制的电流源（VCCS）：g——控制系数，常量，成为转移电导，具有电导的量纲（S）\n电流控制的电压源（CCVS）：r——控制系数，常量，称为转移电阻具有电阻的量纲（）\n电流控制的电流源（CCCS）：——控制系数，常量，称为电流放大系数/转移电流比/无量纲\n1.8基尔霍夫定律基尔霍夫\n                    基尔霍夫定律                            |        基尔霍夫电流定律——————————————基尔霍夫电压定律            （KCL）                     （KVL）              |                            |        |————————————|                |——————————|适用于电路中的  反映任一结点的各    适用于电路中  反映任一回路中任一“结点”     支路电流间相互约束   任一“回路”    各支路电压间相              的关系                           互约束的关系\n\n基尔霍夫定律是分析和计算电路的基本依据，是集总电路的基本定律\n有关术语：\n· 支路：每个二端元件可以构成一条支路· 结点：支路的连接点· 回路：由支路构成的闭合路径· 广义节点：由假想闭合面S包围的结点和支路的集合，S即为广义节点\n基尔霍夫电流定律：在集总电路中，任何时刻，对任一结点，所有流出结点的支路电流的代数和为零\n流出节点的电流和等于流入此节点的电流和\nKCL适用于闭合面，在任意瞬间，所有流出闭合面的支路电流代数和=0\n基尔霍夫电压定律；在集总参数电路中，任何时刻，任一回路，所有之路电压的代数和恒为0\n数学方程：\n小结：    · 基尔霍夫定律是分析和计算电路的基本依据        KCl:   KVL:    · KCL与元件性质无关，KCL方程的具体形式仅仅依赖于支路与结点的连接关系和支路电流的参考方向    · KVL与元件的性质无关，KVL方程的具体形式仅仅依赖于回路所关联的支路以及贿赂参考方向和回路中各支路电压的参考方向。\n两类约束：    · 元件的特性形成的约束        ——由元件的电压电流关系来体现                · 元件的相互连接给支路电流和支路电压之间带来的约束        ——由基尔霍夫定律体现，称为拓扑约束          \n第二章2.1引言线性电路：由线性无源元件、线性受控源和独立电源组成的电路\n电阻电路：构成线性电路的无源元件均为线性电阻\n直流电路：线性电路中的独立电源都是直流电源\n本章主要内容： 电阻电路的分析计算，介绍等效变换\n2.2电路等效变换等效变换条件：等效变换前后，被被替换部分电路电压与电流保持不变\n等效变换的实质：“对外等效”——u、i保持不变仅限于等效电路外\n2.3电阻的串联和并联串联：等效电阻\n 分压公式：$u_k=\\frac{R_k}{\\sum_{k=1}^{n}R_k}u=\\frac{R_k}{R_{eq}}u$\n\n并联：等效电阻\n  分流公式$i_k=G_ku=\\frac{G_k}{G_{eq}}i_S$\n\n    当$G_1=G_2=G_3=……=G_n$时,$i_k=\\frac{1}{n}i_S$\n\n    n=2时,$i_1=\\frac{G_1}{G_1+G_2}i_s$ 或者 $i_1=\\frac{R_2}{R_1+R_2}i_S$\n\n串联电阻电路可作为分压电路\n并联电阻电路可作为分流电路\n惠斯通电桥实验\n三角形连接-&gt;Y连接可以提高计算效率\nY连接，又称星型连接/T型连接\n","categories":["note","article"],"tags":["hardware","note"]},{"title":"关于11月27日自习打卡清单内容更新通知（）","url":"/2023/11/25/%E5%85%B3%E4%BA%8E11%E6%9C%8827%E6%97%A5%E8%87%AA%E4%B9%A0%E6%89%93%E5%8D%A1%E6%B8%85%E5%8D%95%E5%86%85%E5%AE%B9%E6%9B%B4%E6%96%B0%E9%80%9A%E7%9F%A5%EF%BC%88%EF%BC%89/","content":"#自习打卡#11月26日11：45闪断更新公告 \n感谢您对《每日自习打卡》的关注与支持。《每日自习打卡》计划将于2023年11月26日11:45 ~ 24:00 期间进行服务器闪断更新。届时将造成玩家强制掉线，无法登录，打卡天数清零等问题。为确保您的游戏内账号数据正常，请在本次闪断更新时提前结束自习。本次更新给各位用户带来的不便，敬请谅解！\n闪断更新时间：2023年11月26日11:45 ~ 24:00 期间\n更新内容：◆工图打卡量减少至一题&#x2F;天（原本为一页&#x2F;天）◆移动arduino课程至每日打卡栏◆新增51单片机入门课程至每日打卡栏◆四级备战日常打卡活动限时开始◆sw课程加入“周末打卡”专栏◆新增自由调度功能，允许在日程繁忙&#x2F;空闲的时候减少&#x2F;增加打卡量（但需保持总量&gt;&#x3D;原本量）◆将打卡汇报模块迁移至Bilibili平台◆将原本打卡清单更新公告迁移至个人博客平台，原微信平台仅提供链接◆预将”Linux学习打卡任务”修改为”Linux选择性复习任务”并移入选择性打卡模块\n闪断补偿：V我50专用二维码两张（见评论区上方“给穷逼一点钱吧！”可展开模块）补偿范围：2023年11月26日11:45更新前及以后所有注册并创建角色的玩家\n本次维护不排除延迟开启的可能，如若延迟则请关注官方发布的具体开服时间\n路过的过路人2023年11月25日\n","categories":["notice"],"tags":["notice"]},{"title":"51单片机入门学习笔记","url":"/2023/11/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"51单片机学习笔记前言这篇文章是我在学习51单片机时的笔记\n学习视频链接：51单片机入门教程-2020版 程序全程纯手打 从零开始入门\n祝我学习顺利\n学习安排硬件要求：\n51单片机一只（淘宝很多），Windows系统电脑一台（苹果叉出去）\n软件要求：\nKeli5，STC-ISP\n单片机和开发板简介单片机，检测MCU，内部集成CPU、RAM、ROM、定时器等一系列电脑常用硬件\n单片机的任务是信息采集、处理、硬件设备\n单片机和计算机相比体积小但是性能较差，成本低结构简单\nunsigned int：无符号int（16位）型数据（单片机内int是默认有单位的）同理：unsigned short、unsigned long……\n祝：非整型除了unsigned char（8位十六进制数）不能加unsigned前缀表示无符号，unsigned和后面有空格\nLCD1602调试工具使用LCD1602液晶屏作为调试窗口\n使用液晶屏的时候数码管和LED模块因为引脚占用无法使用\n\n\n\n函数\n作用\n参数\n\n\n\nLCD_Init()\n初始化\n无\n\n\nLCD_ShowChar(1,1,’A’)\n显示一个字符\n行，列，现实的字符\n\n\nLCD_ShowString(1,3,”Hello”)\n显示字符串\n行，起始列，字符串\n\n\nLCD_ShowNum(1,9,123,3)\n显示十进制数字\n行，起始列，数字，数字长度（范围1-5）\n\n\nLCD_ShowSignedNum(2,1,-66，2)\n显示有符号十进制数字\n同上\n\n\nLCD_ShowHexNum(2,1,0xA8,2)\n显示十六进制数字\n同上\n\n\nLCD_ShowBinNum(2,4,0xAA,8)\n显示二进制数字\n行，起始列，数字（只能用十六进制数字代替），长度\n\n\n51单片机矩阵键盘51单片机中矩阵键盘接在STC89C52RC的10-17脚，我们可以通过逐列扫描的方法来完成对按键是否被按下进行确定，具体代码如下：\nunsigned char Matrixkey()&#123;\tunsigned char KeyNumber=0;\t\t// ????\tP1=0xFF;\tP1_3=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=1;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=5;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=9;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=13;&#125;\t\tP1=0xFF;\tP1_2=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=2;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=6;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=10;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=14;&#125;\t\tP1=0xFF;\tP1_1=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=3;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=7;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=11;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=15;&#125;\t\t\tP1=0xFF;\tP1_0=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=4;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=8;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=12;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=16;&#125;\t\treturn KeyNumber;&#125;\n\n这里我们声明了一个扫描的函数，在你按下后松开之前函数不会继续进行但是手松开之后会返回你按下按键对应的数值。\n利用这个键盘我们可以完成一些简单的功能，比如说下面的代码利用矩阵键盘完成了一个简单的个位数计算器（Matrixkey（）函数在Matrixkey头文件中定义了）：\n#include &lt;REGX52.H&gt;#include &quot;Matrixkey.h&quot;#include &quot;Delay.h&quot;#include &quot;LCD1602.h&quot;int Num1 = 0, Num2 = 0, Num3 = 0;int Answer = 0;unsigned char b;void main()&#123;    LCD_Init();    while (1)    &#123;        LCD_ShowString(1, 1, &quot;Input equations&quot;);        while (Num1 &gt;= 10 || Num1 == 0)        &#123;            Num1 = Matrixkey();        &#125;        LCD_ShowNum(2, 1, Num1, 1);        while (Num2 &gt;= 14 || Num2 &lt;= 9)        &#123;            Num2 = Matrixkey();        &#125;        if (Num2 == 10)        &#123;            b = &#x27;+&#x27;;            LCD_ShowString(2, 2, &quot;+&quot;);        &#125;        else if (Num2 == 11)        &#123;            b = &#x27;-&#x27;;            LCD_ShowString(2, 2, &quot;-&quot;);        &#125;        else if (Num2 == 12)        &#123;            b = &#x27;*&#x27;;            LCD_ShowString(2, 2, &quot;*&quot;);        &#125;        else if (Num2 == 13)        &#123;            b = &#x27;/&#x27;;            LCD_ShowString(2, 2, &quot;/&quot;);        &#125;        while (Num3 &gt;= 10 || Num3 == 0)        &#123;            Num3 = Matrixkey();        &#125;        LCD_ShowNum(2, 3, Num3, 1);        if (b == &#x27;+&#x27;)        &#123;            Answer = Num1 + Num3;        &#125;        else if (b == &#x27;-&#x27;)        &#123;            Answer = Num1 - Num3;        &#125;        else if (b == &#x27;*&#x27;)        &#123;            Answer = Num1 * Num3;        &#125;        else if (b == &#x27;/&#x27;)        &#123;            Answer = Num1 / Num3;        &#125;\t\t\t\tLCD_ShowString(2,4,&quot;=&quot;);\t\t\t\tif(Answer&lt;0)\t\t\t\t&#123;\t\t\t\t\tAnswer=-Answer;\t\t\t\t\tLCD_ShowString(2,5,&quot;-&quot;);\t\t\t\t\tLCD_ShowNum(2, 6, Answer, 2);\t\t\t\t&#125;else\t\t\t\t&#123;\t\t\t\t\tLCD_ShowSignedNum(2, 5, Answer, 2);\t\t\t\t&#125;                Num1 = Num2 = Num3 = 0;        Delay(1);    &#125;&#125;\n\n\n蜂鸣器蜂鸣器分为有源蜂鸣器和无源蜂鸣器，其中的“源”指的是震荡源有源蜂鸣器只要通电就可以发声，但是振荡频率固定无源蜂鸣器内部不带振荡源，需要提供振荡脉冲的频率，但是发声频率可以调整\n正负极看标志或者长短脚（长脚为正极）\n串口TXD &#x3D; transmit exchange dataRXD &#x3D; receive ~ ~TXD和RXD要交叉连接，VCC和GND对接\n只需单项数据传输时，可以只连接一根通信线\n当电平标准不一致时，需要加电平转换芯片\n\n电平标准是与数据对应关系1和0的表达方式，是传输线缆中人为规定的电压，常用的有以下三种TTL电平：+5V表示1，0V表示0；RS232电平：-3——-5V表示1，+3——+15V表示0RS485电平：两线压差+2——+6V表示1，-2——-6V表示0（差分信号）’前两者距离短，容忍电压大，常用于电脑等，后者距离远可达1km\n\n相关术语：· 全双工 ： 通信双方可以在同一时刻相互传输数据· 半双工 ： 通信双方可以相互传输数据，但是必须分时复用一根数据线· 单工 ： 通信只能由一方发送到另一方，不能反向传输\n· 异步 ： 通信双方各自约定通信速率· 同步 ： 通信双方靠一根时钟线来约定通信速率\n· 总线：连接各个设备的数据的传输线路\n· 波特率：串口通信的速率（发送和接受各数据位ied间隔时间）\n—目前已学习完毕，暂时不考虑继续更新—\n","categories":["note","article"],"tags":["SCM","hardware","note"]},{"title":"STM32学习笔记1（不定时更新）","url":"/2024/01/31/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/","content":"STM32学习笔记这个笔记是基于标准库的，跟随江协教程学习。\n1-新建工程新建工程时要选择启动文件，其选择依据芯片类型，具体见下表\n\n\n\n缩写\n释义\nFlash容量\n型号\n\n\n\nDL_VL\n小容量产品超值系列\n16-32K\nSTM32F100\n\n\nMD_VL\n中容量产品超值系列\n64-128K\nSTM32F100\n\n\nHD_VL\n大容量产品超值系列\n256-512K\nSTM32F100\n\n\nLD\n小容量产品\n16-32K\nSTM32F101/102/103\n\n\nMD\n中容量产品\n64-128K\nSTM32F101/102/103\n\n\nHL\n大容量产品\n256-512K\nSTM32F101/102/103\n\n\nXL\n加大容量产品\n大于512K\nSTM32F101/102/103\n\n\nCL\n互联型产品\n-\nSTM32F105/107\n\n\n总结：新建工程的步骤：· 建立工程文件夹，Keil中新建工程，选择型号· 工程文件夹里建立StartLibrary、User等文件夹，2复制固件库里面的文件到工程文件夹· 工程里对应建立Start、Library、User等同名称的分组，然后将文件夹的文件添加到工程分组里· 工程选项，C/C++，Include Paths内声明所有包含头文件的文件夹· 工程选项，C/C++，Define内定义USE_STDPERIPH_DRIVER· 工程选项，Debug，下拉列表选择对应调试器，Settings,FlashDownload里勾选Reset and Run\n工程架构：\nstartup_xx.c：                  system_xx.c/.h:         stm32f10x.h:    复位中断：                     定义Systeminit           外设寄存器描述        调用Systeminit          main.c:                 core_cm3.c/.h:        调用main                    定义main                内核寄存器描述    其他中断：                  stm32f10x_it.c/.h:      misc.c/.h,stm32f10x_abc.c/.h…：        调用中断                    定义中断                库函数        处理函数                    处理函数            stm32f10x_conf.h:                                其他用户文件                库函数配置\n\n2-GPIOGPIO简介GPIO即通用输入输出口可配置8种输入输出模式引脚：0-3.3V，部分可容忍5V\n输出模式下可以控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等\nGPIO基本结构\n由于stm32是32位的单片机，stm32内部的寄存器都是32位的，但是端口只有16个，所以寄存器只有低16位有对应端口\n注：输入驱动器中的肖特基触发器实际为施密特触发器，此处为翻译错误\n施密特触发器：当电压高于一定值的时候立马输出高电压，当电压低于一定值的时候立马输出低电压，处于中间保持此处用于整形，防止信号失真\n\n输出数据清除器同时控制16个端口且只能整体读写，想要控制个别位需要用”&amp;=”以及”|=”的方法，比较麻烦，利用前面的位设置/清除寄存器可以仅控制输出数据寄存器的某一位而不影响其他位\n输出控制有推挽、开漏、关闭三种输出模式\n\n推挽：此模式下，P-MOS和N-MOS均有效。数据寄存器为1时，P导通N断开，输出接VDD，高电平；数据寄存器为0时，P断开N导通，输出接VSS，低电平。此状态下高低电平均有较强驱动能力，所以又称强推输出模式。\n\n开漏：此模式下P-MOS无效，N-MOS有效。数据寄存器为1时，N断开，相当于输出断开，也就是高阻模式；数据寄存器为0时，N导通，输出接VSS，低电平。此模式可以作为通信协议的驱动模式，如I2C，此模式下可以避免各个设备的相互干扰；同时在此模式下，通过在IO口外接上拉电源（以5V为例），数据寄存器输出1时由外部电路上拉到5V，就可以兼容5V的设备。\n\n关闭，此时P-MOS和N-MOS均关闭，IO口由外部电路控制。\n\n\nGPIO模式通过配置GPIO的端口寄存器，端口可配置成以下8种模式\n四种输出方式：　　（1）推挽输出   可输出引脚电平，高电平为高阻态，低电平接VSS　　（2）开漏输出   可输出引脚电平，高电平接VDD，低电平接VSS　　（3）复用推挽   由片上外设控制，高电平为高阻态，低电平接VSS　　（4）复用开漏   由片上外设控制，高电平接VDD，低电平接VSS\n四种输入方式：　　（1）浮空输入   可读取引脚电平，若引脚悬空，则电平不确定　　（2）上拉输入   可读取引脚电平，内部连接上拉电阻，悬空时默认高电平　　（3）下拉输入   可读取引脚电平，内部连接下拉电阻，悬空时默认低电平　　（4）模拟输入   GPIO无效，引脚直接接入内部ADC\n浮空/上拉/下拉输入\n在输入模式下，输出寄存器是断开的，端口只能输入而不能输出。输入寄存器的两个的电阻可以上拉工作下拉工作或者都不工作，对应上拉输入下拉输入和浮空输入。右侧保护二极管，VDD和VDD_FT不同，后者对5V容忍IO脚是特殊的\n模拟输入\n在次模式下，IO口直接模拟输入，其余部分全部无效\n开漏/推挽输出\nP-MOS无效时是开漏输出，P-MOS和N-MOS均有效时是推挽输出。在输出模式下输入模式是有效的。\n复用开漏/复用推挽输出\n此状态下通用输出没有连接，引脚的控制权转移到片上外设。\nLED和蜂鸣器LED：反光二极管\n蜂鸣器：分为有源无源，有源自带振荡源，接上直流电压即可持续发声；无源内部不带振荡源，需要控制器提供震荡脉冲才可发声，调整振荡脉冲频率可发出不同频率的声音。\n面包板结构如下图：\n应用1.LED闪烁电路板连接图：\n\n使用GPIO点灯的步骤：\n\n使用RCC开启GPIO时钟；\n使用GPIO_Init()函数初始化\n使用输出或者输入函数控制GPIO口\n\nGPIO_ResetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)和GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)是设置引脚电平的两个函数，其中第一个参数是GPIO口（如GPIOA），第二个参数是引脚号（如GPIO_PIN_0）\n攥写一段代码如下：\n#include \"stm32f10x.h\"                  // Device headerint main(void){    GPIO_InitTypeDef    GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    GPIO_ResetBits(GPIOA,GPIO_Pin_0);    while(1)    {            }}\n\n写入后得到现象如下图：\n\n可以看到LED成功被点亮。\n在我们使用GPIO_SetBits(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin)时，LED熄灭。\nvoid GPIO_WriteBit(GPIO_TypeDef* GPIOx, uint16_t GPIO_Pin, BitAction BitVal)是对单个引脚写入信号的函数，在上程序中，将GPIO_ResetBits(GPIOA,GPIO_Pin_0);替换为GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);也能得到点亮的效果。\n下面我们要实现LED的闪烁，通过使用Delay模块即可实现（Delay模块的编写在之后的课程）。代码如下\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"int main(void){    GPIO_InitTypeDef    GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    while(1)    {        GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_RESET);        Delay_ms(500);        GPIO_WriteBit(GPIOA,GPIO_Pin_0,Bit_SET);        Delay_ms(500);    }}\n\n写入后，可以观察到LED闪烁。使用SetBits或者ResetBits得到的效果同样。\n在WriteBit函数中，BIT_(RE)SET可以换成0或者1，但是前面要加上”(BitAction)”切换成枚举类型\n将LED长短脚位置互换之后，LED依旧闪烁，说明推挽模式下高低电平都有驱动能力；将模式改成OUT_OD（开漏输出）LED不亮了，说明开漏输出的高电平无驱动能力，重新将LED长短脚换回原来位置，LED回复闪烁，说明开漏模式下低电平有驱动能力。\n应用2.LED流水灯面包板连线：\n\n在编写流水灯的程序，设置引脚的时候可以使用“|”来同时设置多个引脚，在流水灯应用中，我们需要使用0-7，共八个引脚，所以可以写GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0  GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7;\n最终代码如下：\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"unsigned char i;int main(void){    GPIO_InitTypeDef    GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5| GPIO_Pin_6 | GPIO_Pin_7;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    while(1)    {        for ( i = 0; i &lt; 8; i++)        {            GPIO_Write(GPIOA,~(0x0001&lt;&lt;i));            Delay_ms(500);        }    }}\n\n效果图如下：\n应用3.蜂鸣器面包板连线：\n具体代码如下：\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"unsigned char i;int main(void){    GPIO_InitTypeDef    GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);    while(1)    {        GPIO_ResetBits(GPIOB,GPIO_Pin_13);        Delay_ms(500);        GPIO_SetBits(GPIOB,GPIO_Pin_13);        Delay_ms(500);    }}\n注：我在使用的时候连接了B13，所以代码中写的是13\n传感器模块给予的工具包包含了四个传感器模块：光敏/热敏/对射式红外/反射式红外传感器，图片及电路图如下：\n结构较简单，不多赘述\n部分C语言知识点数据类型浮点数不能加unsigned\n在单片机编程中，原本用于定义字符的char常被用于定义整形，所以C和ST就给其定义了新的关键字，出处于相同原因，部分其他关键字也被定义了新的名字，具体见下表：\n\n\n\n关键字\n位数\n表示范围\nstdint关键字\nST关键字\n\n\n\nchar\n8\n-128 - 127\nint8_t\ns8\n\n\nunsigned char\n8\n0-255\nuint8_t\nu8\n\n\nshort\n16\n-32768 - 32767\nint16_t\ns16\n\n\nunsigned short\n16\n0 - 65535\nuint16_t\nu16\n\n\nint\n32\n-2147483648 - 2147483647\nint32_t\ns32\n\n\nunsigned int\n32\n0 - 4294967295\nuint32_t\nu32\n\n\nlong\n32\n-2147483648 - 2147483647\n\ns32\n\n\nunsigned long\n32\n0 - 4294967295\n\nu32\n\n\nlong long\n64\n-(2^64)/2 - (2^64)/2-1\nint64_t\n\n\n\nunsigned long long\n32\n0 - (2^64)-1\nuint64_t\n\n\n\nfloat\n32\n-3.4e38 - 3.4e38\n\n\n\n\ndouble\n64\n-1.7e308 = 1.7e308\n\n\n\n\n注：ST关键字是老版本的，推荐使用stdint关键字\n宏定义·关键字：#define·用途：将一个字符串改成数字，便于理解防止出错；提取程序中常出现的参数，便于修改\ne.p. : 定义宏定义：        #define ABC 12345       引用宏定义：        int a = ABC; //等效于int a = 12345;\ntypedef·关键字：typedef·用途：将比较长的变量类型名字改名字，便于使用\ne.p. : 定义typedef：        typedef unsigned char uint8_t;       引用typedef：        unit8_t a; //等效于unsigned char a;\n与宏定义的不同：    1. 新名字在后面    2. 仅能用于变量类型名    3. typedef会进行检查，更安全\n结构体·关键字：struct·用途：数据打包，不同类型变量的集合\ne.p. : 定义结构体：        struct{char x;int y;float z;} StructName;        因为结构体变量类型较长，所以常用typedef更改变量类型名       引用结构体：        StructName.x= ‘A’;        StructName.y= 66;        StructName. z= 1.14;    或：pStructName-&gt;x= ‘A’;    //pSrtuctName是结构体的地址        pStructName-&gt;y= 66;        pStructName-&gt;z= 1.14;\n使用typedef举例：\ntypedef struct{    char x;    int y;    float z;} StructName_1;int main(){    StructName_1 c;    StructName_1 d;    c.x= 'A';    c.y= 66;    c. z= 1.14;    prinf(\"c.x-%c\\n\",c.x);    return 0;}\n\n枚举·关键字：enum·用途：定义一个取值受限的整型变量，用于限制变量取值范围；宏定义的集合\ne.p. : 定义枚举变量：        enum{FALSE = 0, TRUE = 1} EnumName;        因为枚举变量变量类型较长，所以常用typedef更改变量类型名       引用typedef：        EnumName=FALSE;        EnumName=TRUE;\n应用4.按键控制LED面包板连接图如下：\n连接完成品如下：\n为了保持主函数整洁，将部分代码封装到头文件Key.c和LED.c\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"/**  * 函    数：按键初始化  * 参    数：无  * 返 回 值：无  */void Key_Init(void){\t/*开启时钟*/\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t\t//开启GPIOB的时钟\t\t/*GPIO初始化*/\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_11;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOB, &amp;GPIO_InitStructure);\t\t\t\t\t\t//将PB1和PB11引脚初始化为上拉输入}/**  * 函    数：按键获取键码  * 参    数：无  * 返 回 值：按下按键的键码值，范围：0~2，返回0代表没有按键按下  * 注意事项：此函数是阻塞式操作，当按键按住不放时，函数会卡住，直到按键松手  */uint8_t Key_GetNum(void){\tuint8_t KeyNum = 0;\t\t//定义变量，默认键码值为0\t\tif (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0)\t\t\t//读PB1输入寄存器的状态，如果为0，则代表按键1按下\t{\t\tDelay_ms(20);\t\t\t\t\t\t\t\t\t\t\t//延时消抖\t\twhile (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_1) == 0);\t//等待按键松手\t\tDelay_ms(20);\t\t\t\t\t\t\t\t\t\t\t//延时消抖\t\tKeyNum = 1;\t\t\t\t\t\t\t\t\t\t\t\t//置键码为1\t}\t\tif (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0)\t\t\t//读PB11输入寄存器的状态，如果为0，则代表按键2按下\t{\t\tDelay_ms(20);\t\t\t\t\t\t\t\t\t\t\t//延时消抖\t\twhile (GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_11) == 0);\t//等待按键松手\t\tDelay_ms(20);\t\t\t\t\t\t\t\t\t\t\t//延时消抖\t\tKeyNum = 2;\t\t\t\t\t\t\t\t\t\t\t\t//置键码为2\t}\t\treturn KeyNum;\t\t\t//返回键码值，如果没有按键按下，所有if都不成立，则键码为默认值0}\n\n#include \"stm32f10x.h\"                  // Device header/**  * 函    数：LED初始化  * 参    数：无  * 返 回 值：无  */void LED_Init(void){\t/*开启时钟*/\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t\t//开启GPIOA的时钟\t\t/*GPIO初始化*/\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStructure);\t\t\t\t\t\t//将PA1和PA2引脚初始化为推挽输出\t\t/*设置GPIO初始化后的默认电平*/\tGPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);\t\t\t\t//设置PA1和PA2引脚为高电平}/**  * 函    数：LED1开启  * 参    数：无  * 返 回 值：无  */void LED1_ON(void){\tGPIO_ResetBits(GPIOA, GPIO_Pin_1);\t\t//设置PA1引脚为低电平}/**  * 函    数：LED1关闭  * 参    数：无  * 返 回 值：无  */void LED1_OFF(void){\tGPIO_SetBits(GPIOA, GPIO_Pin_1);\t\t//设置PA1引脚为高电平}/**  * 函    数：LED1状态翻转  * 参    数：无  * 返 回 值：无  */void LED1_Turn(void){\tif (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)\t\t//获取输出寄存器的状态，如果当前引脚输出低电平\t{\t\tGPIO_SetBits(GPIOA, GPIO_Pin_1);\t\t\t\t\t//则设置PA1引脚为高电平\t}\telse\t\t\t\t\t\t\t\t\t\t\t\t\t//否则，即当前引脚输出高电平\t{\t\tGPIO_ResetBits(GPIOA, GPIO_Pin_1);\t\t\t\t\t//则设置PA1引脚为低电平\t}}/**  * 函    数：LED2开启  * 参    数：无  * 返 回 值：无  */void LED2_ON(void){\tGPIO_ResetBits(GPIOA, GPIO_Pin_2);\t\t//设置PA2引脚为低电平}/**  * 函    数：LED2关闭  * 参    数：无  * 返 回 值：无  */void LED2_OFF(void){\tGPIO_SetBits(GPIOA, GPIO_Pin_2);\t\t//设置PA2引脚为高电平}/**  * 函    数：LED2状态翻转  * 参    数：无  * 返 回 值：无  */void LED2_Turn(void){\tif (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)\t\t//获取输出寄存器的状态，如果当前引脚输出低电平\t{                                                  \t\tGPIO_SetBits(GPIOA, GPIO_Pin_2);               \t\t//则设置PA2引脚为高电平\t}                                                  \telse                                               \t\t//否则，即当前引脚输出高电平\t{                                                  \t\tGPIO_ResetBits(GPIOA, GPIO_Pin_2);             \t\t//则设置PA2引脚为低电平\t}}\n\n主程序：\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"LED.h\"#include \"Key.h\"uint8_t KeyNum;\t\t//定义用于接收按键键码的变量int main(void){\t/*模块初始化*/\tLED_Init();\t\t//LED初始化\tKey_Init();\t\t//按键初始化\t\twhile (1)\t{\t\tKeyNum = Key_GetNum();\t\t//获取按键键码\t\t\t\tif (KeyNum == 1)\t\t\t//按键1按下\t\t{\t\t\tLED1_Turn();\t\t\t//LED1翻转\t\t}\t\t\t\tif (KeyNum == 2)\t\t\t//按键2按下\t\t{\t\t\tLED2_Turn();\t\t\t//LED2翻转\t\t}\t}}\n具体功能见注释，通过这几个程序可以做到使用按键控制LED亮灭。\n应用5.光敏传感器控制蜂鸣器接线图如下：\n连接完成后实物图如下：\n\n头文件：LightSensor.c:\n#include \"stm32f10x.h\"                  // Device header/**  * 函    数：光敏传感器初始化  * 参    数：无  * 返 回 值：无  */void LightSensor_Init(void){\t/*开启时钟*/\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE);\t\t//开启GPIOB的时钟\t\t/*GPIO初始化*/\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_13;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOB, &amp;GPIO_InitStructure);\t\t\t\t\t\t//将PB13引脚初始化为上拉输入}/**  * 函    数：获取当前光敏传感器输出的高低电平  * 参    数：无  * 返 回 值：光敏传感器输出的高低电平，范围：0/1  */uint8_t LightSensor_Get(void){\treturn GPIO_ReadInputDataBit(GPIOB, GPIO_Pin_13);\t\t\t//返回PB13输入寄存器的状态}\n\nLED.c:\n#include \"stm32f10x.h\"                  // Device header/**  * 函    数：LED初始化  * 参    数：无  * 返 回 值：无  */void LED_Init(void){\t/*开启时钟*/\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t\t//开启GPIOA的时钟\t\t/*GPIO初始化*/\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_1 | GPIO_Pin_2;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStructure);\t\t\t\t\t\t//将PA1和PA2引脚初始化为推挽输出\t\t/*设置GPIO初始化后的默认电平*/\tGPIO_SetBits(GPIOA, GPIO_Pin_1 | GPIO_Pin_2);\t\t\t\t//设置PA1和PA2引脚为高电平}/**  * 函    数：LED1开启  * 参    数：无  * 返 回 值：无  */void LED1_ON(void){\tGPIO_ResetBits(GPIOA, GPIO_Pin_1);\t\t//设置PA1引脚为低电平}/**  * 函    数：LED1关闭  * 参    数：无  * 返 回 值：无  */void LED1_OFF(void){\tGPIO_SetBits(GPIOA, GPIO_Pin_1);\t\t//设置PA1引脚为高电平}/**  * 函    数：LED1状态翻转  * 参    数：无  * 返 回 值：无  */void LED1_Turn(void){\tif (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_1) == 0)\t\t//获取输出寄存器的状态，如果当前引脚输出低电平\t{\t\tGPIO_SetBits(GPIOA, GPIO_Pin_1);\t\t\t\t\t//则设置PA1引脚为高电平\t}\telse\t\t\t\t\t\t\t\t\t\t\t\t\t//否则，即当前引脚输出高电平\t{\t\tGPIO_ResetBits(GPIOA, GPIO_Pin_1);\t\t\t\t\t//则设置PA1引脚为低电平\t}}/**  * 函    数：LED2开启  * 参    数：无  * 返 回 值：无  */void LED2_ON(void){\tGPIO_ResetBits(GPIOA, GPIO_Pin_2);\t\t//设置PA2引脚为低电平}/**  * 函    数：LED2关闭  * 参    数：无  * 返 回 值：无  */void LED2_OFF(void){\tGPIO_SetBits(GPIOA, GPIO_Pin_2);\t\t//设置PA2引脚为高电平}/**  * 函    数：LED2状态翻转  * 参    数：无  * 返 回 值：无  */void LED2_Turn(void){\tif (GPIO_ReadOutputDataBit(GPIOA, GPIO_Pin_2) == 0)\t\t//获取输出寄存器的状态，如果当前引脚输出低电平\t{                                                  \t\tGPIO_SetBits(GPIOA, GPIO_Pin_2);               \t\t//则设置PA2引脚为高电平\t}                                                  \telse                                               \t\t//否则，即当前引脚输出高电平\t{                                                  \t\tGPIO_ResetBits(GPIOA, GPIO_Pin_2);             \t\t//则设置PA2引脚为低电平\t}}\n\n主程序如下：\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"Buzzer.h\"#include \"LightSensor.h\"int main(void){\t/*模块初始化*/\tBuzzer_Init();\t\t\t//蜂鸣器初始化\tLightSensor_Init();\t\t//光敏传感器初始化\t\twhile (1)\t{\t\tif (LightSensor_Get() == 1)\t\t//如果当前光敏输出1\t\t{\t\t\tBuzzer_ON();\t\t\t\t//蜂鸣器开启\t\t}\t\telse\t\t\t\t\t\t\t//否则\t\t{\t\t\tBuzzer_OFF();\t\t\t\t//蜂鸣器关闭\t\t}\t}}\n\nOLED简介OLED(Organic Light Emitting Diode)供电：3-5.5V，通信协议：I2C/SPI，分辨率：128*64（0.96寸）\nOLED显示屏电路原理图：\n\n调试方式\n串口调试：通过串口通信将调试信息发送到电脑端，电脑使用串口助手显示调试信息\n显示屏调试：将显示屏连到单片机，将调试信息直接在显示屏上显示\nKeil调试模式：借助keil软件的调试功能，可使用单步运行、设置断点、查看寄存器以及变量等功能（调试模式下不能修改代码）\n\n驱动函数将OLED显示屏区分为4行16列\n教程给出的函数有：\n\n\n\n函数\n功能\n\n\n\nOLED_Init()\n初始化\n\n\nOLED_Clear()\n清屏\n\n\nOLED_ShowChar(1,1,’A’)\n显示一个字符\n\n\nOLED_ShowString(1,3,”HelloWorld”)\n显示字符串\n\n\nOLED_ShowNum(2,1,12345,5)\n显示十进制数字\n\n\nOLED_ShowSignedNum(2,7,-66,2)\n显示有符号十进制数\n\n\nOLED_ShowHexNum(3,1,0xAA55,4)\n显示16进制数字\n\n\nOLED_ShowBinNum(4,1,0xAA55,16)\n显示2进制数字\n\n\n实体演示面包板接线图 ；\n编写如下代码：\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"int main(void){\tOLED_Init();    OLED_ShowChar(1,1,'A');    OLED_ShowString(1,3,\"Homo\");    OLED_ShowNum(2,1,114,3);    OLED_ShowHexNum(2,4,0x514,3);    OLED_ShowSignedNum(3,1,-19198,5);    OLED_ShowBinNum(4,1,0x2,2);    while(1)    {              }}\n\n显示结果如下：\n莫名感觉有点可爱\nEXTI外部中断简介EXTI(Extern Interrupt)外部中断\nEXTI可以监测指定GPIO口的电平信号，当其指定的GPIO产生电平变化时，EXTI会立刻向NVIC发出中断申请，经NVIC裁决后即可中断CPU主程序，使CPU执行EXTI对应的中断程序\n支持的触发方式：上升沿/下降沿/双边沿/软件触发\n支持全部GPIO口，但是相同的Pin不能同时触发中断\n通道数：16个GPIO，外加PVD输出、RTC闹钟、USB唤醒、以太网唤醒\n触发相应方式：中断响应/事件响应（中断响应是触发中断，事件响应是触发别的外设操作）\n中断系统中断：主程序运行时出现了特定的中断触发条件（中断源），使CPU暂停当前程序转去处理中断程序，处理完之后返回暂停位置继续执行原本程序\n中断优先级：多个中断源同时申请中断的时候，CPU会根据中断源的轻重缓急进行裁决，优先响应更加紧急的中断源\n中断嵌套：一个中断正在运行的时候，有优先级更高的中断源申请中断的时候，CPU会再次暂停当前中断程序，转去处理新的中断程序，处理完之后依次返回\nSTM32中断包括：EXTI,TIM,ADC,USRT,SPI,I2C,PTC\n中断向量表：\nNVICNVIC基本结构\n使用NVIC为了防止中断占用过多CPU引脚以及防止优先级分组对CPU性能的占用\nNVIC优先级分组NVIC的中断优先级由优先级寄存器的四位（0-15）组成，这四位可以进行切分，分成高n位的抢占优先级和低4-n位的相应优先级\n抢断优先级高的可以中断嵌套，响应优先级高的可以优先排队，两者相同按中断号排队\nEXTIEXTI基本结构结构框图：\nAFIO是一个数据选择器，他会选择前面连接的一个引脚连接到EXTI，这也是为什么前面说每个引脚只能连接一个中断。\n*注：原本EXTI有20路通道输出，但是其中5-9，10-15分别被集中到一个引脚中，即5-9，10-15分别会触发同一个中断函数，在这两个中断函数中，我们要通过标志位来判断具体是哪个中断\n下面还有20个引脚连接外设\nAFIO复用IO口AFIO电路图：\nAFIO主要用于引脚复用功能的选择和重定义\n在STM32中，AFIO主要完成两个任务：复用功能引脚重映射、中断引脚选择\nEXTI内部框图EXTI内部框图：\n图中右下角输入线就是20根输入线，通过检测器决定是进行上升沿触发/下降沿触发/两者\n请求挂起寄存器可以被读取以判断是哪个通道触发的判断\n· 需要使用外部中断的情况：外部驱动的突发事件\n旋转编码器介绍旋转编码器：用来测量位置、速度或旋转方向的装置，当其旋转轴旋转时，其输出端可以输出与旋转速度和方向对应的方波信号，读取方波信号的频率和相位信息即可得知旋转轴的速度和方向\n类型：机械触点式/霍尔传感器式/光栅式\n光栅式：通过旋钮上光栅阻挡信号产生信号波，但是只能测位置和速度不能测方向\n机械触电式：金属触点经过设计，正反转时。两个触电会有不同的相位差，通过相位差可以判断方向\n硬件电路：\n应用1.对射式红外传感器计次面包板连接图：\n头文件：CountSensor.c:\n#include \"stm32f10x.h\"uint16_t CounterSensor_Count;void CounterSensor_Init(){    //基础配置    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_14;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOB,&amp;GPIO_InitStructure);    //配置AFIO    GPIO_EXTILineConfig(GPIO_PortSourceGPIOB,GPIO_PinSource14);    //配置EXTI    EXTI_InitTypeDef EXTI_InitStructure;    EXTI_InitStructure.EXTI_Line=EXTI_Line14;    EXTI_InitStructure.EXTI_LineCmd=ENABLE;    EXTI_InitStructure.EXTI_Mode=EXTI_Mode_Interrupt;    EXTI_InitStructure.EXTI_Trigger=EXTI_Trigger_Falling;    EXTI_Init(&amp;EXTI_InitStructure);    //配置NVIC    NVIC_PriorityGroupConfig(NVIC_PriorityGroup_2);    NVIC_InitTypeDef NVIC_InitStructure;    NVIC_InitStructure.NVIC_IRQChannel=EXTI15_10_IRQn;    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=1;    NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;    NVIC_Init(&amp;NVIC_InitStructure);}uint16_t CountSensor_GetCount(){    return CounterSensor_Count;}void EXTI15_10_IRQHandler(void){    if(EXTI_GetITStatus(EXTI_Line14)==SET)    {        if (GPIO_ReadInputDataBit(GPIOB,GPIO_Pin_14)==0)        {            CounterSensor_Count++;        }        EXTI_ClearITPendingBit(EXTI_Line14);            }    }\n\n主程序：main.c:\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"CountSensor.h\"int main(void){\tOLED_Init();    CounterSensor_Init();    OLED_ShowChar(1,1,'A');    while(1)    {        OLED_ShowNum(2,1,CountSensor_GetCount(),5);           }}\n现象：每次对射式红外传感器中间被隔光，OLED上显示次数+1\n应用2.旋转编码器计次面包板接线图：![旋转编码计数器](https://pic .imgdb.cn/item/65c481509f345e8d03201b8a.jpg)\nTIM定时器中断TIM简介定时器可以对输入的时钟进行计数，并在计数值达到设定值时触发中断16位计数器、预分频器、自动重装寄存器的时基单元，在72MHz计数时钟下可以实现最大59.65s的定时\n不仅具备基本的定时中断功能，而且还包含内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等多种功能\n根据复杂度和应用场景分为了高级定时器、通用定时器、基本定时器三种类型\n\n\n\n类型\n编号\n总线\n功能\n\n\n\n高级定时器\nTIM1、TIM8\nAPB2\n拥有通用定时器全部功能，并额外具有重复计数器、死区生成、互补输出、刹车输入等功能\n\n\n通用定时器\nTIM2、TIM3、TIM4、TIM5\nAPB1\n拥有基本定时器全部功能，并额外具有内外时钟源选择、输入捕获、输出比较、编码器接口、主从触发模式等功能\n\n\n基本定时器\nTIM6、TIM7\nAPB1\n拥有定时中断、主模式触发DAC的功能\n\n\nSTM32F103C8T6定时器资源：TIM1、TIM2、TIM3、TIM4\n基本定时器\nPSC预分频器：输出频率=输入频率/输入的值\n自动重装寄存器记录写入的计数目标，当计数==技术目标的时候产生一个中断信号并清零计数器\n此类计数值等于自动重装值产生的中断叫做“更新中断”\n通用定时器\n通用定时器除了向上计数（从0开始累计到重装值之后清零同时申请中断），还支持向下计数（从重装值开始递减，到0之后回到重装值并申请中断）和中央对齐计数（先从0向上到重装值申请中断然后从重装值向下到0再申请中断，依次循环），高级计时器也支持这三类模式\n除了使用内部72Hz的时钟，还可以通过ETR连接外部时钟（通过ETRF作为时钟使用较简单，通过TRGI会占据通道\nITR引脚来自其他定时器的TRGO输出\n高级定时器\n基本和通用计时器只能每个计数周期发生一次中断，但是高级计时器可以使用重复次数计时器完成多个技术周期进行一次中断\n定时中断基本结构\n预分频器时序图：\n预分频器原理：在TIMx_PSC中写入新数据后（改变预分频值），控制，直到当前计数周期结束之后，改变的分频值才会起作用\n预分频计数器内部也是靠计数器工作的，分频值为0时，计数器恒为0，分频值为1时，计数器就01计数，回到0时发出一个脉冲，定时器时钟计数。\n计数器计数频率：CK_CNT=CK_PSC/(PSC+1)\n计时器时序\nUIF需要在中断程序中手动清零\n计数器溢出频率：CK_CNT_OV=CK_CNT/(ARR+1)=CK_PSC/(PSC+1)/(ARR+1)\n计数器无预装时序计数器中有缓冲计时器，可以通过修改APRE的值控制是否使用\n\n在无预装时许的情况下修改技术目标，若当前计数值小于技术目标，则到达修改后的计数目标然后重置，若大于，则会因为无法等于技术目标而一直到上限再重置 \n计数器有预装时序\n影子计数器用于同步防止出错\nRCC时钟树\n在不修改参数的情况下，三种计时器都是72Hz\n应用1.定时器定时中断面包板接线图：\n头文件Timer.c：\n#include \"stm32f10x.h\"extern uint16_t Num;void TImer_Init(void){    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);    TIM_InternalClockConfig(TIM2);    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;    TIM_TimeBaseInitStructure.TIM_ClockDivision=TIM_CKD_DIV1;    TIM_TimeBaseInitStructure.TIM_CounterMode=TIM_CounterMode_Up;    TIM_TimeBaseInitStructure.TIM_Period=10000-1;    TIM_TimeBaseInitStructure.TIM_Prescaler=7200-1;    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);    TIM_ClearFlag(TIM2,TIM_FLAG_Update);    TIM_ITConfig(TIM2,TIM_IT_Update,ENABLE);    NVIC_InitTypeDef NVIC_InitStructure;    NVIC_InitStructure.NVIC_IRQChannel=TIM2_IRQn;    NVIC_InitStructure.NVIC_IRQChannelCmd=ENABLE;    NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority=2;    NVIC_InitStructure.NVIC_IRQChannelSubPriority=1;    NVIC_Init(&amp;NVIC_InitStructure);     TIM_Cmd(TIM2,ENABLE);}void TIM2_IRQHandler(void){    if (TIM_GetITStatus(TIM2,TIM_IT_Update)==SET)    {        Num++;        TIM_ClearITPendingBit(TIM2,TIM_IT_Update);    }    }\n\n主程序 main.c\n#include \"stm32f10x.h\"                  // Device header#include \"OLED.h\"#include \"Timer.h\"uint16_t Num;int main(void){    OLED_Init();    TImer_Init();    OLED_ShowString(1,1,\"Num:\");        while(1)    {        OLED_ShowNum(2,1,Num,5);    }}\n\n应用2.定时器外部时钟面包板接线图：\n\n输出比较输出比较简介·OC（Output Compare） 输出比较可以通过比较CNT和CRR寄存器值的关系来输出电平进行置0、置1或反转的操作，用于输出一点频率和占空比的PWM波形·每个高级定时器和通用定时器都有4个输出比较通道·高级定时器的前三个通道额外拥有死区生成和互补输出的功能\nPWM简介PWM(Pluse Width Modulation)脉冲宽度调制在具有惯性的系统中，可通过对一系列脉冲的宽度进行调制来等效的获取需要的模拟参量，常用于电机控速等领域PWM参数：  频率=1/T_s  占空比=T_ON/T_s  分辨率=占空比变化步距\n输出比较通道下图是输出比较通道框图（高级和普通）\n\n为了控制电机，高级输出比较通道的OC1和OC1N需要输出互补的信号，在实际应用中可能会因为元件的不理想，导致出现上管未关闭下管就导通的现象，会导致功率损耗产生大量热，为防止该现象使用死区发生器，可以在一管关闭时延迟一段时间再导通另一管，避免同时导通。\n\n通过比较CNT和CCR可以使输出模式控制器输出高低电平，通过调节寄存器可以选择不同模式，模式表如下:\n\n\n\n模式\n描述\n\n\n\n冻结\nCNT=CCR时，REF保持为原状态\n\n\n匹配时置有效电平\nCNT=CCR时，REF置有效电平\n\n\n匹配时置有效电平\nCNT=CCR时，REF置无效电平\n\n\n匹配时电平翻转\nCNT=CCR时，REF电平翻转\n\n\n强制为无效电平\nCNT与CCR无效，REF强制为无效电平\n\n\n强制为有效电平\nCNT与CCR无效，REF强制为有效电平\n\n\nPWM模式1\n向上计数：CNT&lt;CCR时，REF置有效电平，CNT≥CCR时，REF置无效电平   向下计数：CNT&gt;CCR时，REF置无效电平，CNT≤CCR时，REF置有效电平\n\n\nPWM模式2\n向上计数：CNT&lt;CCR时，REF置无效电平，CNT≥CCR时，REF置有效电平   向下计数：CNT&gt;CCR时，REF置有效电平，CNT≤CCR时，REF置无效电平\n\n\n匹配时电平翻转模式可以平稳输出占空比为50%的信号，匹配时置有效电平和匹配时置有效电平相对不适合输出连续信号，比较适用于当你想要输出某一信号的情况\nPWM基本结构PWM基本结构框图：\n由图可以看出PWM的基本结构\nPWM参数计算\n\nPWM频率：  Freq = CK_PSC/(PSC+1)/(ARR+1)\nPWM占空比：Duty = CRR/(ARR+1)\nPWM分辨率：Reso = 1/(ARR+1)\n\n舵机简介舵机是一种根据输入PWM信号占空比来控制输出角度的装置\n输入PWM信号要求：周期为20ms，高电平宽度为0.5ms~2.5ms\n\n\n如图：舵机不是单纯的电机，而是由多个期间组成，大概逻辑就是PWM波给电板一个指定角度，判断当前角度，大则反转小则正转\n\n↑根据该图可以得到输入信号脉冲宽度对应的舵机输出角度\n\n在上面图片蓝色舵机的三个引线中，棕色是GND，红色是电源，黄色是信号线，不同型号的舵机可以参考元件的说明书\n\n给舵机供电时需要看电源是否达标\n直流电机及驱动直流电机是一种将电能转换为机械能的装置，有两个电极，当电极正接时，电机正转，当电极反接时，电机反转\n\n直流电机属于大功率器件，GPIO口无法直接驱动，需要配合电机驱动电路来操作\nTB6612是一款双路H桥型的直流电机驱动芯片，可以驱动两个直流电机并且控制其转速和方向\n\n\n\nVM是电机电源，需要一个能输出大电流的电源，VCC是逻辑电平输入，需要和控制器电压相同AO和BO是电机输出，PWMA，AIN1，AIN2是AO1/2对应的控制，其中PWMA接PWM信号输出端。STBY是待机控制，接地待机，接VCC启动，需要时可以接GPIO控制详细见下表：\n应用3.PWM驱动LED呼吸灯面包板接线图：\n头文件 PWM.c:\n#include \"stm32f10x.h\"void PWM_Init(void){    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);    GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);    GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_15;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    TIM_InternalClockConfig(TIM2);    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;    TIM_TimeBaseInitStructure.TIM_Period=100-1;    TIM_TimeBaseInitStructure.TIM_Prescaler=7200-1;    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);    TIM_OCInitTypeDef TIM_OCInitStructure;    TIM_OCStructInit(&amp;TIM_OCInitStructure);    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;    TIM_OCInitStructure.TIM_Pulse = 0;    TIM_OC1Init(TIM2,&amp;TIM_OCInitStructure);    TIM_Cmd(TIM2,ENABLE);}void PWM_SetCompare1(uint16_t Compare){    TIM_SetCompare1(TIM2,Compare);}\n\n主程序 mian.c\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"PWM.h\"uint16_t i;int main(void){\tOLED_Init();    PWM_Init();    while(1)    {        for ( i = 0; i &lt; 100; i++)        {            PWM_SetCompare1(i);            Delay_ms(10);        }        for ( i = 0; i &lt; 100; i++)        {            PWM_SetCompare1(100-i);            Delay_ms(10);        }           }}\n总体步骤和51单片机呼吸灯相似\n应用4.PWM驱动电机面包板接线图：\n所有PWM通道输出信号跳变都是同步的，所以可以四个一起用\n头文件 PWM.c（有更改）\n#include \"stm32f10x.h\"void PWM_Init(void){    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM2,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    // RCC_APB2PeriphClockCmd(RCC_APB2Periph_AFIO,ENABLE);    // GPIO_PinRemapConfig(GPIO_PartialRemap1_TIM2,ENABLE);    // GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable,ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_AF_PP;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_1;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    TIM_InternalClockConfig(TIM2);    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;    TIM_TimeBaseInitStructure.TIM_Period=2000-1;    TIM_TimeBaseInitStructure.TIM_Prescaler=72-1;    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;    TIM_TimeBaseInit(TIM2,&amp;TIM_TimeBaseInitStructure);    TIM_OCInitTypeDef TIM_OCInitStructure;    TIM_OCStructInit(&amp;TIM_OCInitStructure);    TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1;    TIM_OCInitStructure.TIM_OCNPolarity = TIM_OCPolarity_High;    TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;    TIM_OCInitStructure.TIM_Pulse = 0;    TIM_OC2Init(TIM2,&amp;TIM_OCInitStructure);    TIM_Cmd(TIM2,ENABLE);}void PWM_SetCompare2(uint16_t Compare){    TIM_SetCompare2(TIM2,Compare);}\n\nServo.c:\n#include \"stm32f10x.h\"#include \"PWM.h\"void Servo_Init(void){    PWM_Init();}void Servo_SetAngle(float Angle){    PWM_SetCompare2(Angle/100*2000+500);}\n\n主程序 main.c:\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"Servo.h\"#include \"Key.h\"uint16_t KeyNum;float Angle=0;int main(void){\tOLED_Init();    Key_Init();    Servo_Init();    OLED_ShowString(1,1,\"Angle:\");    while(1)    {        OLED_ShowSignedNum(2,1,Angle,3);        KeyNum=Key_GetNum();        if (KeyNum==1)        {             Angle+=10;             if (Angle&gt;=90)             {                 Angle=0;             }             Servo_SetAngle(Angle);        }    }}\n\n应用5.PWM驱动直流电机面包板接线图：\n头文件Motor.c:\n#include \"stm32f10x.h\"#include \"PWM.h\"void Motor_Init(void){    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_Out_PP;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_4 | GPIO_Pin_5;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    PWM_Init();}void Motor_SetSpeed(int8_t Speed){    if (Speed &gt;= 0)    {        GPIO_SetBits(GPIOA,GPIO_Pin_4);        GPIO_ResetBits(GPIOA,GPIO_Pin_5);        PWM_SetCompare3(Speed);    }    else    {        GPIO_ResetBits(GPIOA,GPIO_Pin_4);        GPIO_SetBits(GPIOA,GPIO_Pin_5);        PWM_SetCompare3(-Speed);    }    }\n主程序mian.c:\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"Motor.h\"#include \"Key.h\"uint8_t KeyNum;int8_t Speed;int main(void){\tOLED_Init();    Motor_Init();    Key_Init();    OLED_ShowString(1,1,\"Speed:\");    Motor_SetSpeed(20);    while(1)    {        KeyNum=Key_GetNum();        if (KeyNum==1)        {            Speed+=20;            if (Speed&gt;100)            {                Speed=-100;            }          }        Motor_SetSpeed(Speed);        OLED_ShowNum(2,1,Speed,3);            }}\n\n若电机旋转方向和自己想要的不一致可以更改Motor.c里面的Motor_SetSpeed函数\n输入捕获IC(Input Compare)输入捕获模式下，当通道输入引脚出现指定电平跳变时，当前CNT的值将被锁存到CCR中，可用于测量PWM波形的频率、占空比、脉冲间隔、电平持续时间等参数\n每个高级定时器和通用定时器都拥有4个输入捕获通道\n可配置为PWMI模式，同时测量频率和占空比\n可配合主从触发模式，实现硬件全自动测量\n频率测量\n测频法：在闸门时间T内，对上升沿计次，得到N，则频率\n测频法适合高频\n测周法：两个上升沿内，以标准频率fc计次，得到N ，则频率\n测周法适合低频\n在上述的两种方法中，N越大，误差越大，在某个频率下测频法和测周法的N相同，此频率为中界频率\n中界频率：测频法与测周法误差相等的频率点\n输入捕获通道\n应用6.输入捕获模式测频率面包板接线图：\n头文件IC.c\n#include \"stm32f10x.h\"#include \"PWM.h\"void IC_Init(void){    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    TIM_InternalClockConfig(TIM3);    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;    TIM_TimeBaseInitStructure.TIM_Period=65536-1;    TIM_TimeBaseInitStructure.TIM_Prescaler=72-1;    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;    TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);    TIM_ICInitTypeDef TIM_ICInitStructure;    TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;    TIM_ICInitStructure.TIM_ICFilter=0xF;    TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;    TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;    TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;    TIM_ICInit(TIM3,&amp;TIM_ICInitStructure);    TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);    TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);    TIM_Cmd(TIM3,ENABLE);}uint32_t IC_GetFreq(void){    return 1000000/(TIM_GetCapture1(TIM3)+1);}\n\n主程序mian.c:\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"PWM.h\"#include \"IC.h\"uint16_t i;int main(void){\tOLED_Init();    PWM_Init();\tIC_Init();    OLED_ShowString(1,1,\"Freq:00000Hz\");    PWM_SetPrescaler(720-1);    PWM_SetCompare1(50);    while(1)    {        OLED_ShowNum(1,6,IC_GetFreq(),5);           }}\n\n应用7.PWMI模式测占空比面包板接线图：\n头文件：IC.c:\n#include \"stm32f10x.h\"#include \"PWM.h\"void IC_Init(void){    RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode=GPIO_Mode_IPU;    GPIO_InitStructure.GPIO_Pin=GPIO_Pin_6;    GPIO_InitStructure.GPIO_Speed=GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    TIM_InternalClockConfig(TIM3);    TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;    TIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;    TIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up;    TIM_TimeBaseInitStructure.TIM_Period=65536-1;    TIM_TimeBaseInitStructure.TIM_Prescaler=72-1;    TIM_TimeBaseInitStructure.TIM_RepetitionCounter=0;    TIM_TimeBaseInit(TIM3,&amp;TIM_TimeBaseInitStructure);    TIM_ICInitTypeDef TIM_ICInitStructure;    TIM_ICInitStructure.TIM_Channel=TIM_Channel_1;    TIM_ICInitStructure.TIM_ICFilter=0xF;    TIM_ICInitStructure.TIM_ICPolarity=TIM_ICPolarity_Rising;    TIM_ICInitStructure.TIM_ICPrescaler=TIM_ICPSC_DIV1;    TIM_ICInitStructure.TIM_ICSelection=TIM_ICSelection_DirectTI;    TIM_PWMIConfig(TIM3,&amp;TIM_ICInitStructure);    TIM_SelectInputTrigger(TIM3,TIM_TS_TI1FP1);    TIM_SelectSlaveMode(TIM3,TIM_SlaveMode_Reset);    TIM_Cmd(TIM3,ENABLE);}uint32_t IC_GetFreq(void){    return 1000000/(TIM_GetCapture1(TIM3)+1);}uint32_t IC_GetPuty(void){    return (TIM_GetCapture2(TIM3)+1)*100/(TIM_GetCapture1(TIM3)+1);}\n\n主程序mian.c\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"PWM.h\"#include \"IC.h\"uint16_t i;int main(void){\tOLED_Init();    PWM_Init();\tIC_Init();    OLED_ShowString(1,1,\"Freq:00000Hz\");    OLED_ShowString(2,1,\"Duty:000%\");    PWM_SetPrescaler(720-1);    PWM_SetCompare1(50);    while(1)    {        OLED_ShowNum(1,6,IC_GetFreq(),5);        OLED_ShowNum(2,6,IC_GetPuty(),3);    }}\n\n因为没有信号发生器，所以这里的信号由GPIOA_PIN0产生的PW吗波代替\n编码器接口编码器接口(Encoder Interface )可接收增量（正交）编码器的信号，根据编码器旋转产生的正交信号脉冲，自动控制CNT自增或自减，从而指示编码器的位置、旋转方向和旋转速度\n每个高级定时器和通用定时器都拥有1个编码器接口\n两个输入引脚借用了输入捕获的通道1和通道2\n正交编码器\n由图：在正转时A相提前B相90°，反转时A相滞后B相90°（具体哪个提前哪个滞后可以自己改）\n使用正交信号好处：\n\n更精确\n抗噪声\n\n编码器接口基本结构：\n工作模式：\n实例：\n通过调节IC1PF1可以使反向\n实例（反向）:\n应用8.编码器接口测速面包板接线图：\n头文件：Encoder.c\n#include \"stm32f10x.h\"                  // Device header/**  * 函    数：编码器初始化  * 参    数：无  * 返 回 值：无  */void Encoder_Init(void){\t/*开启时钟*/\tRCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);\t\t\t//开启TIM3的时钟\tRCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE);\t\t\t//开启GPIOA的时钟\t\t/*GPIO初始化*/\tGPIO_InitTypeDef GPIO_InitStructure;\tGPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;\tGPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7;\tGPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;\tGPIO_Init(GPIOA, &amp;GPIO_InitStructure);\t\t\t\t\t\t\t//将PA6和PA7引脚初始化为上拉输入\t\t/*时基单元初始化*/\tTIM_TimeBaseInitTypeDef TIM_TimeBaseInitStructure;\t\t\t\t//定义结构体变量\tTIM_TimeBaseInitStructure.TIM_ClockDivision = TIM_CKD_DIV1;     //时钟分频，选择不分频，此参数用于配置滤波器时钟，不影响时基单元功能\tTIM_TimeBaseInitStructure.TIM_CounterMode = TIM_CounterMode_Up; //计数器模式，选择向上计数\tTIM_TimeBaseInitStructure.TIM_Period = 65536 - 1;               //计数周期，即ARR的值\tTIM_TimeBaseInitStructure.TIM_Prescaler = 1 - 1;                //预分频器，即PSC的值\tTIM_TimeBaseInitStructure.TIM_RepetitionCounter = 0;            //重复计数器，高级定时器才会用到\tTIM_TimeBaseInit(TIM3, &amp;TIM_TimeBaseInitStructure);             //将结构体变量交给TIM_TimeBaseInit，配置TIM3的时基单元\t\t/*输入捕获初始化*/\tTIM_ICInitTypeDef TIM_ICInitStructure;\t\t\t\t\t\t\t//定义结构体变量\tTIM_ICStructInit(&amp;TIM_ICInitStructure);\t\t\t\t\t\t\t//结构体初始化，若结构体没有完整赋值\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//则最好执行此函数，给结构体所有成员都赋一个默认值\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//避免结构体初值不确定的问题\tTIM_ICInitStructure.TIM_Channel = TIM_Channel_1;\t\t\t\t//选择配置定时器通道1\tTIM_ICInitStructure.TIM_ICFilter = 0xF;\t\t\t\t\t\t\t//输入滤波器参数，可以过滤信号抖动\tTIM_ICInit(TIM3, &amp;TIM_ICInitStructure);\t\t\t\t\t\t\t//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道\tTIM_ICInitStructure.TIM_Channel = TIM_Channel_2;\t\t\t\t//选择配置定时器通道2\tTIM_ICInitStructure.TIM_ICFilter = 0xF;\t\t\t\t\t\t\t//输入滤波器参数，可以过滤信号抖动\tTIM_ICInit(TIM3, &amp;TIM_ICInitStructure);\t\t\t\t\t\t\t//将结构体变量交给TIM_ICInit，配置TIM3的输入捕获通道\t\t/*编码器接口配置*/\tTIM_EncoderInterfaceConfig(TIM3, TIM_EncoderMode_TI12, TIM_ICPolarity_Rising, TIM_ICPolarity_Rising);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//配置编码器模式以及两个输入通道是否反相\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//注意此时参数的Rising和Falling已经不代表上升沿和下降沿了，而是代表是否反相\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//此函数必须在输入捕获初始化之后进行，否则输入捕获的配置会覆盖此函数的部分配置\t\t/*TIM使能*/\tTIM_Cmd(TIM3, ENABLE);\t\t\t//使能TIM3，定时器开始运行}/**  * 函    数：获取编码器的增量值  * 参    数：无  * 返 回 值：自上此调用此函数后，编码器的增量值  */int16_t Encoder_Get(void){\t/*使用Temp变量作为中继，目的是返回CNT后将其清零*/\tint16_t Temp;\tTemp = TIM_GetCounter(TIM3);\tTIM_SetCounter(TIM3, 0);\treturn Temp;}\n\n主程序：main.c\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"Timer.h\"#include \"Encoder.h\"int16_t Speed;\t\t\t//定义速度变量int main(void){\t/*模块初始化*/\tOLED_Init();\t\t//OLED初始化\tTimer_Init();\t\t//定时器初始化\tEncoder_Init();\t\t//编码器初始化\t\t/*显示静态字符串*/\tOLED_ShowString(1, 1, \"Speed:\");\t\t//1行1列显示字符串Speed:\t\twhile (1)\t{\t\tOLED_ShowSignedNum(1, 7, Speed, 5);\t//不断刷新显示编码器测得的最新速度\t}}/**  * 函    数：TIM2中断函数  * 参    数：无  * 返 回 值：无  * 注意事项：此函数为中断函数，无需调用，中断触发后自动执行  *           函数名为预留的指定名称，可以从启动文件复制  *           请确保函数名正确，不能有任何差异，否则中断函数将不能进入  */void TIM2_IRQHandler(void){\tif (TIM_GetITStatus(TIM2, TIM_IT_Update) == SET)\t\t//判断是否是TIM2的更新事件触发的中断\t{\t\tSpeed = Encoder_Get();\t\t\t\t\t\t\t\t//每隔固定时间段读取一次编码器计数增量值，即为速度值\t\tTIM_ClearITPendingBit(TIM2, TIM_IT_Update);\t\t\t//清除TIM2更新事件的中断标志位\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//中断标志位必须清除\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t//否则中断将连续不断地触发，导致主程序卡死\t}}\n\nADC 数模转换器ADC（Analog-Digital Converter）模拟-数字转换器\nADC可以将引脚上连续变化的模拟电压转换为内存中存储的数字变量，建立模拟电路到数字电路的桥梁\n12位逐次逼近型ADC，1us转换时间\n输入电压范围：03.3V，转换结果范围：04095\n18个输入通道，可测量16个外部和2个内部信号源\n规则组和注入组两个转换单元\n模拟看门狗自动监测输入电压范围\nSTM32F103C8T6 ADC资源：ADC1、ADC2，10个外部输入通道\n逐次逼近型ADC\n通道选择开关八个通道都可输入，地址锁存和译码可选择输入的通道\nDAC输入的电压在比较器与通道进入的电压比较，逼近，直至大约相等，此时DAC电压等于输入电压，比较过程使用二分法\nCLOCK是时钟，START是输入信号，EOC是输出信号\nV_REF是参考电压\nADC框图\n左侧ADCx_IN是输入口，经过选择器进入模数转换器（原理类似于上面逐次逼近型ADC），输出数据保存在寄存器，可以读取\n在这个模型里，可以一次性选择多个通道，注入通道上限4个，规则通道上限16个\n规则通道只有一个寄存器，所以直接使用会导致前面的数据丢失，只有最后的数据，常配合DMA使用，DMA可以将前面的数据移至其他地方存储。\n为了减少对程序的影响，左下两个触发使用硬件触发，将TIM3设为TRGO，定时，就可以自动触发ADC转换，节省了触发资源\n右上角模拟看门狗，可以设置模拟阈值，当达到阈值的时候就会申请NVIC的ADC中断，同样，（注入）转换结束也能申请中断\n输入通道\nADC1和ADC2可分开使用，也可以一起使用\n转换模式单次转换非扫描模式\n把想要转换的通道放在序列1，转换后数据存放在数据寄存器，通识EOC置1\n连续转换非扫描模式\n连续转换不需要判断结束，需要数据直接读取\n单次转换扫描模式\n设置通道数目，每次只转换通道数目对应数目的，全部完成之后EOC置1\n连续转换扫描模式\n连续扫描\n触发控制\n数据对齐分为数据右对齐和数据左对齐，分别为左侧和右侧补0，右对齐比较常用\n转换时间AD转换的步骤：采样，保持，量化，编码\nSTM32 ADC的总转换时间为：    T_CONV = 采样时间 + 12.5个ADC周期\n例如：当ADCCLK=14MHz，采样时间为1.5个ADC周期    T_CONV = 1.5 + 12.5 = 14个ADC周期 = 1μs\n校准ADC有一个内置自校准模式。校准可大幅减小因内部电容器组的变化而造成的准精度误差。校准期间，在每个电容器上都会计算出一个误差修正码(数字值)，这个码用于消除在随后的转换中每个电容器上产生的误差\n建议在每次上电后执行一次校准\n启动校准前， ADC必须处于关电状态超过至少两个ADC时钟周期\n硬件电路\n应用1.AD单通道面包板接线图：\n\n头文件 AD.c:\n#include \"stm32f10x.h\"void AD_Init(void){    RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1,ENABLE);    RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA,ENABLE);    RCC_ADCCLKConfig(RCC_PCLK2_Div6);    GPIO_InitTypeDef GPIO_InitStructure;    GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;    GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;    GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;    GPIO_Init(GPIOA,&amp;GPIO_InitStructure);    ADC_RegularChannelConfig(ADC1,ADC_Channel_0,1,ADC_SampleTime_55Cycles5);    ADC_InitTypeDef ADC_InitStructure;    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;    ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;    ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None;    ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;    ADC_InitStructure.ADC_NbrOfChannel = 1;    ADC_InitStructure.ADC_ScanConvMode = DISABLE;    ADC_Init(ADC1,&amp;ADC_InitStructure);    ADC_Cmd(ADC1,ENABLE);    ADC_ResetCalibration(ADC1);    while(ADC_GetResetCalibrationStatus(ADC1) == SET);    ADC_StartCalibration(ADC1);    while(ADC_GetCalibrationStatus(ADC1) == SET);    ADC_SoftwareStartConvCmd(ADC1,ENABLE);}uint16_t AD_GetValue(void){        return ADC_GetConversionValue(ADC1);}\n上面程序配置的是连续模式，将init函数的最后一行移到getvalue函数的第一行并在后面加一行    while(ADC_GetFlagStatus(ADC1,ADC_FLAG_EOC) == RESET);并将    ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;改为DISABLE即可改成非连续模式。\n主程序 main.c:\n#include \"stm32f10x.h\"                  // Device header#include \"Delay.h\"#include \"OLED.h\"#include \"AD.h\"uint16_t ADVALUE;float Voltage;int main(void){\tOLED_Init();    AD_Init();    OLED_ShowString(1,1,\"ADVALUE:\");    OLED_ShowString(2,1,\"Voltage:\");    while(1)    {        ADVALUE = AD_GetValue();        Voltage = (float)ADVALUE/4095*3;        OLED_ShowNum(1,9,ADVALUE,4);        OLED_ShowNum(2,9,Voltage,1);        OLED_ShowNum(2,11,(uint16_t)(Voltage*100)%100,3);        OLED_ShowChar(2,10,'.');        Delay_ms(100);    }}\n\n应用2.AD多通道面包板接线图：\nDMADMA（Direct Memory Access）直接存储器存取DMA可以提供外设和存储器或者存储器和存储器之间的高速数据传输，无须CPU干预，节省了CPU的资源12个独立可配置的通道： DMA1（7个通道）， DMA2（5个通道）每个通道都支持软件触发和特定的硬件触发\nSTM32F103C8T6 DMA资源：DMA1（7个通道）\n存储器映像ROM：\n\n\n\n起始地址\n存储器\n用途\n\n\n\n0x0800 0000\n程序存储器Flash\n存储C语言编译后的程序代码\n\n\n0x1FFF F000\n系统存储器\n存储BootLoader，用于串口下载\n\n\n0x1FFF F800\n选项字节\n存储一些独立于程序代码的配置参数\n\n\n","categories":["note","article"],"tags":["SCM","hardware","note"]},{"title":"stm32笔记2（不定更新 ）","url":"/2024/02/01/stm32%E7%AC%94%E8%AE%B02%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/","content":"STM32学习笔记这个笔记是基于HAL库的，跟随正中电子教程学习。\n单片机简介特点体积小，功耗低，集成度高，使用方便，拓展灵活\nCoetex-MARM公司ARM只设计内核提供IP，不涉及芯片；\n\n\n\n对比项\nCortex-A\nCortex-B\nCortex-C\n\n\n\n特点\n高时钟频率，长流水线，高性能\n较高时钟频率，较长的流水线，实时性强\n时钟频率较低，通常较低的流水线，超低功耗\n\n\nCortex-M3&#x2F;4&#x2F;7 介绍\n\n\n类别\nCortex-M3\nCortex-M4\nCortex-M7\n\n\n\n核心版本\nARMv7-M\nARMv7E-M\nARMv7E-M\n\n\n指令系统\nThumb&#x2F;Thumb2\nThumb&#x2F;Thumb2\nThumb&#x2F;Thumb2\n\n\nDSP指令扩展\n无\n有\n有\n\n\n浮点单元\n无\n单精度浮点单元\n可选单&#x2F;双精度浮点单元\n\n\n流水线\n3级\n3级+分支预测\n6级+分支预测\n\n\n中断\nNVIC，NMI+1~256个中断优先级\nNVIC，NMI+1~256个中断优先级\nNVIC，NMI+1~256个中断优先级\n\n\n系统定时器\n24位系统滴答定时器\n24位系统滴答定时器\n24位系统滴答定时器\n\n\n睡眠模式\n集成WFI和WFE指令及退出睡眠功能\n集成WFI和WFE指令及退出睡眠功能\n集成WFI和WFE指令及退出睡眠功能\n\n\n调试\n可选JTAG和SWD调试接口\n可选JTAG和SWD调试接口\n可选JTAG和SWD调试接口\n\n\n内存保护\n可选8个区域MPU\n可选8个区域MPU\n可选8&#x2F;16个区域MPU\n\n\nDPIMS&#x2F;Mhz\n1.25\n1.25\n2.14\n\n\nCoreMark®Mhz\n3.34\n3.43\n5.01\n\n\n初识STM32STM32 ST指意法半导体，M指MCU&#x2F;MPU，32指32位\nSTM32命名规则以STM32F051R8T6xxx为例：\nSTM32：家族（32位MCU&#x2F;MPU）\nF：产品类型（基础型）\n051：特定功能（3位数字）\nR：引脚数（64&amp;66）\n8：闪存容量（64Kbytes）\nT:封装：（QFP）\n6：温度范围（-40~+85）\nx：固件版税\nxx：选项\nSTM引脚分布规则小圆点放置左下角，圆点下第一个是1脚，逆时针依次为1.2.3……\n芯片背面小三角对应的是小圆点的位置。\n小圆点左侧从下向上依次是1-17，下侧左到右依次是A-Q，根据表可以找到对应内容\n最小系统：保证MCU正常工作的最小电路组成单元\nSTM32复位引脚NRST保持低电平状态1~4.5ms即可复位（按键复位）\nIO口微调：当IO不够用的时候，通用GPIO和特定外设·可能要公用IO口；为方便布线，可能要调整某些IO口的位置。\nSTM32引脚类型\n电源引脚（V开头）\n晶振引脚（8、9，23、24）\n复位引脚（25）\n下载引脚下载接口分为三类： 1.JTAG（PA15、PA14、PA13、PB4、PB3、VDD、GND） 2.SWD（PA14、PA13、VDD、GND）（占的少，可调式，推荐） 3.串口（PA9、PA10、VDD、GND）（不可调试）SWD：A13SWDIO输入&#x2F;输出；A14SWCLK时钟JTAG：A13JTMS模式选择；A14JTCK时钟；A15JTDI输入；B3JTDO输出；B4TNTRST输入\nBOOT引脚\nGPIO引脚\n\n软件及驱动安装MDK和器件支持包安装步骤：\n\n安装MDK\n安装器件支持包\n拷贝下载算法到Flash文件夹，如：C:\\MDK5.34\\ARM|Flash\n购买授权并注册我选择破解\n\n注：安装目录及路径不要汉字且越短越好，电脑系统名和用户名最好不要中文\n安装仿真器驱动\n\n\n安装CH340 USB虚拟串口驱动打开exe直接点击安装即可，安装完成后，连接开发板，在设备管理器-&gt;端口可以找到对应设备\n为什么要安装：可以使用通信协议\nUSB虚拟串口作用：\n\n当串口使用\n如果连接串口1，还可以用来下载程序\n当USB供电口\n\nSTM32初体验使用MDK5编译历程部分编译和全局编译：时按两个效果相同，后续编译中，部分编译只编译当前文件\n编译结果分析：\n\n\n\n数据类型\n占用Flash&#x2F;SRAM\n说明\n\n\n\nCode\nFlash\n代码\n\n\nRO-Data\nFlash\n只读数据，一般是指const修饰的数据\n\n\nRW-Data\nFlash&amp;SRAM\n初值为非0的可读可写数据\n\n\nZI-Data\nSRAM\n初值为0的可读可写数据\n\n\n串口下载程序下载须知\nM3、M4、M7支持串口下载程序但是ATK-XIPS.exe(正点研发的下载软件)只支持下载到内部Flash\nSTM32的ISP下载常用串口1下载程序\n使用USB虚拟串口需事先下载驱动\n\n硬件连接PC(USB)-&gt;USB&#x2F;串口转换电路-&gt;TTL\nATK-XISP.exe下载工具配置\n搜索选择CH340虚拟的串口，然后设置波特率 注：不同芯片内部的波特率可能不同，下载不了时可以调整波特率\n选择需要下载的hex文件\n勾选“编程后运行”、“校验”、“编程前执行全片擦除”\n选择“DTR低电平复位，RTS高电平进BootLoader”\n“开始编程”\n\nSTM32启动模式（M3和M4）通过BOOT0和BOOT1引脚设置启动模式（M3和M4）\nBOOT1：X，BOOT0：0  ： 主闪存存储模式BOOT1：0，BOOT0：1  ： 系统存储器BOOT1：1，BOOT0：1  ： 内置SRAM\n注：自举模式只支持引脚1（USART1）进行控制 \nISP下载步骤：    1.BOOT0接高电平，BOOT1接低电平    2.按复位键\n程序执行一般步骤：    1.BOOT0接低电平，BOOT1接任意    2.按复位\n（分别对应上面系统储存和主闪存存储模式）\n仿真调试依靠软件，这里暂不演示\n\nC语言知识点补充位操作\n\n\n运算符\n含义\n\n\n\n&amp;\n按位与\n\n\n\n\n\n\n^\n按位异或（相同取0相异取1）\n\n\n~\n按位取反\n\n\n&lt;&lt;\n左移\n\n\n&gt;&gt;\n右移\n\n\n左移移除的部分不要，补充的部分写0；右移移除的部分不要，若为正数补充的部分补0，负数则补1\n宏定义例：#define LED1 0x01\n#define LED(x) do&#123;x?\\    HAL_GPIO_WritePin(LED1_GPIO_PORT,LED_GPIO_PIN,GPIO_PIN_SET):\\    HAL_GPIO_WritePin(LED1_GPIO_PORT,LED_GPIO_PIN,GPIO_PIN_RESET):\\&#125;while(0)\n\n建议使用do{…}while(0)来构造宏定义，这样不会受大括号分号运算优先级等的影响\n条件编译\n\n\n指令\n作用\n\n\n\n#if\n编译预处理条件指令，类似if\n\n\n#ifdef\n判断某个宏是否被定义\n\n\n#ifndef\n判断某个宏是否没有被定义\n\n\n#elif\n若前面条件不满足则判断新的条件，类似于else if\n\n\n#else\n若前面条件不满足则执行后面的语句，类似于else\n\n\n#endif\n#if,#ifdef,#ifndef的结束标志\n\n\nextern声明放在函数&#x2F;变量前，可以在所有文件中找到并使用\n类型别名（typedef）为现有的数据类型创建一个新的名字\n结构为; typedef 现有类型 新名字\ne.p. typedef unsigned char          uint8_t\n类型别名应用（Struct）正常情况下：\nstruct GPIO_TypeDef&#123;    __IO uint32_t CRL;    __IO uint32_t CHR;    …&#125;;struct GPIO_TypeDef gpiox\n使用typedef：\ntypedef struct&#123;    __IO uint32_t CRL;    __IO uint32_t CHR;    …&#125;GPIO_TypeDef;GPIO_TypeDef gpiox\n\n结构体由若干基本数据类型集合组成的一种自定义数据类型，也叫聚合体\ne.p.定义：\nstruct student&#123;    char *name;    int num;    int age;    char group;    float score;&#125;stu1,st2;\n\n应用：\nstruct student stu3,stu4;stu3.name=&quot;Trump&quot;;stu3.age=114;\n\n指针指针即内存的地址，指针变量就是保存了指针的变量\n结构：类型名 *指针变量名\ne.p.:char *p_str = &quot;Test&quot;;\n*p_str：取p_str变量的值&amp;p_str：取p_str变量的地址\n指针使用的问题：\n\n未分配（申请）内存就使用\n越界使用\n\nSTM基础知识STM32系统框架F1系统框架4个主动单元+4个被动单元\n\n\n\n主动单元\n被动单元\n\n\n\nCortex M3内核 DCode总线(D-Bus)\n内部FLASH\n\n\nCortex M3内核 系统总线 (S-Bus)\n内部SRAM\n\n\n通用DMA1\nFSMC\n\n\n通用DMA2\nAHB到APB的桥，他链接所有APB外设\n\n\nAHB：高级高性能总线APB：高级外围总线\n再互联型产品中有3个被动5个主动\nSTM32选址范围STM32寻址大小：2^32&#x3D;4G（字节）STM32寻址范围：0x0000 0000~0xFFFF FFFF\n存储器映射存储器是可以存储数据的设备，本身无地址信息，对存储器分配地址的过程称为存储器映射\n存储器功能划分（F1为例）ST将4GB（2^32）地址空间分成8块\n\n\n\n存储块\n功能\n地址范围\n\n\n\nBlock0\nCode(FLASH)\n0x0000 0000 ~ 0x1FFF FFFF(512MB)\n\n\nBlock1\nSRAM\n0x2000 0000 ~ 0x3FFF FFFF(512MB)\n\n\nBlock2\n片上外设\n0x4000 0000 ~ 0x5FFF FFFF(512MB)\n\n\nBlock3\nFSMC Blank1&amp;2\n0x6000 0000 ~ 0x7FFF FFFF(512MB)\n\n\nBlock4\nFSMC Blanc3&amp;4\n0x8000 0000 ~ 0x9FFF FFFF(512MB)\n\n\nBlock5\nFSMC寄存器\n0xA000 0000 ~ 0xBFFF FFFF(512MB)\n\n\nBlock6\n没用到\n0xC000 0000 ~ 0xDFFF FFFF(512MB)\n\n\nBlock7\nCortex M3内部外设\n0xE000 0000 ~ 0xFFFF FFFF(512MB)\n\n\nBlock0（FLASH）功能划分：\n\n\n功能\n地址范围\n\n\n\nFLASH或系统存储器别名区\n0x0000 0000~0x0007 FFFF(512KB)\n\n\n保留\n0x0008 0000~0x07FF FFFF\n\n\n用户FLASH，用于存储用户代码\n0x0800 0000~0x0807 FFFF(521KB)\n\n\n保留\n0x0808 0000~0x1FFF EFFF\n\n\n系统存储器，存储出厂Bootloader\n0x1FFF F000~0x1FFF F7FF(2KB)\n\n\n选项字节，配置读保护等\n0x1FFF F800~0x1FFF F80F(16B)\n\n\n保留\n0x1FFF F810~0x1FFF FFFF\n\n\nBlock1(SRAM)功能划分\n\n\n功能\n地址范围\n\n\n\nSRAM\n0x2000 0000~0x2000 FFFF(64KB)\n\n\n保留\n0x2001 0000~0x3FFF FFFF\n\n\nBlock2(外设)功能划分\n\n\n功能\n地址范围\n\n\n\nAPB1总线外设\n0x4000 0000~0x4000 77FF\n\n\n保留\n0x4000 7800~0x4000 FFFF\n\n\nAPB2总线外设\n0x4001 0000~0x4000 3FFF\n\n\n保留\n0x4001 4000~0x4001 7FFF\n\n\nAHB总线外设\n0x4001 8000~0x4002 33FF\n\n\n保留\n0x4002 3400~0x5FFF FFFF\n\n\n寄存器寄存器是单片机内部一种特殊的内存，可以实现对单片机各功能的控制\nSTM32寄存器分类内核寄存器：内核相关寄存器，中断寄存器，Sys Tick寄存器，内存保护寄存器，调试系统寄存器外设寄存器：UART、IIC、SPI等\n寄存器映射给寄存器命名的过程叫做寄存器映射\n例：0x4001080C–映射–&gt;GPIOA_ODR\n直接映射：*(unsigned int*)(0x4001 080C) = 0xFFFF;\n定义名字之后映射：\n#define GPIOA_ODR   *(unsigned int*)(0x4001080C)GPIOA_ODR = 0xFFFF;\n\n寄存器描述解读要点：\n\n寄存器名字\n偏移量及复位值\n寄存器位表\n位功能描述\n\n寄存器地址计算为方便编写代码及使用，我们将寄存器地址分为三部分\n\n总线基地址(BUS_BASE_ADDR)\n外设基于总线基地址的偏移量(PERIPH_OFFSET)\n寄存器相对外设基地址的偏移量(REG_OFFSET)\n\n寄存器地址&#x3D;BUS_BASE_ADDR + PERIPH_OFFSET + REG_OFFSET\n总线基地址\n\n\n总线\n基地址\n偏移量\n\n\n\nAPB1\n0x4000 0000\n0\n\n\nAPB2\n0x4001 0000\n0x1 0000\n\n\nAHB\n0x4001 8000\n0x1 8000\n\n\nAPB1总线的基地址也叫做外设基地址(PERIPH_BASE)此表的偏移量是相对外设基地址来说的\nGPIO基地址及偏移量\n\n\n外设\n基地址\n偏移量\n\n\n\nGPIOA\n0x4001 0800\n0x800\n\n\nGPIOB\n0x4001 0C00\n0xC00\n\n\nGPIOC\n0x4001 1000\n0x1000\n\n\nGPIOD\n0x4001 1400\n0x1400\n\n\nGPIOE\n0x4001 1800\n0x1800\n\n\nGPIOF\n0x4001 1C00\n0x1C00\n\n\nGPIOG\n0x4001 2000\n0x2000\n\n\n此表的偏移量是相对与APB2外设基地址(APB2PERIPH_BASE)来说的\nGPIOA外设基地址及偏移量\n\n\n寄存器\n地址\n偏移量\n\n\n\nGPIOA_CRL\n0X4001 0800\n0X00\n\n\nGPIOA_CRH\n0X4001 0804\n0X04\n\n\nGPIOA_IDR\n0X4001 0808\n0X08\n\n\nGPIOA_ODR\n0X4001 080C\n0X0C\n\n\nGPIOA_BSRR\n0X4001 0810\n0X10\n\n\nGPIOA_BRR\n0X4001 0814\n0X14\n\n\nGPIOA_LCKR\n0X4001 0818\n0X18\n\n\n此表的偏移量是相对与GPIOA外设基地址(GPIO_BASE)来说的\n寄存器地址计算举例（GPIOA_ODR）：\n\n获取外设挂载在那个总线（查系统结构图）\n获取总线基地址，APB2总线基地址：0x4001 0000\n获取外设偏移量，GPIOA相对APB2总线偏移量：0x800\n获取寄存器地址偏移量，ORD相对GPIOA外设基地址偏移量是0x0C\n\n寄存器地址&#x3D;BUS_BASE_ADDR + PERIPH_OFFSET + REG_OFFSETGPIOA_ODR&#x3D;0X4001 0000 +0X800 + 0X0C &#x3D; 0X4001 080C\n利用结构体，我们可以很方便的完成对寄存器的映射\ntypedef struct&#123;    __IO uint32_t CRL;    __IO uint32_t CRH;    __IO uint32_t IDR;    __IO uint32_t ODR;    __IO uint32_t BSRR;    __IO uint32_t BRR;    __IO uint32_t LCKR;&#125;GPIO_TypeDef;\n注：GPIOA_BASE: 0x4001 0800\n由上面内容知道，GPIOA内每个寄存器偏移量都是0x04，uint_32大小刚好为0x04，能很好适配，利用这种方法可以方便的一次性配置一整个GPIO口\n#define GPIOA ((GPIO_TypeDef*)GPIOA_BASE)\n通过这个代码就可以一次性配置完整个GPIOA\n此时：&amp;GPIOA-&gt;CRL: 0x4001 0800&amp;GPIOA_CRH: 0x4001 0804……\n配置完之后实际应用只需要GPIOA-&gt;ODR = 0xFFFF就完成对GPIOA下的ODR的写入\n新建寄存器MDK版本新建工程前的准备工作\n下载相关STM32Cube官方固件包\n搭建开发环境\n\n新建寄存器版本MDK工程步骤\n新建工程文件夹 D&#x2F;M&#x2F;O&#x2F;P&#x2F;U文件夹，5个文件夹\n新建一个工程框架 工程命名，选芯片\n添加文件 建分组，添加.s&#x2F;.c\n魔术棒设置 T&#x2F;O&#x2F;L&#x2F;D&#x2F;C&#x2F;U，6个选项卡\n添加mian.c并编写代码 编写自己的代码\n\n\n\n\n文件夹名称\n作用\n\n\n\nDrivers\n存放和硬件相关的驱动层文件\n\n\nMiddlewares\n存放正点提供的中间层组件文件和第三方中间层文件\n\n\nOutput\n存放工程编译输出文件\n\n\nProjects\n存放MDK文件\n\n\nUsers\n存放HAL库用户配置文件、mian.c、中断文件，以及分散加载文件\n\n\n新建工程时要选择启动文件，其选择依据芯片类型，具体见下表\n\n\n\n缩写\n释义\nFlash容量\n型号\n\n\n\nDL_VL\n小容量产品超值系列\n16-32K\nSTM32F100\n\n\nMD_VL\n中容量产品超值系列\n64-128K\nSTM32F100\n\n\nHD_VL\n大容量产品超值系列\n256-512K\nSTM32F100\n\n\nLD\n小容量产品\n16-32K\nSTM32F101&#x2F;102&#x2F;103\n\n\nMD\n中容量产品\n64-128K\nSTM32F101&#x2F;102&#x2F;103\n\n\nHL\n大容量产品\n256-512K\nSTM32F101&#x2F;102&#x2F;103\n\n\nXL\n加大容量产品\n大于512K\nSTM32F101&#x2F;102&#x2F;103\n\n\nCL\n互联型产品\n-\nSTM32F105&#x2F;107\n\n\nstartup.stm32f103.s中有部分代码需要修改，按正点文件修改\n魔术棒设置\n\nTarget选项卡 设置使用的编译器版本、外部晶振频率\nOutput选项卡 设置Objects输出文件夹、生成.hex文件、输出浏览信息\nListing选项卡 设置Listing输出文件夹\nC&#x2F;C++选项卡 设置全局宏定义、优化等级、C99 Mode、设置头文件包含路径\nDebug选项卡 设置使用的仿真器类型、选择下载接口等\nUtilities选项卡 设置下载功能、下载算法起始地址和算法等\nLinker选项卡（可选） 添加分散加载文件（北极星&#x2F;MiniPro H750等）\n\n认识HAL库ST提供了三种库：标准外设库、HAL库、LL库\n直接操作寄存器：执行效率高、时间成本高标准库：只兼容F0&#x2F;F1&#x2F;F3&#x2F;F4&#x2F;L1，目前停止维护HAL库：全系列兼容、ST主推的库、兼容性、易移植性、效率低LL库：全系列兼容，与HAL库捆绑发布，轻量级、效率高，不匹配复杂外设\nSTM32固件包\n\n\nDocumentation\nDrivers\nMiddleware\nProject\nUtilities\nLisence.md\npackage.xml\nReadme.md\nRelease_Notes.html\n\n\n\n说明文档\n驱动源码\n中间文件\nST官方开发板案例教程\n公共组件\n软件版本信息\n固件包版本信息\n自述\n补充或更新说明\n\n\n如何使用HAL库基于CMSIS应用的程序文件描述\nSTM32开发文件结构分布图\nHAL库用户配置文件（stm32f1xx_hl_conf.h）\n裁剪HAL库外设驱动源码（不进行编译）\n\n仅包含使用到的文件\n屏蔽不使用的宏的定义\n\n\n设置外部高速晶振频率（根据实际情况）\n\n设置外部低速晶振频率（根据实际情况）\n\n\nHAL库使用注意事项\n使用HAL库出现问题还得通过参考实验手册检查是否有硬件操作问题\n尽量不通过修改库源码实现功能，这样不方便库更新\nHAL库可能会存在错误\n有些HAL库API函数执行效率不高，我们可能会通过操作寄存器来直接替代\n\n新建HAL库版本MDK工程\n新建工程前的准备工作\n新建HAL库版本MDK工程步骤\n下载验证\n\n新建HAL库版本MDK工程步骤步骤\n新建工程文件夹 D&#x2F;M&#x2F;O&#x2F;P&#x2F;U文件夹，5个文件夹\n新建一个工程框架 工程命名，选芯片\n添加文件 建分组，添加.s&#x2F;.c\n魔术棒设置 T&#x2F;O&#x2F;L&#x2F;D&#x2F;C&#x2F;U，6个选项卡\n添加mian.c并编写代码 编写自己的代码\n\n新建工程文件夹\n\n\n文件夹名称\n作用\n\n\n\nDrivers\n存放和硬件相关的驱动层文件\n\n\nMiddlewares\n存放正点提供的中间层组件文件和第三方中间层文件\n\n\nOutput\n存放工程编译输出文件\n\n\nProjects\n存放MDK文件\n\n\nUsers\n存放HAL库用户配置文件、mian.c、中断文件，以及分散加载文件\n\n\nDrivers文件夹：\n\n\n\n文件夹名称\n作用\n\n\n\nBSP\n存放开发板级支持包驱动代码，如各种外设驱动\n\n\nCMSIS\n存放CMSIS底层代码，如启动文件（.s文件）等\n\n\nSYSTEM\n存放正点原子系统级核心驱动代码，如sys.c、delay.c和usart.c等\n\n\nSTM32F1xx_HAL_Drivers\n存放ST提供的F1系列HAL库驱动代码\n\n\n新建一个工程框架\n新建工程\n保存工程\n选择主控型号\n删除文件夹\n\n\n\n\n文件夹\n作用\n\n\n\nDebugConfig\n用于存放调试设置的信息文件(.debconf)，不可删除\n\n\nListings\n用于存放编译过程产生的链接列表等文件\n\n\nObjects\n用于存放编译过程产生的调试信息、.hex、预览、.lib文件等\n\n\n添加文件\n设置工程名和分组名\n添加启动文件\n添加User源码\n添加SYSTEM源码\n添加STM32F1xx_HAL_Driver源码\n\n魔术棒设置\nTarget选项卡 设置使用的编译器版本、外部晶振频率\nOutput选项卡 设置Objects输出文件夹、生成.hex文件、输出浏览信息\nListing选项卡 设置Listing输出文件夹\nC&#x2F;C++选项卡 设置全局宏定义、优化等级、C99 Mode、设置头文件包含路径\nDebug选项卡 设置使用的仿真器类型、选择下载接口等\nUtilities选项卡 设置下载功能、下载算法起始地址和算法等\nLinker选项卡（可选） 添加分散加载文件（北极星&#x2F;MiniPro H750等）\n\nMAP文件浅析MAP文件浅析\n\n\n文件类型\n简介\n\n\n\n.o\n可重定向对象文件，每个.c&#x2F;.s文件都对应一个.o文件\n\n\n.axf\n可执行对象文件，由.o文件连接成，仿真时需要用到此文件\n\n\n.hex\nINTEL Hex格式文件，用于下载到MCU运行，由.axf转换而来\n\n\n.map\n连接器生成的列表文件，对分析程序存储占用情况非常有用\n\n\n其他\n.ctf&#x2F;.d&#x2F;.dep&#x2F;.lnp&#x2F;.lst&#x2F;.build_log.thml等一般用不到的\n\n\nMAP文件是MDK编译代码后，产生的集程序、数据及IO空间的一种映射列表文件简单说就是包括了：各种.c文件、函数、符号等的地址、大小、引用关系等信息分析各.c文件占用FLASH 和 RAM的大小，方便优化代码\nMAP文件组成：\n\n\n\n组成部分\n简介\n\n\n\n程序段交叉引用关系\n描述各文件之间函数调用关系\n\n\n删除映像未使用的程序段\n描述工程中未使用到而被删除的冗余程序段\n\n\n映像符号表\n描述各符号（程序段&#x2F;数据）在存储器中的地址、类型、大小等\n\n\n映像内存分布图\n描述各个程序段（函数）在存储器中的地址及占用大小\n\n\n映像组件大小\n给出整个映像代码（.o）占用空间汇总信息\n\n\nSTM32启动模式STM32启动模式（也称自举模式）M3&#x2F;M4&#x2F;M7等内核复位之后做的第一件事：\n\n从地址0x0000 0000处去除堆栈指针MSP的初始值，该值就是栈顶地址\n从地址0x0000 0004处去除程序计数器指针PC的初始值，该值是复位向量\n\nF1在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存\n\n无法下载程序解决方案：BOOT0接3.3V，按复位，然后在下载\nF4在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存\n\n如果要使用FSMC重映射到外部的SRAM，可以通过配置SYSCFG_MEMRMP寄存器无法下载程序解决方案：BOOT0接3.3V，按复位，然后在下载\nF7在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存\n\nH7在系统复位后，SYSCLK的第4个上升沿，BOOT引脚的值将被锁存\n\nSTM32启动过程（内部Flash启动为例）启动文件介绍\n初始化MSP 从0x0800 0000获取\n初始化PC 从0x0800 0004获取\n设置堆栈大小 Heap_Size(堆)、Stack_Size(栈)\n初始化中断向量表 __Vectors定义\n调用初始化函数 可选，如调用：SysTeminitg函数\n调用__main 标准C库函数，执行一系列设置，最后调用main函数\n\nReset_Handler函数介绍Reset_Handler   PROC                EXPORT  Reset_Handler   [WEAK]                IMPORT  __main                IMPORT  SystemInit                LDR   R0, =SystemInit                BLX   R0                               LDR   R0, =__main                BX      R0                ENDP\n\nEXPORT：标明全局属性，可被外部调用IMPORT：申明来自外部文件，类externPROC：定义子程序ENDP：表示子程序结束WEAK：弱定义\n堆栈简介栈（Stack） ： 编译器自带分配和释放，存放函数参数、局部变量等堆（Heap） ： 程序员分配和释放，如malloc、calloc、realloc等\nSTM32启动过程图解\n","categories":["note","article"],"tags":["SCM","hardware","note"]}]