[{"title":"Arduino学习日志","url":"/2023/11/22/arduino%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/","content":"Arduino学习日志前言这篇文章是我个人在Arduino学习上所做的笔记，arduino的学习是为了未来32单片机以及51单片机的学习作提前适应\n由于受限于图片上传我仅会在这篇笔记展示代码的内容，硬件部分我会尝试在一些其他的平台展示（也许会做一个微信公众号）\n叠甲：这篇文章可能存在一些错误，如果您发现了，请在评论区为我留言，我将很快改正\n部分省略由于arduino的一些语法是和C&#x2F;C++有相似之处，所以语法基础这篇笔记掠过不踢\n串口通讯串口通讯是传输数据的一种方式，所有arduino控制器都有至少一个串行端口（UART）。串口通讯主要由RX（receice接受）、TX（transport发送）、GND（ground接地）三个接口组成，控制器可以据此与其他单片机、传感器、计算机进行通讯\n个人计算机可以使用USB接口与arduino的引脚0（RX）和引脚1（TX）进行串口通讯\n优点：·发展时间长，技能成熟可靠     ·兼容性好、很多电子设备支持串口     ·使用方便，实现简单\n相关函数Serial.begin(speed)：初始化串口数据，打开串口通讯，并设置传输速率    · 参数 spped：波特率,设定的波特率需要和IDE上的波特率相同，否则会出错\nSerial.available()：用于检测控制器是否接到数据。返回值为等待读取的数据字节\nSerial.print(val,format)：串口输函数，发送ASCII码型数据，被发送的数据可以使任何格式    ·参数 format：可为BIN（二进制）DEC（十进制）HEX（十六进制）OCT（八进制）例：Serial.print(“Passenger”)-&gt;输出Passenger    Serial.print(23,BIN)-&gt;输出：0001 1001\nSerial.println(val,format)：在Serial.print()的基础上换个行\nSerial.write(val)：串口输出函数，发送单个字节或字符串    · val&#x3D;65时输出A（val为数字时会根据ASCII码发送字符）\nSerial.read()：串口读取函数，每次读取一个字节    · 没收到时返回-1    · 收到时返回值为接收到的数据流中的一个字符\nSerial.parselnt()：串口数据解析函数，用来读取所接收到的数据中的整数，从数据中第一个数字读取到连续的最后一个数字。可以重复使用。\nparselnt()读取数据时，会忽略字母并提取数字，每次读取后，数字之前的数据和数字本身会从缓存区删除，其他数据保持不变\n\nSerial.parseFloat()：串口数据解析函数，用来读取数据中的小数。 \n","categories":["note","article"],"tags":["SCM","code","hardware","note"]},{"title":"Linux学习日志","url":"/2023/11/10/Linux%E5%AD%A6%E4%B9%A0%E6%97%A5%E5%BF%97/","content":"前言Linux是一个免费、开源、可靠、安全、稳定、多平台的操作系统内核，这篇文章将随着我的学习进程不断更新用于作为笔记。\n\n一些小知识（快捷键· Ctrl+L：清空终端\n小知识（没啥用也许· 使用ls查看目录下内容时，深色的为文件夹，浅色的为文件；使用ls -l时，最前面为d（directory）的是文件夹，为-的是文件\n· 使用su -root然后输入用户密码，获得最大权限（切换root用户）\n通配符“*”通配符“*”，用来做模糊匹配\n通配符，即匹配任意内容（包括空），例：· test* 表示匹配任何以test开头的内容· *test 表示匹配任何以test结尾的内容· test 表示任何包含test的内容\n管道符“|”管道符“|”，把管道符左侧输出的结果作为右边的输入\n左侧可以是任何有输出的命令，右侧只能是有可作为内容输入端口参数的命令\n例：cat test.txt | grep pessenger\n原本上面grep命令应该为grep pessenger 筛选内容，但是grep命令的筛选内容参数可作为内容输入端口，所以在使用管道符时可以省略，将管道符之前内容作为参数输入\n注：管道符可以嵌套使用，比如：cat test.txt | grep pessenger | grep D\n即：cat test.txt的输出（输出内容1）作为参数进行grep pessenger 输出内容1,得到输出内容2，在输入输出内容2进行命令grep D 输出内容2得出最后我们看到的输出内容\n反引号“&#96;”（又称飘号）用反引号包围的命令不会被作为参数，而是将命令输出的内容作为参数输入\n例：echo pwd输出结果为pwd，而echo &quot;pwd&quot;输出内容是当前目录位置\n重定向符“&gt;”和“&gt;&gt;”&gt;将左侧命令的结果覆盖写入到符号右侧指定的文件中\n例：eacho &quot;Hello Linux&quot; &gt; test.txt-&gt;test.txt内容为“Hello Linux”\n&gt;&gt;将左侧命令的结果追加写入到符号右侧的指定文件中\n例：echo &quot;Hello Linux&quot; &gt;&gt; test.txt-&gt;test.txt最后多一行“Hello Linux”\n\n命令行操作命令结构Linux的命令结构大致为：[commend] [-option] [parameter]\n其中：· commend 指的是命令本身，比如：ls、cd等· -option 指的是命令的一些选项，可以通过这个来选择控制命令的行为细节· parameter 指的是命令的参数，用于命令的指向目标\n注：[-0ption]和[parameter]是可选的而不是必须的\n命令表lsls命令的作用是列出目录下的内容，细节如下：\nls [-a -l -h] [Linux路径]\n前置小知识：·Home目录：每一个用户在Linux系统的专属目录默认在:/home/用户名·当前工作目录： Linux在执行命令的时候往往需要一个工作目录来打开命令程序（终端），默认设置工作目录在用户的home目录\n选项-a选项-a选项 表示“all”，即列出所有文件（包括隐藏的）\n显示的文件里面开头是 “.” 的就是隐藏的文件\n-l选择-l选项 以纵向的形式展示内容，并展示更多内容\n-h选择-h选项 可以更好的展示内存，但是只能和 -l 一起使用\n组合使用可以选择分别使用选项，比如 ls -l -a -h，也可以组合使用，比如ls -lah两者等效并且前后顺序没有影响。\ncdcd命令就是更改工作目录，语法是：\ncd [Linux路径]\n注：cd没有选项只有路径\ncd直接执行不写参数就是回到根目录\n绝对路径和相对路劲绝对路径即从根目录为起点，以 &#x2F; 开头\n相对路径从当前文件夹开始，不需要&#x2F;开头\n特殊路径符·**.** 表示当前目录     例：cd ./desktop就是切换到当前目录下的desktop目录内\n·**..**表示上一级目录     例：cd ../..  切换到上二级目录\n·**~**表示HOME目录     例：cd ~/desktop切换到根目录的desktop目录\npwd（Print Work Directory） 用于查看当前所在的工作目录\npwd没有选项，并且没有参数，直接执行即可\nmkdirmkdir命令（来自“Make Directory”）可以创建新的目录（文件夹）\n语法：mkdir [-p] Linux路径\n注：·参数必填，相对路径以及绝对路径均可    · -p选项可选，表示创建不存在父目录，适用于连续多级的目录    · 创建文件夹需要修改权限，在home目录内可以直接创建，在home目录之外需要权限\n例：mkdir pessenger，mkdir ./pessenger等\n选项-p-p 可以没有父目录的目录，用于创建连续目录\n例： mkdir -p /pessenger/hello/world\ntouch用来创建文件，语法：touch Linux路径 \n注：touch命令没有选项，但是参数必填\n例：touch text.txt \ncat查看文件内容,语法：cat Linux路径\n注：cat命令也没有路径且参数必填\n例：cat test.txt\nmore也可以查看文件内容，语法：more Linux路径\n注：more也没有选项且参数必填\n文件内操作·space键：下一页·ENTER键：：下一行·B键上一页·Q键退出\nmore与cat的区别·cat直接将内容全部展示出来·more支持翻页，若文件内容过多，可以一页页展示\n所以more较cat更适合大文件的查看\ncp复制文件&#x2F;文件夹（copy），语法：cp [-r] 参数1 参数2\n参数1：Linux路径，表示被复制的文件或者文件夹\n参数2：Linux路径，表示要复制去的文件或者文件夹\n选项-r用于复制文件夹用，表示递归\nmv用于移动文件夹&#x2F;文件（move），语法： mv 参数1 参数2\n参数1：Linux路径，表示被移动的文件或者文件夹\n参数2：Linux路径，表示要移动到的地方（若目标不存在则改名确保存在）\n例：若目标存在，比如：mv text.txt /desktop，text.txt就被移动到了desktop目录下    若目录不存在，比如：mv text.txt text2.txt(text1.txt不存在这个目录下)，text.txt就被重命名成了text1.txt\nrm用于删除文件&#x2F;文件夹（来自remove），语法：rm [-r -f] 参数1 参数2 …… 参数n\n参数为要删除的文件或者文件夹路径\n谨慎使用rm命令，尤其root用户时rm -rf/,rm -rf/*等效于电脑格式化（删光光）\n选项-r同cp命令，用于删除文件夹\n-f-f表示force，强制删除（不会弹出确认信息）\n注： ·普通用户删除内容不会弹出提示，只有root管理员用户删除内容会有提示 ·一般用户不使用-f选项\nwhich我们前面学的Linux命令，本体就是一个个二进制的可执行程序（相当于windows的exe文件）\nwhich命令查看一系列命令的程序文件存放在哪里，语法：which Linux命令\n例：which cd\nfind搜索指定的文件，语法：find 起始路径 -name &quot;被查找文件名&quot;（以文件名查找）                    find 起始路径 -size +/-n[kMG](以 大小查找文件)\n+、-表示大于小于；n表示大小数字；[]内为大小单位（k为kb，M为MB，G为GB）\n注：允许使用通配符\n例：find /desktop &quot;-name&quot; *text，find -size +1k\ngrep从文件中，通过关键字过滤文件行，语法：grep [-n] 关键词 文件路径\n选项-n（可选）：表示在结果中显示匹配行的行号\n参数·关键字（必填）：表示过滤的关键字，带有space或者其他特殊符号时建议用””把关键字包起来（建议一直使用“”包围）\n参数·文件路径（必填）：表示要过滤的文件的路径，可作为内容输入端口\n例：grep &quot;pessenger&quot; text.txt\nwc文件内容统计，包括行数，单词数量等，语法：wc [-c -m -l -w] 文件路径\n参数文件路径（必填），被统计路径，可作为内容输入端口\n例：wc -c test.txt\n选项-c统计bytes数量\n-m统计字符数量\n-l统计字数\n-w统计单词数量\necho在命令行内输出指定内容，语法：echo 输出内容\n注：无选项，参数较复杂时可用“”包围\n例：echo &quot;Hello Linux&quot;\ntail可以查看文件尾部内容，跟踪文件最新更改，语法：tail [-f -num] Linux路径\n·参数Linux路径：表示被追踪的文件路径\n例：tail test.txt\n选项-f表示持续追踪，例：tail -f test.txt（运行之后不会主动停止并一直更新用户在对参数对象操作之后的结果）\n注：CTRL+C强制停止运行\n-num表示查看尾部多少行，num为具体数字，不填默认10行，例：tail -5 test.txt\n\nVim&#x2F;Vi 编辑器Vi&#x2F;Vim是Linux最经典的文本编辑器（Vim是Vi的加强版）\n工作模式命令模式此模式下，所敲的按键编辑器都会理解为命令，用命令驱动不同功能。\n此模式下不能自由进行文本编辑\n输入模式编辑模式、插入模式\n此模式下，可以自由地对文件内容进行编辑\n底线命令模式以”:”开始，通常用于文件的保存退出\n打开编辑器时默认是命令模式\n*注：你可以从命令模式进入输入模式和底线命令模式，但是不可以从输入模式进入底线模式或相反，只能从两者回到命令模式再进入另一方\n用打开vi&#x2F;vim打开并编辑文件\nvi/vim 文件路径\n如果存在文件就打开，如果不存在就新建一个文件，再打开进行编辑\n命令模式的命令（缩写）表\n\n\n模式\n快捷键\n描述\n\n\n\n命令模式\ni\n在当前光标位置进入输入模式\n\n\n命令模式\na\n在当前光标位置之后进入输入模式\n\n\n命令模式\nI\n在当前行的开头进入输入模式\n\n\n命令模式\nA\n在当前行的结尾进入输入模式\n\n\n命令模式\no\n在当前光标的上一行进入输入模式\n\n\n命令模式\nO\n在当前光标的下一行进入输入模式\n\n\n输入模式\nesc\n任何情况下输入esc都能回到命令模式\n\n\n命令模式\n↑、k\n向上移动光标\n\n\n命令模式\n↓、j\n向下移动光标\n\n\n命令模式\n←，h\n向左移动光标\n\n\n命令模式\n→、l\n向右移动光标\n\n\n命令模式\n0\n移动光标到当前行的开头\n\n\n命令模式\n$\n移动光标到当前行的结尾\n\n\n命令模式\npageup（PgUp）\n向上翻页\n\n\n命令模式\npagedown（PgDn）\n向下翻页\n\n\n命令模式\n&#x2F;\n进入搜索模式\n\n\n命令模式\nn\n向下继续搜索\n\n\n命令模式\nN\n向上继续搜索\n\n\n命令模式\ndd\n删除光标所在行的内容\n\n\n命令模式\nndd\nn是数字，表示删除当前光标向下n行\n\n\n命令模式\nyy\n复制当前行\n\n\n命令模式\nnyy\nn位为数字，表示复制当前光标向下n行\n\n\n命令模式\np\n黏贴复制的内容\n\n\n命令模式\nu\n撤销修改\n\n\n命令模式\nCTRL+r\n反向撤销修改\n\n\n命令模式\ngg\n回到首行\n\n\n命令模式\nG\n跳到行尾\n\n\n命令模式\ndG\n从当前行开始删除下面所有内容\n\n\n命令模式\ndgg\n从当前行开始删除上面所有内容\n\n\n命令模式\ndS\n从当前光标开始删除到本行结尾\n\n\n命令模式\ndG\n从当前光标开始删除到本行开头\n\n\n命令模式\n:\n进入底线命令模式\n\n\n底线命令模式\n:wq\n保存并退出\n\n\n底线命令模式\n:q\n仅退出\n\n\n底线命令模式\n:q!\n强制退出\n\n\n底线命令模式\n:w\n仅保存\n\n\n底线命令模式\n:set nu\n显示行号\n\n\n底线命令模式\n:set paste\n设置黏贴模式（用于从外部复制内容，防止格式错乱）\n\n\n\nroot及相关root用户，即超级用户，是拥有最大权限的账户\nroot用户拥有一般用户没有的权限，例如：在根目录创建文件夹等\n普通用户的权限一般在HOME目录内是不受限的，一旦出了HOME目录，一般用户在大部分地方只有只读和执行权限，无修改权限\n切换用户我们可用使用su命令来切换用户（switch user）\n语法：su [-] [用户名]\n注：·“-”符号是可选的，表示是否加载环境变量，建议带上。·参数：用户名，表示要切换的用户，可省略，省略表示切换到root·切换用户后可用exit命令退回到上一个用户，也可以使用快捷键CTRL+D\n·普通用户切换到其他用户需要输入密码·root用户切换到其他用户不需要密码\nsudo命令长期使用root用户可能会对系统产生损坏，所以可以使用sudo来为普通命令授权，临时以root身份执行\n语法：sudo 其他命令\n在其他命令前带上sudo即可为这一条命令临时赋予root授权\n注：不是所有用户都有权利使用sudo，我们需要为普通用户配置sudo认证\n为普通用户配置sudo认证1.切换到root用户，执行visudo命令，会通过vi打开：&#x2F;etc&#x2F;sudoers\n2.在文件最后添加：用户名 ALL=(ALL)         NOPASSSWD:ALL其中：NOPASSSWD：ALL表示使用sudo命令无需输入密码\n3.使用wq保存\n4.换回普通用户即可使用\n用户以及用户组在Linux中可以：· 配置多个用户· 配置多个用户组· 用户可以加入到多个用户组中\nlinux系统中关于权限的管控级别有两个：\n\n针对用户的权限控制\n针对用户组的权限控制\n\n用户组及用户管理命令用户组以及用户相关命令只有root用户才可以执行\n用户组相关命令创建用户组：groupadd 用户组名称\n删除用户组：groupdel 用户组名称\n用户相关命令创建用户：useradd [-g 用户组 -d home目录] 用户名    ·选项-g：指定用户组，若不指定则创建一个与用户同名的用户组然后把这个用户塞进去（-g指定的组需要已存在，如果已存在同名的用户组，必须使用-g）    ·选项-d：指定用户的HOME目录，不指定就默认在：&#x2F;home&#x2F;用户名\n删除用户：userdel [-r] 用户名    ·选项-r：删除用户的home目录，如果不带则不删除\n产看用户所属组：id [用户名]    ·参数用户名：被查看的用户，不带就看自己\n修改用户所属组：user mod -aG 用户组 用户名将指定用户移动到指定用户组\ngetent命令：查看当前系统有哪些用户和用户组语法1：getent password（password是你的密码）\n每条结果包括七份信息，分别是：    用户名：密码（x）：用户ID：组ID：描述信息（没啥软用）：HOME目录：执行终端（默认bash）\n语法2：getent group\n每条结果包含三份信息，分别是：    组名称：组认证（显示为x）：组ID\n查看权限控制认知权限信息当你使用ls -l命令查看内容时，会显示权限细节。\n以一条结果为例：    drwxr-xr-x. 3 pessenger passenger 4 11月   4 5:14 Desktop        1       2     3其中：第一部分表示文件、文件夹的权限控制信息      第二部分表示文件、文件夹所属用户      第三部分：表示文件、文件夹所属用户组\n第一部分用于展示文件、文件夹的具体权限，可以分为十个槽位：-/d/l r/- w/- x/- r/- w/- x/- r/- w/- x/-\n· 第一块：-表示文件         d表示文件夹         l表示软链接· 第2-4块表示所属用户权限\n· 第5-7块表示所属用户组的权限\n· 第8-10块表示其他用户权限\nr 表示读权限w 表示写权限x 表示执行权限\n对于文件、文件夹的不同，rwx的含义有细微差别：· r 针对文件可以查看文件内容    针对文件夹可以查看文件夹内容（如ls命令）· w 针对文件可以修改文件内容    针对文件夹可以在文件夹内创建、删除、修改等操作· x 针对文件可表示将文件作为程序执行    针对文件夹可表示更改工作目录到这个文件夹，即cd进入\nchmod命令chomd命令用于修改文件、文件夹的权限信息\n注：只有文件、文件夹的所属用户或者root用户才可修改\n语法：chmod [-R] 权限 文件/文件夹· -R 对文件夹内所有内容应用同样操作\n例：chmod u=rwx,g=rx,o=x hello.txt将文件权限修改为rwxr-x–x    ·其中：u表示user所属用户权限，g表示group组权限，o表示other其他权限\nchmod语法也可以简化，例如：chmod 761 hello.txt\n这句命令相当于chmod u=rwx,g=rw,o=x hello.txt\n例句中的7、6、1分别将u、g、o的权限修改\n我们可以把三位上的每个数字分别理解为一个三位二进制数\n比如7就相当于111即rwx三个权限都有；6相当于110即拥有rw两个权限\n用这种表达可以更加快速便捷地执行chmod命令\nchown命令chown命令可以修改文件文件夹的所属用户和所属用户组\n注：普通用户无法修改所属为其他用户或族，此命令仅适用于root用户执行\n语法：chown [-R] [用户] [:] [用户组] [文件或者文件夹]    · 选项-R：同chmod    · 选项用户：修改所属用户    · 选项用户组：修改所属用户组    · “:”：用于分隔用户和用户组\n例：chown root hello.txt 将hello.txt所属用户组修改为root    chown root:pessenger hello.txt将hello.txt所属用户改为root，用户组改为pessenger\n实战训练用于练习，锻炼熟练度。本环节不会有较多的文字，只是作为实战过程中部分须注意点的记录。\n在Linux上部署各类软件","categories":["note","article"],"tags":["code","note"]},{"title":"生日蛋糕绘图","url":"/2023/10/25/%E7%94%9F%E6%97%A5%E8%9B%8B%E7%B3%95%E7%BB%98%E5%9B%BE/","content":"利用python画一个生日蛋糕！python画图主要是运用了turtle、math和random三个模块\nturtle用于画图，math用于数学计算而random用于最后乱七八糟的彩色点点的布局（我放不好，自己做的太丑了）\n代码是从我之前写的一个改过来的（我忘掉之前那个是从哪里抄来的了）\n具体代码如下：\n\nimport turtle as timport math as mimport random as rdef drawX(a, i):    angle = m.radians(i)    return a * m.cos(angle)def drawY(b, i):    angle = m.radians(i)    return b * m.sin(angle)# 设置背景颜色，窗口位置以及大小t.bgcolor(&quot;#d3dae8&quot;)t.setup(1000, 800)t.penup()t.goto(150, 0)t.pendown()# 1t.pencolor(&quot;white&quot;)t.begin_fill()for i in range(360):    x = drawX(150, i)    y = drawY(60, i)    t.goto(x, y)t.fillcolor(&quot;#fef5f7&quot;)t.end_fill()# 2t.begin_fill()for i in range(180):    x = drawX(150, -i)    y = drawY(70, -i)    t.goto(x, y)for i in range(180, 360):    x = drawX(150, i)    y = drawY(60, i)    t.goto(x, y)t.fillcolor(&quot;#f2d7dd&quot;)t.end_fill()# 3t.pu()t.goto(120, 0)t.pd()t.begin_fill()for i in range(360):    x = drawX(120, i)    y = drawY(48, i)    t.goto(x, y)t.fillcolor(&quot;#cbd9f9&quot;)t.end_fill()# 4t.begin_fill()t.pencolor(&quot;#fee48c&quot;)for i in range(540):    x = drawX(120, i)    y = drawY(48, i) + 70    t.goto(x, y)t.goto(-120, 0)t.fillcolor(&quot;#cbd9f9&quot;)t.end_fill()# 5t.pu()t.goto(120, 70)t.pd()t.pencolor(&quot;#fff0f3&quot;)t.begin_fill()for i in range(360):    x = drawX(120, i)    y = drawY(48, i) + 70    t.goto(x, y)t.fillcolor(&quot;#fff0f3&quot;)t.end_fill()# 6t.pu()t.goto(110, 70)t.pd()t.pencolor(&quot;#fff9fb&quot;)t.begin_fill()for i in range(360):    x = drawX(110, i)    y = drawY(44, i) + 70    t.goto(x, y)t.fillcolor(&quot;#fff9fb&quot;)t.end_fill()# 7t.pu()t.goto(120, 0)t.pd()t.begin_fill()t.pencolor(&quot;#ffa79d&quot;)for i in range(180):    x = drawX(120, -i)    y = drawY(48, -i) + 10    t.goto(x, y)t.goto(-120, 0)for i in range(180, 360):    x = drawX(120, i)    y = drawY(48, i)    t.goto(x, y)t.fillcolor(&quot;#ffa79d&quot;)t.end_fill()# 8t.pu()t.goto(120, 70)t.pd()t.begin_fill()t.pensize(4)t.pencolor(&quot;#fff0f3&quot;)for i in range(1800):    x = drawX(120, 0.1 * i)    y = drawY(-18, i) + 10    t.goto(x, y)t.goto(-120, 70)t.pensize(1)for i in range(180, 360):    x = drawX(120, i)    y = drawY(48, i) + 70    t.goto(x, y)t.fillcolor(&quot;#fff0f3&quot;)t.end_fill()# 9t.pu()t.goto(80, 70)t.pd()t.begin_fill()t.pencolor(&quot;#6f3732&quot;)t.goto(80, 120)for i in range(180):    x = drawX(80, i)    y = drawY(32, i) + 120    t.goto(x, y)t.goto(-80, 70)for i in range(180, 360):    x = drawX(80, i)    y = drawY(32, i) + 70    t.goto(x, y)t.fillcolor(&quot;#6f3732&quot;)t.end_fill()# 10t.pu()t.goto(80, 120)t.pd()t.pencolor(&quot;#ffaaa0&quot;)t.begin_fill()for i in range(360):    x = drawX(80, i)    y = drawY(32, i) + 120    t.goto(x, y)t.fillcolor(&quot;#ffaaa0&quot;)t.end_fill()# 11t.pu()t.goto(70, 120)t.pd()t.pencolor(&quot;#ffc3be&quot;)t.begin_fill()for i in range(360):    x = drawX(70, i)    y = drawY(28, i) + 120    t.goto(x, y)t.fillcolor(&quot;#ffc3be&quot;)t.end_fill()# 12t.pu()t.goto(80, 120)t.pd()t.begin_fill()t.pensize(3)t.pencolor(&quot;#ffaaa0&quot;)for i in range(1800):    x = drawX(80, 0.1 * i)    y = drawY(-12, i) + 80    t.goto(x, y)t.goto(-80, 120)t.pensize(1)for i in range(180, 360):    x = drawX(80, i)    y = drawY(32, i) + 120    t.goto(x, y)t.fillcolor(&quot;#ffaaa0&quot;)t.end_fill()# 13t.pu()t.goto(64, 120)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 60    y = drawY(1, i) + 120    t.goto(x, y)t.goto(64, 170)for i in range(540):    x = drawX(4, i) + 60    y = drawY(1, i) + 170    t.goto(x, y)t.goto(56, 120)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(64, 120 + 10 * i)    t.pu()    t.goto(56, 120 + 10 * i)    t.pd()t.pu()t.goto(60, 170)t.pd()t.goto(60, 180)t.pensize(1)#t.pu()t.goto(64, 190)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 60    y = drawY(10, i) + 190    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 14t.pu()t.goto(-56, 120)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 60    y = drawY(1, i) + 120    t.goto(x, y)t.goto(-56, 170)for i in range(540):    x = drawX(4, i) - 60    y = drawY(1, i) + 170    t.goto(x, y)t.goto(-64, 120)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(-56, 120 + 10 * i)    t.pu()    t.goto(-64, 120 + 10 * i)    t.pd()t.pu()t.goto(-60, 170)t.pd()t.goto(-60, 180)t.pensize(1)#t.pu()t.goto(-56, 190)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 60    y = drawY(10, i) + 190    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 15t.pu()t.goto(0, 130)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i)    y = drawY(1, i) + 130    t.goto(x, y)t.goto(4, 180)for i in range(540):    x = drawX(4, i)    y = drawY(1, i) + 180    t.goto(x, y)t.goto(-4, 130)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(4, 130 + 10 * i)    t.pu()    t.goto(-4, 130 + 10 * i)    t.pd()t.pu()t.goto(0, 180)t.pd()t.goto(0, 190)t.pensize(1)#t.pu()t.goto(4, 200)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i)    y = drawY(10, i) + 200    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 16t.pu()t.goto(30, 110)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 30    y = drawY(1, i) + 110    t.goto(x, y)t.goto(34, 160)for i in range(540):    x = drawX(4, i) + 30    y = drawY(1, i) + 160    t.goto(x, y)t.goto(26, 110)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(34, 110 + 10 * i)    t.pu()    t.goto(26, 110 + 10 * i)    t.pd()t.pu()t.goto(30, 160)t.pd()t.goto(30, 170)t.pensize(1)#t.pu()t.goto(34, 180)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) + 30    y = drawY(10, i) + 180    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()# 17t.pu()t.goto(-30, 110)t.pd()t.pencolor(&quot;#b1c9e9&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 30    y = drawY(1, i) + 110    t.goto(x, y)t.goto(-26, 160)for i in range(540):    x = drawX(4, i) - 30    y = drawY(1, i) + 160    t.goto(x, y)t.goto(-34, 110)t.fillcolor(&quot;#b1c9e9&quot;)t.end_fill()t.pencolor(&quot;white&quot;)t.pensize(2)for i in range(1, 6):    t.goto(-26, 110 + 10 * i)    t.pu()    t.goto(-34, 110 + 10 * i)    t.pd()t.pu()t.goto(-30, 160)t.pd()t.goto(-30, 170)t.pensize(1)#t.pu()t.goto(-26, 180)t.pd()t.pencolor(&quot;#f1add1&quot;)t.begin_fill()for i in range(360):    x = drawX(4, i) - 30    y = drawY(10, i) + 180    t.goto(x, y)t.fillcolor(&quot;#f1add1&quot;)t.end_fill()###随机color = [&quot;#e28cb9&quot;, &quot;#805a8c&quot;, &quot;#eaa989&quot;, &quot;#6e90b7&quot;, &quot;#b8b68f&quot;, &quot;#e174b5&quot;, &quot;#cf737c&quot;, &quot;#7c8782&quot;]for i in range(80):    t.pu()    x = r.randint(-120, 120)    y = r.randint(-25, 30)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(40):    t.pu()    x = r.randint(-90, 90)    y = r.randint(-35, 10)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(40):    t.pu()    x = r.randint(-80, 80)    y = r.randint(60, 90)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(30):    t.pu()    x = r.randint(-50, 50)    y = r.randint(45, 70)    t.goto(x, y)    t.pd()    t.dot(r.randint(2, 5), color[r.randint(0, 7)])for i in range(50):    t.pu()    x = r.randint(-500, 500)    y = r.randint(120, 300)    t.goto(x, y)    t.pd()    t.dot(r.randint(3, 5), color[r.randint(0, 7)])t.seth(90)t.pu()t.goto(0, 0)t.fd(210)t.left(90)t.fd(170)t.pd()t.write(&quot;Happy Birthday&quot;, font=(&quot;Curlz MT&quot;, 50))t.done()\n\n\n总之就是找点作图，难度不是很大，就是费神（这个艾斯比点怎么这么难找啊！）\n四百多行代码，祝你们看的愉快！  \n","categories":["article"],"tags":["code"]},{"title":"目猫老师我是你粉丝啊！","url":"/2023/10/27/%E7%9B%AE%E7%8C%AB%E8%80%81%E5%B8%88%E6%88%91%E6%98%AF%E4%BD%A0%E7%B2%89%E4%B8%9D%E5%95%8A%EF%BC%81/","content":"目猫老师我是你粉丝啊！！！输入 %eyecat输出 目猫：还是南通的氛围适合我\n","categories":["notice"],"tags":["life"]},{"title":"第一篇文章","url":"/2023/10/23/%E7%AC%AC%E4%B8%80%E7%AF%87%E6%96%87%E7%AB%A0/","content":"Hello！这是我发布的第一篇博客！\n欢迎你们将这个网站加入收藏夹\n我将不时更新一些我所接触的内容\n或者一些生活上的东西\n\n以下是一些小小的测试，只是做着玩的。这是我的GitHub主页，可以来看看，我会不时丢一些奇怪的内容上去：zjuter\n还有\n↓这是我老婆↓（ 是猫猫不是猪！！！）\n","categories":["notice"],"tags":["life"]},{"title":"使用hexo搭建个人博客","url":"/2023/10/28/%E4%BD%BF%E7%94%A8hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","content":"0基础使用hexo搭建个人博客先叠个甲：我是个菜鸡，如果有无请各位大佬提出助我更正！这个教程主要是提供一个大致的步骤。hexo是一个简洁高效的博客框架，利用hexo将服务器布局在github上可以做到零成本的个人博客搭建\n以下是大体的步骤\n1.前期准备\n2.hexo本地部署与上传\n3.个性化\n· 由于我个人是Windows系统，下列的操作我将以Windows系统为例，mac✌的操作步骤也是大致相同的，可以简单的代替一下部分语句进行操作。\n1.前期准备首先我们需要创建一个GitHub账户国内也有一些可以代替的网站比如Gitee等，但是没几个可以和GitHub比的，所以原则上我们最推荐GitHub\nGithub官网\n部分用户在打开GitHub时会有一些困难，可以耐心等待（或者开个魔法，也许有帮助？）\n具体步骤可以看这里GitHub注册\n然后我们就需要安装git这是下载的地址 git，你可以选择自己需要的版本下载。\n我也丢一个教程在这里：安装git（绝对不是因为我懒）\n安装完之后，任意页面右键出现git相关的选择项（主要是 git brash 就行了）\n完成以上步骤之后我们需要配置ssh老样子，丢个别人的教程 ssh配置 （就是懒行吧）\n之后就是安装node这是官网：ndoe.js\n注意：一定要选左边的！\n左边的是稳定版本，更加可靠，右边的是尝鲜版本，不是很稳定！\n下载完之后无脑继续就行了\n完成安装之后右键打开poweshell或者cmd（后面我就检测打开终端了）输入npm，看到版本号就说明安装成功了\n由于node是默认安装在C盘下面的，如果你对自己的C盘比较不自信，可以给node搬个家（我比较建议搬个家）\n你可以在其他盘想要的地方建一个文件夹（一定要英文名称，建议直接nodejs）\n然后在里面建node_global和node_cache两个文件夹\n打开终端，输入npm config set prefix &quot;nodejs文件位置\\node_global&quot;\n再输入node list -g查看是否更改成功（显示empty是正常的）\n同样的，我们再更改以下node_cache的位置npm config set cache &quot;nodejs的位置\\node_cache&quot;\n输入npm install express -g检测一下（安装报错就用管理员身份重新运行一下\n再输入npm list -g，这次不是empty说明成功了\n然后就是配置环境了！\n计算机右键属性-&gt;高级系统设置-&gt;path-&gt;编辑\n把原来的C:\\Users\\用户名\\AppData\\Roaming\\npm改为新的地址（node_global的位置）\n再新建系统变量NODE_PATH,变量值是node_golbal里面node_modules 的位置\n确定之后就配置完成了\n配置pnpm虽然node的npm已经足够大部分的使用了，但是他有一个致命的缺点：太慢了！\n这个时候我们就需要pnpm了！\npnpm适用范围极光，而且巨快！！，安装也相当简单\n打开终端，输入npm install -g pnpm或者npm install -g @pnpm/exe就好了\n安装完之后，我们还要配置一下镜像，一般来说用的是淘宝的镜像\n终端输入pnpm get registry,pnpm set registry https://registry.npm.taobao.org\n你也可以修改安装包的位置（其实没啥必要我就不展开了）\n然后你就可以愉快的使用pnpm了，就是这么简单（pnpm yyds！）\n2.hexo框架搭建完成前置点之后我们终于可以开始进入搭建环节了！\n先让我们检查一下\n终端输入node -v,pnpm -v和git --version\n有版本号就说明你已经准备好了\n首先链接GitHub设置用户名和邮箱git config --global user.name &quot;GitHub 用户名&quot;git config --global user.email &quot;GitHub 邮箱&quot;\n创建SSH密钥：输入ssh-keygen -t rsa -C &quot;GitHub邮箱&quot;然后一路回车\n进入用户下的.ssh目录（要开显示隐藏文件），用记事本打开id_rsa.pub并复制里面内容\n登录GitHub，进入setting，选择边栏的SSH and GPG keys，点击New SSH key\ntitle随便取，黏贴复制的内容，点Add SSH key完成添加\n然后就要验证链接了\n打开右键打开git brash，输入ssh -T git@github.com,出现“Are you sure……”,输入yes回车确定\n显示“hi ***!……”就成功了\n然后创建GitHub Page仓库GitHub主页右上角加号 -&gt; New repository\n·仓库名输入 用户名.github.io（必须是这个格式）\n·勾选“Initialize this repository with a README”\n其他随便\n最后点 Create repository \n开始正式搭建先在自己喜欢的位置创建一个文件夹（名字要是英文，建议直接blog，我就称这个文件夹为blog了）\n在blog里右键打开终端，输入pnpm install -g hexo-cli一键安装博客\n这个时候就可直观体会pnpm和npm的区别了，npm半天才能安装完，而pnpm只需要短短几秒\n下一步初始化并安装组件\n输入：hexo init,npm install就完成了\n是不是非常迅速？✌\n现在让我们启动一下试试\n输入hexo g完成本地部署\n再输入hexo s启动服务器\n他会跳出一个本地钉钉网址，按住CTRL点击就可以打开\n如果正常的打开了一个网址，恭喜你！你已经成功搭建了一个个人博客！（虽然只是在本地）\n下一步就是把你的博客部署到GitHub上了！\n按CTRL加C退出hexo，让我们先安装点插件\n首先，安装hexo-deployer-git:pnpm install hexo-deployer-git --save\n然后打开blog里面_config.yml文件的deployment部分，改成这样：\ndeploy:  type: git  repository: git@github.com:用户名/用户名.github.io.git  branch: master\n\n完成之后输入hexo d将网站上传部署到GitHub上\n在网页输入https://用户名.github.io就可以上你的个人博客了~\n在个人博客上上传自己的文章创建文章的快捷输入方式是hexo n &quot;文章名称&quot;\n创建之后就可以在blog里面blog\\source_posts位置找到新建的文章（结尾是.md）\n用vscode打开这个文件就可以编辑了！\n·注：md文件不是普通的txt或doc文件，他的编写也有些简单的语法，即MarkDown语法，具体怎么用可以看官方的文档MarkDown\n编辑完成并保存之后在blog里打开终端，输入hexo g,hexo d，一段时间之后你的网站里就会出现你的新文章了\n·注：文章更新需要一段时间，一时半会儿没别太急哈\n个人博客主页个性化首先，你要找一个喜欢的个性化页面\n这里我个人比较建议hexo自己给的个性化库hexo个性化库\n去里面找一个自己喜欢的模板，打开其对应的GitHub库，跟着操作一步步走就行了👍\n各个模板的操作可能不一样，我就不细说了，剩下就交给你自己慢慢探索了\n","categories":["article"],"tags":["code"]},{"title":"没钱力","url":"/2023/11/14/%E6%B2%A1%E9%92%B1%E5%8A%9B/","content":"震惊！生活费即将见底！我超为什么十一月才过了一半不到我的生活费就只剩一点点了！\n双十一甚至只买了两个东西（虽然每个都三百多……）\n但是真的要吃不起饭了！\n与我相依为命的只剩下没吃完的两箱泡面（哭\n\n最后的希望就是淘宝和拼多多（第一次不叫他拼夕夕woc）签到送的一两分钱了！\n老板们快扫扫下面的码爆爆金币（呜呜呜~\n\n（其实就是写个博客吐槽一下，日子还能过只是艰苦了亿点点……\n","categories":["notice"],"tags":["life"]},{"title":"电路学习笔记","url":"/2023/11/23/%E7%94%B5%E8%B7%AF%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"电路学习笔记前言一切为了机器人比赛！总之就是没有规则的乱记笔记，能看就行\n第一章1.3电功率和能量u、i的参考方向为关联参考方向的时候：\n计算元件吸收功率，·若p&gt;0，则说明该部分电路实际为吸收电功率（消耗能量），若p&lt;0，实际为发出电功率\n计算原件发出功率，·若结果p&gt;0，则说明此部分电路实际为发出电功率（提供能量），若p&lt;0，实际为吸收电功率\nu、i的参考方向为非关联参考方向的时候：\n计算原件发出的功率：·若结果p&gt;0。则说明该电路实际为发出电功率（提供能量），若p&lt;0，史记为吸收电功率。\n计算元件吸收功率，·若p&gt;0，则说明该部分电路实际为吸收电功率（消耗能量），若p&lt;0，实际为发出电功率\n电能：从t0到t的时间内，元件吸收的电能W为电力将单位时间正电荷由A点移动到B点时所作的功:\n电功率和电能单位：略（不会还有杂鱼不知道吧）\n1.4电路元件电路由电路元件组成，电路元件是电路中最基本的组成单元\n电路分为集总参数电路和分布参数电路\n· 电路元件特性：可用元件的两个端子的电路物理量之间的函数关系 （二端电路元件，简称电路元件、元件）\n · 集总参数原件，在元件外部不存在任何电场与磁场    · 在任何时刻，流入二端原件的一个端子的电流一定等于从另一个端子流出的电流且两个端子之间的电压为单值量[^1]: 即一个值对应唯一一个函数值。\n电流物理量：电压u、电流i、电荷q、磁通（磁链）元件特性：电压u、电流i、电荷q、磁通（磁链）之间的关系    例：点与原件·电阻元件特性：;电容元件特性：；电感元件特性：\n按元件特性可分为：    · 线性元件、非线性元件、时不变元件（特性参数不随时间变化，又称定常元件）、时变元件    · 无源元件、有源元件\n按元件与外部连接的端子数可分为：· 二段原件，三段原件，四段原件等\n1.5电阻元件电阻元件是反应能量损耗的模型，用于模拟电阻和其他实际部件的电阻特性\n分类近似于电路元件\n常见的电阻：普通金属膜电阻，绕线电阻，电阻排，热敏电阻\n电阻符号 \n服从欧姆定律 ,\nR —– 电阻元件的电阻，单位：欧姆（）G —– 电阻元件的电导，单位：西门子（S），\n伏安特性：电阻元件两端电压u与流过电流i间的关系也称为伏安特性\n4.功率：\n取关联参考方向，电阻元件吸收的顺时功率为：\n电阻是无源元件\n5.能量消耗\n从到时间内，元件吸收的电能为：\n电阻元件一般把吸收的电能转换成热能消耗掉\n实际的金属导体的电阻与导体的尺寸及材料的导电性能有关：\n1.6电压源和电流源1.电压源：有源二端元件，其端电压在任意瞬时与其端电流无关：    · 或者恒定不变——直流    · 或者按某一固有函数规律随时间而变化\n电压源的符号：左侧为通用符号，右侧为直流符号（在为交流电的时候不能使用右侧符号）\n2.伏安特性：交流电源：位置随时间而变化，恒压源：位置恒定不变\n电压源是一个理想的电路元件\n3.功率\n电流源：电流源是一个有源二端元件，其端电流在任一瞬时与其端电压无关：    ·或者恒定不变——直流    ·或者按照某一固有函数规律随时间变化\n电路符号：\n伏安特性：交流电流源：位置随时间的改变而改变恒流源：位置不随时间的改变而改变\n电流源是理想的二端元件\n电压源在实际运行时不允许短路，电流源在实际运行时不允许开路\n正弦电压源/正弦电流源：\n电压源或电流源随时间作正弦规律变化时\n电压源：\n1.7受控电源又称非独立电源（不同于电压源和电流源，受控电源的符号是一个棱形）\n提供的电压或电流，依赖于电路中另一支路的电压或电流。也就是说，只要电路中有一个支路的电压或电流受另一支路的电压或电流控制时，这两个支路就构成一个受控源。\n输出量：电压或电流控制量：电压或电流\n按受控源的分类：\n                        受控电源                           |         输出量为电压————————————————输出量为电流             ↓                          ↓         受控电压源                   受控电流源              |                          |控制量为电压——————控制量为电流 控制量为电压————控制量为电流     ↓                ↓           ↓              ↓电压控电压源      电流控电压源 电压控制电流源  电流控制电流源\n\n\n电压控制的电压源（VCVS）：——控制系数，常数，称为电压放大系数/转移电压比/无量纲\n电压控制的电流源（VCCS）：g——控制系数，常量，成为转移电导，具有电导的量纲（S）\n电流控制的电压源（CCVS）：r——控制系数，常量，称为转移电阻具有电阻的量纲（）\n电流控制的电流源（CCCS）：——控制系数，常量，称为电流放大系数/转移电流比/无量纲\n1.8基尔霍夫定律基尔霍夫\n                    基尔霍夫定律                            |        基尔霍夫电流定律——————————————基尔霍夫电压定律            （KCL）                     （KVL）              |                            |        |————————————|                |——————————|适用于电路中的  反映任一结点的各    适用于电路中  反映任一回路中任一“结点”     支路电流间相互约束   任一“回路”    各支路电压间相              的关系                           互约束的关系\n\n基尔霍夫定律是分析和计算电路的基本依据，是集总电路的基本定律\n有关术语：\n· 支路：每个二端元件可以构成一条支路· 结点：支路的连接点· 回路：由支路构成的闭合路径· 广义节点：由假想闭合面S包围的结点和支路的集合，S即为广义节点\n基尔霍夫电流定律：在集总电路中，任何时刻，对任一结点，所有流出结点的支路电流的代数和为零\n流出节点的电流和等于流入此节点的电流和\nKCL适用于闭合面，在任意瞬间，所有流出闭合面的支路电流代数和=0\n基尔霍夫电压定律；在集总参数电路中，任何时刻，任一回路，所有之路电压的代数和恒为0\n数学方程：\n小结：    · 基尔霍夫定律是分析和计算电路的基本依据        KCl:   KVL:    · KCL与元件性质无关，KCL方程的具体形式仅仅依赖于支路与结点的连接关系和支路电流的参考方向    · KVL与元件的性质无关，KVL方程的具体形式仅仅依赖于回路所关联的支路以及贿赂参考方向和回路中各支路电压的参考方向。\n两类约束：    · 元件的特性形成的约束        ——由元件的电压电流关系来体现                · 元件的相互连接给支路电流和支路电压之间带来的约束        ——由基尔霍夫定律体现，称为拓扑约束          \n第二章2.1引言线性电路：由线性无源元件、线性受控源和独立电源组成的电路\n电阻电路：构成线性电路的无源元件均为线性电阻\n直流电路：线性电路中的独立电源都是直流电源\n本章主要内容： 电阻电路的分析计算，介绍等效变换\n2.2电路等效变换等效变换条件：等效变换前后，被被替换部分电路电压与电流保持不变\n等效变换的实质：“对外等效”——u、i保持不变仅限于等效电路外\n2.3电阻的串联和并联串联：等效电阻\n 分压公式：$u_k=\\frac{R_k}{\\sum_{k=1}^{n}R_k}u=\\frac{R_k}{R_{eq}}u$\n\n并联：等效电阻\n  分流公式$i_k=G_ku=\\frac{G_k}{G_{eq}}i_S$\n\n    当$G_1=G_2=G_3=……=G_n$时,$i_k=\\frac{1}{n}i_S$\n\n    n=2时,$i_1=\\frac{G_1}{G_1+G_2}i_s$ 或者 $i_1=\\frac{R_2}{R_1+R_2}i_S$\n\n串联电阻电路可作为分压电路\n并联电阻电路可作为分流电路\n惠斯通电桥实验\n三角形连接-&gt;Y连接可以提高计算效率\nY连接，又称星型连接/T型连接\n","categories":["note","article"],"tags":["hardware","note"]},{"title":"关于11月27日自习打卡清单内容更新通知（）","url":"/2023/11/25/%E5%85%B3%E4%BA%8E11%E6%9C%8827%E6%97%A5%E8%87%AA%E4%B9%A0%E6%89%93%E5%8D%A1%E6%B8%85%E5%8D%95%E5%86%85%E5%AE%B9%E6%9B%B4%E6%96%B0%E9%80%9A%E7%9F%A5%EF%BC%88%EF%BC%89/","content":"#自习打卡#11月26日11：45闪断更新公告 \n感谢您对《每日自习打卡》的关注与支持。《每日自习打卡》计划将于2023年11月26日11:45 ~ 24:00 期间进行服务器闪断更新。届时将造成玩家强制掉线，无法登录，打卡天数清零等问题。为确保您的游戏内账号数据正常，请在本次闪断更新时提前结束自习。本次更新给各位用户带来的不便，敬请谅解！\n闪断更新时间：2023年11月26日11:45 ~ 24:00 期间\n更新内容：◆工图打卡量减少至一题&#x2F;天（原本为一页&#x2F;天）◆移动arduino课程至每日打卡栏◆新增51单片机入门课程至每日打卡栏◆四级备战日常打卡活动限时开始◆sw课程加入“周末打卡”专栏◆新增自由调度功能，允许在日程繁忙&#x2F;空闲的时候减少&#x2F;增加打卡量（但需保持总量&gt;&#x3D;原本量）◆将打卡汇报模块迁移至Bilibili平台◆将原本打卡清单更新公告迁移至个人博客平台，原微信平台仅提供链接◆预将”Linux学习打卡任务”修改为”Linux选择性复习任务”并移入选择性打卡模块\n闪断补偿：V我50专用二维码两张（见评论区上方“给穷逼一点钱吧！”可展开模块）补偿范围：2023年11月26日11:45更新前及以后所有注册并创建角色的玩家\n本次维护不排除延迟开启的可能，如若延迟则请关注官方发布的具体开服时间\n路过的过路人2023年11月25日\n","categories":["notice"],"tags":["notice"]},{"title":"51单片机入门学习笔记","url":"/2023/11/26/51%E5%8D%95%E7%89%87%E6%9C%BA%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","content":"51单片机学习笔记前言这篇文章是我在学习51单片机时的笔记\n学习视频链接：51单片机入门教程-2020版 程序全程纯手打 从零开始入门\n祝我学习顺利\n学习安排硬件要求：\n51单片机一只（淘宝很多），Windows系统电脑一台（苹果叉出去）\n软件要求：\nKeli5，STC-ISP\n单片机和开发板简介单片机，检测MCU，内部集成CPU、RAM、ROM、定时器等一系列电脑常用硬件\n单片机的任务是信息采集、处理、硬件设备\n单片机和计算机相比体积小但是性能较差，成本低结构简单\nunsigned int：无符号int（16位）型数据（单片机内int是默认有单位的）同理：unsigned short、unsigned long……\n祝：非整型除了unsigned char（8位十六进制数）不能加unsigned前缀表示无符号，unsigned和后面有空格\nLCD1602调试工具使用LCD1602液晶屏作为调试窗口\n使用液晶屏的时候数码管和LED模块因为引脚占用无法使用\n\n\n\n函数\n作用\n参数\n\n\n\nLCD_Init()\n初始化\n无\n\n\nLCD_ShowChar(1,1,’A’)\n显示一个字符\n行，列，现实的字符\n\n\nLCD_ShowString(1,3,”Hello”)\n显示字符串\n行，起始列，字符串\n\n\nLCD_ShowNum(1,9,123,3)\n显示十进制数字\n行，起始列，数字，数字长度（范围1-5）\n\n\nLCD_ShowSignedNum(2,1,-66，2)\n显示有符号十进制数字\n同上\n\n\nLCD_ShowHexNum(2,1,0xA8,2)\n显示十六进制数字\n同上\n\n\nLCD_ShowBinNum(2,4,0xAA,8)\n显示二进制数字\n行，起始列，数字（只能用十六进制数字代替），长度\n\n\n51单片机矩阵键盘51单片机中矩阵键盘接在STC89C52RC的10-17脚，我们可以通过逐列扫描的方法来完成对按键是否被按下进行确定，具体代码如下：\nunsigned char Matrixkey()&#123;\tunsigned char KeyNumber=0;\t\t// ????\tP1=0xFF;\tP1_3=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=1;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=5;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=9;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=13;&#125;\t\tP1=0xFF;\tP1_2=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=2;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=6;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=10;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=14;&#125;\t\tP1=0xFF;\tP1_1=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=3;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=7;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=11;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=15;&#125;\t\t\tP1=0xFF;\tP1_0=0;\tif(P1_7==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=4;&#125;\tif(P1_6==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=8;&#125;\tif(P1_5==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=12;&#125;\tif(P1_4==0)&#123;Delay(10);while(P1_7==0);Delay(10);KeyNumber=16;&#125;\t\treturn KeyNumber;&#125;\n\n这里我们声明了一个扫描的函数，在你按下后松开之前函数不会继续进行但是手松开之后会返回你按下按键对应的数值。\n利用这个键盘我们可以完成一些简单的功能，比如说下面的代码利用矩阵键盘完成了一个简单的个位数计算器（Matrixkey（）函数在Matrixkey头文件中定义了）：\n#include &lt;REGX52.H&gt;#include &quot;Matrixkey.h&quot;#include &quot;Delay.h&quot;#include &quot;LCD1602.h&quot;int Num1 = 0, Num2 = 0, Num3 = 0;int Answer = 0;unsigned char b;void main()&#123;    LCD_Init();    while (1)    &#123;        LCD_ShowString(1, 1, &quot;Input equations&quot;);        while (Num1 &gt;= 10 || Num1 == 0)        &#123;            Num1 = Matrixkey();        &#125;        LCD_ShowNum(2, 1, Num1, 1);        while (Num2 &gt;= 14 || Num2 &lt;= 9)        &#123;            Num2 = Matrixkey();        &#125;        if (Num2 == 10)        &#123;            b = &#x27;+&#x27;;            LCD_ShowString(2, 2, &quot;+&quot;);        &#125;        else if (Num2 == 11)        &#123;            b = &#x27;-&#x27;;            LCD_ShowString(2, 2, &quot;-&quot;);        &#125;        else if (Num2 == 12)        &#123;            b = &#x27;*&#x27;;            LCD_ShowString(2, 2, &quot;*&quot;);        &#125;        else if (Num2 == 13)        &#123;            b = &#x27;/&#x27;;            LCD_ShowString(2, 2, &quot;/&quot;);        &#125;        while (Num3 &gt;= 10 || Num3 == 0)        &#123;            Num3 = Matrixkey();        &#125;        LCD_ShowNum(2, 3, Num3, 1);        if (b == &#x27;+&#x27;)        &#123;            Answer = Num1 + Num3;        &#125;        else if (b == &#x27;-&#x27;)        &#123;            Answer = Num1 - Num3;        &#125;        else if (b == &#x27;*&#x27;)        &#123;            Answer = Num1 * Num3;        &#125;        else if (b == &#x27;/&#x27;)        &#123;            Answer = Num1 / Num3;        &#125;\t\t\t\tLCD_ShowString(2,4,&quot;=&quot;);\t\t\t\tif(Answer&lt;0)\t\t\t\t&#123;\t\t\t\t\tAnswer=-Answer;\t\t\t\t\tLCD_ShowString(2,5,&quot;-&quot;);\t\t\t\t\tLCD_ShowNum(2, 6, Answer, 2);\t\t\t\t&#125;else\t\t\t\t&#123;\t\t\t\t\tLCD_ShowSignedNum(2, 5, Answer, 2);\t\t\t\t&#125;                Num1 = Num2 = Num3 = 0;        Delay(1);    &#125;&#125;\n\n\n蜂鸣器蜂鸣器分为有源蜂鸣器和无源蜂鸣器，其中的“源”指的是震荡源有源蜂鸣器只要通电就可以发声，但是振荡频率固定无源蜂鸣器内部不带振荡源，需要提供振荡脉冲的频率，但是发声频率可以调整\n正负极看标志或者长短脚（长脚为正极）\n串口TXD &#x3D; transmit exchange dataRXD &#x3D; receive ~ ~TXD和RXD要交叉连接，VCC和GND对接\n只需单项数据传输时，可以只连接一根通信线\n当电平标准不一致时，需要加电平转换芯片\n\n电平标准是与数据对应关系1和0的表达方式，是传输线缆中人为规定的电压，常用的有以下三种TTL电平：+5V表示1，0V表示0；RS232电平：-3——-5V表示1，+3——+15V表示0RS485电平：两线压差+2——+6V表示1，-2——-6V表示0（差分信号）’前两者距离短，容忍电压大，常用于电脑等，后者距离远可达1km\n\n相关术语：· 全双工 ： 通信双方可以在同一时刻相互传输数据· 半双工 ： 通信双方可以相互传输数据，但是必须分时复用一根数据线· 单工 ： 通信只能由一方发送到另一方，不能反向传输\n· 异步 ： 通信双方各自约定通信速率· 同步 ： 通信双方靠一根时钟线来约定通信速率\n· 总线：连接各个设备的数据的传输线路\n· 波特率：串口通信的速率（发送和接受各数据位ied间隔时间）\n—目前已学习完毕，暂时不考虑继续更新—\n","categories":["note","article"],"tags":["SCM","hardware","note"]},{"title":"STM32学习笔记（不定时更新）","url":"/2024/01/31/STM32%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%8D%E5%AE%9A%E6%97%B6%E6%9B%B4%E6%96%B0%EF%BC%89/","content":"STM32学习笔记1-新建工程新建工程时要选择启动文件，其选择依据芯片类型，具体见下表\n\n\n\n缩写\n释义\nFlash容量\n型号\n\n\n\nDL_VL\n小容量产品超值系列\n16-32K\nSTM32F100\n\n\nMD_VL\n中容量产品超值系列\n64-128K\nSTM32F100\n\n\nHD_VL\n大容量产品超值系列\n256-512K\nSTM32F100\n\n\nLD\n小容量产品\n16-32K\nSTM32F101&#x2F;102&#x2F;103\n\n\nMD\n中容量产品\n64-128K\nSTM32F101&#x2F;102&#x2F;103\n\n\nHL\n大容量产品\n256-512K\nSTM32F101&#x2F;102&#x2F;103\n\n\nXL\n加大容量产品\n大于512K\nSTM32F101&#x2F;102&#x2F;103\n\n\nCL\n互联型产品\n-\nSTM32F105&#x2F;107\n\n\n总结：新建工程的步骤：· 建立工程文件夹，Keil中新建工程，选择型号· 工程文件夹里建立StartLibrary、User等文件夹，2复制固件库里面的文件到工程文件夹· 工程里对应建立Start、Library、User等同名称的分组，然后将文件夹的文件添加到工程分组里· 工程选项，C&#x2F;C++，Include Paths内声明所有包含头文件的文件夹· 工程选项，C&#x2F;C++，Define内定义USE_STDPERIPH_DRIVER· 工程选项，Debug，下拉列表选择对应调试器，Settings,FlashDownload里勾选Reset and Run\n工程架构：\nstartup_xx.c：                  system_xx.c/.h:         stm32f10x.h:    复位中断：                     定义Systeminit           外设寄存器描述        调用Systeminit          main.c:                 core_cm3.c/.h:        调用main                    定义main                内核寄存器描述    其他中断：                  stm32f10x_it.c/.h:      misc.c/.h,stm32f10x_abc.c/.h…：        调用中断                    定义中断                库函数        处理函数                    处理函数            stm32f10x_conf.h:                                其他用户文件                库函数配置\n\n2-GPIOGPIO简介GPIO即通用输入输出口可配置8种输入输出模式引脚：0-3.3V，部分可容忍5V\n输出模式下可以控制端口输出高低电平，用以驱动LED、控制蜂鸣器、模拟通信协议输出时序等输入模式下可读取端口的高低电平或电压，用于读取按键输入、外接模块电平信号输入、ADC电压采集、模拟通信协议接收数据等\nGPIO基本结构\n由于stm32是32位的单片机，stm32内部的寄存器都是32位的，但是端口只有16个，所以寄存器只有低16位有对应端口\n注：输入驱动器中的肖特基触发器实际为施密特触发器，此处为翻译错误\n施密特触发器：当电压高于一定值的时候立马输出高电压，当电压低于一定值的时候立马输出低电压，处于中间保持此处用于整形，防止信号失真\n\n输出数据清除器同时控制16个端口且只能整体读写，想要控制个别位需要用”&amp;&#x3D;”以及”|&#x3D;”的方法，比较麻烦，利用前面的位设置&#x2F;清除寄存器可以仅控制输出数据寄存器的某一位而不影响其他位\n输出控制有推挽、开漏、关闭三种输出模式\n\n推挽：此模式下，P-MOS和N-MOS均有效。数据寄存器为1时，P导通N断开，输出接VDD，高电平；数据寄存器为0时，P断开N导通，输出接VSS，低电平。此状态下高低电平均有较强驱动能力，所以又称强推输出模式。\n\n开漏：此模式下P-MOS无效，N-MOS有效。数据寄存器为1时，N断开，相当于输出断开，也就是高阻模式；数据寄存器为0时，N导通，输出接VSS，低电平。此模式可以作为通信协议的驱动模式，如I2C，此模式下可以避免各个设备的相互干扰；同时在此模式下，通过在IO口外接上拉电源（以5V为例），数据寄存器输出1时由外部电路上拉到5V，就可以兼容5V的设备。\n\n关闭，此时P-MOS和N-MOS均关闭，IO口由外部电路控制。\n\n\nGPIO模式通过配置GPIO的端口寄存器，端口可配置成以下8种模式\n四种输出方式：　　（1）推挽输出   可输出引脚电平，高电平为高阻态，低电平接VSS　　（2）开漏输出   可输出引脚电平，高电平接VDD，低电平接VSS　　（3）复用推挽   由片上外设控制，高电平为高阻态，低电平接VSS　　（4）复用开漏   由片上外设控制，高电平接VDD，低电平接VSS\n四种输入方式：　　（1）浮空输入   可读取引脚电平，若引脚悬空，则电平不确定　　（2）上拉输入   可读取引脚电平，内部连接上拉电阻，悬空时默认高电平　　（3）下拉输入   可读取引脚电平，内部连接下拉电阻，悬空时默认低电平　　（4）模拟输入   GPIO无效，引脚直接接入内部ADC\n浮空&#x2F;上拉&#x2F;下拉输入\n在输入模式下，输出寄存器是断开的，端口只能输入而不能输出。输入寄存器的两个的电阻可以上拉工作下拉工作或者都不工作，对应上拉输入下拉输入和浮空输入。右侧保护二极管，VDD和VDD_FT不同，后者对5V容忍IO脚是特殊的\n模拟输入\n在次模式下，IO口直接模拟输入，其余部分全部无效\n开漏&#x2F;推挽输出","categories":["note","article"],"tags":["SCM","hardware","note"]}]